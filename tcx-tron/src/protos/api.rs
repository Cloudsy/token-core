// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `api/api.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct Return {
    // message fields
    pub result: bool,
    pub code: Return_response_code,
    pub message: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Return {
    fn default() -> &'a Return {
        <Return as ::protobuf::Message>::default_instance()
    }
}

impl Return {
    pub fn new() -> Return {
        ::std::default::Default::default()
    }

    // bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }

    // .protocol.Return.response_code code = 2;


    pub fn get_code(&self) -> Return_response_code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = Return_response_code::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Return_response_code) {
        self.code = v;
    }

    // bytes message = 3;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Return {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != false {
            my_size += 2;
        }
        if self.code != Return_response_code::SUCCESS {
            my_size += ::protobuf::rt::enum_size(2, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.result != false {
            os.write_bool(1, self.result)?;
        }
        if self.code != Return_response_code::SUCCESS {
            os.write_enum(2, self.code.value())?;
        }
        if !self.message.is_empty() {
            os.write_bytes(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Return {
        Return::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &Return| { &m.result },
                    |m: &mut Return| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Return_response_code>>(
                    "code",
                    |m: &Return| { &m.code },
                    |m: &mut Return| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message",
                    |m: &Return| { &m.message },
                    |m: &mut Return| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Return>(
                    "Return",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Return {
        static mut instance: ::protobuf::lazy::Lazy<Return> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Return,
        };
        unsafe {
            instance.get(Return::new)
        }
    }
}

impl ::protobuf::Clear for Return {
    fn clear(&mut self) {
        self.result = false;
        self.code = Return_response_code::SUCCESS;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Return {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Return {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Return_response_code {
    SUCCESS = 0,
    SIGERROR = 1,
    CONTRACT_VALIDATE_ERROR = 2,
    CONTRACT_EXE_ERROR = 3,
    BANDWITH_ERROR = 4,
    DUP_TRANSACTION_ERROR = 5,
    TAPOS_ERROR = 6,
    TOO_BIG_TRANSACTION_ERROR = 7,
    TRANSACTION_EXPIRATION_ERROR = 8,
    SERVER_BUSY = 9,
    NO_CONNECTION = 10,
    NOT_ENOUGH_EFFECTIVE_CONNECTION = 11,
    OTHER_ERROR = 20,
}

impl ::protobuf::ProtobufEnum for Return_response_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Return_response_code> {
        match value {
            0 => ::std::option::Option::Some(Return_response_code::SUCCESS),
            1 => ::std::option::Option::Some(Return_response_code::SIGERROR),
            2 => ::std::option::Option::Some(Return_response_code::CONTRACT_VALIDATE_ERROR),
            3 => ::std::option::Option::Some(Return_response_code::CONTRACT_EXE_ERROR),
            4 => ::std::option::Option::Some(Return_response_code::BANDWITH_ERROR),
            5 => ::std::option::Option::Some(Return_response_code::DUP_TRANSACTION_ERROR),
            6 => ::std::option::Option::Some(Return_response_code::TAPOS_ERROR),
            7 => ::std::option::Option::Some(Return_response_code::TOO_BIG_TRANSACTION_ERROR),
            8 => ::std::option::Option::Some(Return_response_code::TRANSACTION_EXPIRATION_ERROR),
            9 => ::std::option::Option::Some(Return_response_code::SERVER_BUSY),
            10 => ::std::option::Option::Some(Return_response_code::NO_CONNECTION),
            11 => ::std::option::Option::Some(Return_response_code::NOT_ENOUGH_EFFECTIVE_CONNECTION),
            20 => ::std::option::Option::Some(Return_response_code::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Return_response_code] = &[
            Return_response_code::SUCCESS,
            Return_response_code::SIGERROR,
            Return_response_code::CONTRACT_VALIDATE_ERROR,
            Return_response_code::CONTRACT_EXE_ERROR,
            Return_response_code::BANDWITH_ERROR,
            Return_response_code::DUP_TRANSACTION_ERROR,
            Return_response_code::TAPOS_ERROR,
            Return_response_code::TOO_BIG_TRANSACTION_ERROR,
            Return_response_code::TRANSACTION_EXPIRATION_ERROR,
            Return_response_code::SERVER_BUSY,
            Return_response_code::NO_CONNECTION,
            Return_response_code::NOT_ENOUGH_EFFECTIVE_CONNECTION,
            Return_response_code::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Return_response_code", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Return_response_code {
}

impl ::std::default::Default for Return_response_code {
    fn default() -> Self {
        Return_response_code::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for Return_response_code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockReference {
    // message fields
    pub block_num: i64,
    pub block_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReference {
    fn default() -> &'a BlockReference {
        <BlockReference as ::protobuf::Message>::default_instance()
    }
}

impl BlockReference {
    pub fn new() -> BlockReference {
        ::std::default::Default::default()
    }

    // int64 block_num = 1;


    pub fn get_block_num(&self) -> i64 {
        self.block_num
    }
    pub fn clear_block_num(&mut self) {
        self.block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_num(&mut self, v: i64) {
        self.block_num = v;
    }

    // bytes block_hash = 2;


    pub fn get_block_hash(&self) -> &[u8] {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.block_num = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.block_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.block_num != 0 {
            os.write_int64(1, self.block_num)?;
        }
        if !self.block_hash.is_empty() {
            os.write_bytes(2, &self.block_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReference {
        BlockReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "block_num",
                    |m: &BlockReference| { &m.block_num },
                    |m: &mut BlockReference| { &mut m.block_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "block_hash",
                    |m: &BlockReference| { &m.block_hash },
                    |m: &mut BlockReference| { &mut m.block_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockReference>(
                    "BlockReference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockReference {
        static mut instance: ::protobuf::lazy::Lazy<BlockReference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockReference,
        };
        unsafe {
            instance.get(BlockReference::new)
        }
    }
}

impl ::protobuf::Clear for BlockReference {
    fn clear(&mut self) {
        self.block_num = 0;
        self.block_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WitnessList {
    // message fields
    pub witnesses: ::protobuf::RepeatedField<super::Tron::Witness>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WitnessList {
    fn default() -> &'a WitnessList {
        <WitnessList as ::protobuf::Message>::default_instance()
    }
}

impl WitnessList {
    pub fn new() -> WitnessList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Witness witnesses = 1;


    pub fn get_witnesses(&self) -> &[super::Tron::Witness] {
        &self.witnesses
    }
    pub fn clear_witnesses(&mut self) {
        self.witnesses.clear();
    }

    // Param is passed by value, moved
    pub fn set_witnesses(&mut self, v: ::protobuf::RepeatedField<super::Tron::Witness>) {
        self.witnesses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_witnesses(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Witness> {
        &mut self.witnesses
    }

    // Take field
    pub fn take_witnesses(&mut self) -> ::protobuf::RepeatedField<super::Tron::Witness> {
        ::std::mem::replace(&mut self.witnesses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WitnessList {
    fn is_initialized(&self) -> bool {
        for v in &self.witnesses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.witnesses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.witnesses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.witnesses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WitnessList {
        WitnessList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Witness>>(
                    "witnesses",
                    |m: &WitnessList| { &m.witnesses },
                    |m: &mut WitnessList| { &mut m.witnesses },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WitnessList>(
                    "WitnessList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WitnessList {
        static mut instance: ::protobuf::lazy::Lazy<WitnessList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WitnessList,
        };
        unsafe {
            instance.get(WitnessList::new)
        }
    }
}

impl ::protobuf::Clear for WitnessList {
    fn clear(&mut self) {
        self.witnesses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WitnessList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WitnessList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposalList {
    // message fields
    pub proposals: ::protobuf::RepeatedField<super::Tron::Proposal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalList {
    fn default() -> &'a ProposalList {
        <ProposalList as ::protobuf::Message>::default_instance()
    }
}

impl ProposalList {
    pub fn new() -> ProposalList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Proposal proposals = 1;


    pub fn get_proposals(&self) -> &[super::Tron::Proposal] {
        &self.proposals
    }
    pub fn clear_proposals(&mut self) {
        self.proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposals(&mut self, v: ::protobuf::RepeatedField<super::Tron::Proposal>) {
        self.proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proposals(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Proposal> {
        &mut self.proposals
    }

    // Take field
    pub fn take_proposals(&mut self) -> ::protobuf::RepeatedField<super::Tron::Proposal> {
        ::std::mem::replace(&mut self.proposals, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProposalList {
    fn is_initialized(&self) -> bool {
        for v in &self.proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proposals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.proposals {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalList {
        ProposalList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Proposal>>(
                    "proposals",
                    |m: &ProposalList| { &m.proposals },
                    |m: &mut ProposalList| { &mut m.proposals },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalList>(
                    "ProposalList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalList {
        static mut instance: ::protobuf::lazy::Lazy<ProposalList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalList,
        };
        unsafe {
            instance.get(ProposalList::new)
        }
    }
}

impl ::protobuf::Clear for ProposalList {
    fn clear(&mut self) {
        self.proposals.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExchangeList {
    // message fields
    pub exchanges: ::protobuf::RepeatedField<super::Tron::Exchange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeList {
    fn default() -> &'a ExchangeList {
        <ExchangeList as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeList {
    pub fn new() -> ExchangeList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Exchange exchanges = 1;


    pub fn get_exchanges(&self) -> &[super::Tron::Exchange] {
        &self.exchanges
    }
    pub fn clear_exchanges(&mut self) {
        self.exchanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_exchanges(&mut self, v: ::protobuf::RepeatedField<super::Tron::Exchange>) {
        self.exchanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exchanges(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Exchange> {
        &mut self.exchanges
    }

    // Take field
    pub fn take_exchanges(&mut self) -> ::protobuf::RepeatedField<super::Tron::Exchange> {
        ::std::mem::replace(&mut self.exchanges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExchangeList {
    fn is_initialized(&self) -> bool {
        for v in &self.exchanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exchanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.exchanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.exchanges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeList {
        ExchangeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Exchange>>(
                    "exchanges",
                    |m: &ExchangeList| { &m.exchanges },
                    |m: &mut ExchangeList| { &mut m.exchanges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExchangeList>(
                    "ExchangeList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExchangeList {
        static mut instance: ::protobuf::lazy::Lazy<ExchangeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExchangeList,
        };
        unsafe {
            instance.get(ExchangeList::new)
        }
    }
}

impl ::protobuf::Clear for ExchangeList {
    fn clear(&mut self) {
        self.exchanges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssetIssueList {
    // message fields
    pub assetIssue: ::protobuf::RepeatedField<super::Contract::AssetIssueContract>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIssueList {
    fn default() -> &'a AssetIssueList {
        <AssetIssueList as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueList {
    pub fn new() -> AssetIssueList {
        ::std::default::Default::default()
    }

    // repeated .protocol.AssetIssueContract assetIssue = 1;


    pub fn get_assetIssue(&self) -> &[super::Contract::AssetIssueContract] {
        &self.assetIssue
    }
    pub fn clear_assetIssue(&mut self) {
        self.assetIssue.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetIssue(&mut self, v: ::protobuf::RepeatedField<super::Contract::AssetIssueContract>) {
        self.assetIssue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetIssue(&mut self) -> &mut ::protobuf::RepeatedField<super::Contract::AssetIssueContract> {
        &mut self.assetIssue
    }

    // Take field
    pub fn take_assetIssue(&mut self) -> ::protobuf::RepeatedField<super::Contract::AssetIssueContract> {
        ::std::mem::replace(&mut self.assetIssue, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AssetIssueList {
    fn is_initialized(&self) -> bool {
        for v in &self.assetIssue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assetIssue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.assetIssue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.assetIssue {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIssueList {
        AssetIssueList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Contract::AssetIssueContract>>(
                    "assetIssue",
                    |m: &AssetIssueList| { &m.assetIssue },
                    |m: &mut AssetIssueList| { &mut m.assetIssue },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssetIssueList>(
                    "AssetIssueList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssetIssueList {
        static mut instance: ::protobuf::lazy::Lazy<AssetIssueList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssetIssueList,
        };
        unsafe {
            instance.get(AssetIssueList::new)
        }
    }
}

impl ::protobuf::Clear for AssetIssueList {
    fn clear(&mut self) {
        self.assetIssue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIssueList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockList {
    // message fields
    pub block: ::protobuf::RepeatedField<super::Tron::Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockList {
    fn default() -> &'a BlockList {
        <BlockList as ::protobuf::Message>::default_instance()
    }
}

impl BlockList {
    pub fn new() -> BlockList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Block block = 1;


    pub fn get_block(&self) -> &[super::Tron::Block] {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::protobuf::RepeatedField<super::Tron::Block>) {
        self.block = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Block> {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::protobuf::RepeatedField<super::Tron::Block> {
        ::std::mem::replace(&mut self.block, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockList {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.block {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.block {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockList {
        BlockList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Block>>(
                    "block",
                    |m: &BlockList| { &m.block },
                    |m: &mut BlockList| { &mut m.block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockList>(
                    "BlockList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockList {
        static mut instance: ::protobuf::lazy::Lazy<BlockList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockList,
        };
        unsafe {
            instance.get(BlockList::new)
        }
    }
}

impl ::protobuf::Clear for BlockList {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionList {
    // message fields
    pub transaction: ::protobuf::RepeatedField<super::Tron::Transaction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionList {
    fn default() -> &'a TransactionList {
        <TransactionList as ::protobuf::Message>::default_instance()
    }
}

impl TransactionList {
    pub fn new() -> TransactionList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &[super::Tron::Transaction] {
        &self.transaction
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::protobuf::RepeatedField<super::Tron::Transaction>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Transaction> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::protobuf::RepeatedField<super::Tron::Transaction> {
        ::std::mem::replace(&mut self.transaction, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionList {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transaction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transaction {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionList {
        TransactionList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Transaction>>(
                    "transaction",
                    |m: &TransactionList| { &m.transaction },
                    |m: &mut TransactionList| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionList>(
                    "TransactionList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionList {
        static mut instance: ::protobuf::lazy::Lazy<TransactionList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionList,
        };
        unsafe {
            instance.get(TransactionList::new)
        }
    }
}

impl ::protobuf::Clear for TransactionList {
    fn clear(&mut self) {
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DelegatedResourceMessage {
    // message fields
    pub fromAddress: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceMessage {
    fn default() -> &'a DelegatedResourceMessage {
        <DelegatedResourceMessage as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceMessage {
    pub fn new() -> DelegatedResourceMessage {
        ::std::default::Default::default()
    }

    // bytes fromAddress = 1;


    pub fn get_fromAddress(&self) -> &[u8] {
        &self.fromAddress
    }
    pub fn clear_fromAddress(&mut self) {
        self.fromAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_fromAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.fromAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.fromAddress
    }

    // Take field
    pub fn take_fromAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.fromAddress, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DelegatedResourceMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.fromAddress)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fromAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.fromAddress);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.fromAddress.is_empty() {
            os.write_bytes(1, &self.fromAddress)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResourceMessage {
        DelegatedResourceMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "fromAddress",
                    |m: &DelegatedResourceMessage| { &m.fromAddress },
                    |m: &mut DelegatedResourceMessage| { &mut m.fromAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAddress",
                    |m: &DelegatedResourceMessage| { &m.toAddress },
                    |m: &mut DelegatedResourceMessage| { &mut m.toAddress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelegatedResourceMessage>(
                    "DelegatedResourceMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DelegatedResourceMessage {
        static mut instance: ::protobuf::lazy::Lazy<DelegatedResourceMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DelegatedResourceMessage,
        };
        unsafe {
            instance.get(DelegatedResourceMessage::new)
        }
    }
}

impl ::protobuf::Clear for DelegatedResourceMessage {
    fn clear(&mut self) {
        self.fromAddress.clear();
        self.toAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResourceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DelegatedResourceList {
    // message fields
    pub delegatedResource: ::protobuf::RepeatedField<super::Tron::DelegatedResource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceList {
    fn default() -> &'a DelegatedResourceList {
        <DelegatedResourceList as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceList {
    pub fn new() -> DelegatedResourceList {
        ::std::default::Default::default()
    }

    // repeated .protocol.DelegatedResource delegatedResource = 1;


    pub fn get_delegatedResource(&self) -> &[super::Tron::DelegatedResource] {
        &self.delegatedResource
    }
    pub fn clear_delegatedResource(&mut self) {
        self.delegatedResource.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegatedResource(&mut self, v: ::protobuf::RepeatedField<super::Tron::DelegatedResource>) {
        self.delegatedResource = v;
    }

    // Mutable pointer to the field.
    pub fn mut_delegatedResource(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::DelegatedResource> {
        &mut self.delegatedResource
    }

    // Take field
    pub fn take_delegatedResource(&mut self) -> ::protobuf::RepeatedField<super::Tron::DelegatedResource> {
        ::std::mem::replace(&mut self.delegatedResource, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DelegatedResourceList {
    fn is_initialized(&self) -> bool {
        for v in &self.delegatedResource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.delegatedResource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.delegatedResource {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.delegatedResource {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResourceList {
        DelegatedResourceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::DelegatedResource>>(
                    "delegatedResource",
                    |m: &DelegatedResourceList| { &m.delegatedResource },
                    |m: &mut DelegatedResourceList| { &mut m.delegatedResource },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelegatedResourceList>(
                    "DelegatedResourceList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DelegatedResourceList {
        static mut instance: ::protobuf::lazy::Lazy<DelegatedResourceList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DelegatedResourceList,
        };
        unsafe {
            instance.get(DelegatedResourceList::new)
        }
    }
}

impl ::protobuf::Clear for DelegatedResourceList {
    fn clear(&mut self) {
        self.delegatedResource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResourceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeList {
    // message fields
    pub nodes: ::protobuf::RepeatedField<Node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeList {
    fn default() -> &'a NodeList {
        <NodeList as ::protobuf::Message>::default_instance()
    }
}

impl NodeList {
    pub fn new() -> NodeList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Node nodes = 1;


    pub fn get_nodes(&self) -> &[Node] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeList {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeList {
        NodeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                    "nodes",
                    |m: &NodeList| { &m.nodes },
                    |m: &mut NodeList| { &mut m.nodes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeList>(
                    "NodeList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeList {
        static mut instance: ::protobuf::lazy::Lazy<NodeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeList,
        };
        unsafe {
            instance.get(NodeList::new)
        }
    }
}

impl ::protobuf::Clear for NodeList {
    fn clear(&mut self) {
        self.nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    pub address: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // .protocol.Address address = 1;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "address",
                    |m: &Node| { &m.address },
                    |m: &mut Node| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Node>(
                    "Node",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Node {
        static mut instance: ::protobuf::lazy::Lazy<Node> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Node,
        };
        unsafe {
            instance.get(Node::new)
        }
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Address {
    // message fields
    pub host: ::std::vec::Vec<u8>,
    pub port: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // bytes host = 1;


    pub fn get_host(&self) -> &[u8] {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::vec::Vec<u8>) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.host, ::std::vec::Vec::new())
    }

    // int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_bytes(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "host",
                    |m: &Address| { &m.host },
                    |m: &mut Address| { &mut m.host },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &Address| { &m.port },
                    |m: &mut Address| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Address>(
                    "Address",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Address {
        static mut instance: ::protobuf::lazy::Lazy<Address> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Address,
        };
        unsafe {
            instance.get(Address::new)
        }
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmptyMessage {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyMessage {
    fn default() -> &'a EmptyMessage {
        <EmptyMessage as ::protobuf::Message>::default_instance()
    }
}

impl EmptyMessage {
    pub fn new() -> EmptyMessage {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EmptyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyMessage {
        EmptyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EmptyMessage>(
                    "EmptyMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EmptyMessage {
        static mut instance: ::protobuf::lazy::Lazy<EmptyMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EmptyMessage,
        };
        unsafe {
            instance.get(EmptyMessage::new)
        }
    }
}

impl ::protobuf::Clear for EmptyMessage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NumberMessage {
    // message fields
    pub num: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NumberMessage {
    fn default() -> &'a NumberMessage {
        <NumberMessage as ::protobuf::Message>::default_instance()
    }
}

impl NumberMessage {
    pub fn new() -> NumberMessage {
        ::std::default::Default::default()
    }

    // int64 num = 1;


    pub fn get_num(&self) -> i64 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: i64) {
        self.num = v;
    }
}

impl ::protobuf::Message for NumberMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.num != 0 {
            os.write_int64(1, self.num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NumberMessage {
        NumberMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "num",
                    |m: &NumberMessage| { &m.num },
                    |m: &mut NumberMessage| { &mut m.num },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NumberMessage>(
                    "NumberMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NumberMessage {
        static mut instance: ::protobuf::lazy::Lazy<NumberMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NumberMessage,
        };
        unsafe {
            instance.get(NumberMessage::new)
        }
    }
}

impl ::protobuf::Clear for NumberMessage {
    fn clear(&mut self) {
        self.num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NumberMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BytesMessage {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BytesMessage {
    fn default() -> &'a BytesMessage {
        <BytesMessage as ::protobuf::Message>::default_instance()
    }
}

impl BytesMessage {
    pub fn new() -> BytesMessage {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BytesMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BytesMessage {
        BytesMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &BytesMessage| { &m.value },
                    |m: &mut BytesMessage| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BytesMessage>(
                    "BytesMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BytesMessage {
        static mut instance: ::protobuf::lazy::Lazy<BytesMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BytesMessage,
        };
        unsafe {
            instance.get(BytesMessage::new)
        }
    }
}

impl ::protobuf::Clear for BytesMessage {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BytesMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BytesMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeMessage {
    // message fields
    pub beginInMilliseconds: i64,
    pub endInMilliseconds: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeMessage {
    fn default() -> &'a TimeMessage {
        <TimeMessage as ::protobuf::Message>::default_instance()
    }
}

impl TimeMessage {
    pub fn new() -> TimeMessage {
        ::std::default::Default::default()
    }

    // int64 beginInMilliseconds = 1;


    pub fn get_beginInMilliseconds(&self) -> i64 {
        self.beginInMilliseconds
    }
    pub fn clear_beginInMilliseconds(&mut self) {
        self.beginInMilliseconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_beginInMilliseconds(&mut self, v: i64) {
        self.beginInMilliseconds = v;
    }

    // int64 endInMilliseconds = 2;


    pub fn get_endInMilliseconds(&self) -> i64 {
        self.endInMilliseconds
    }
    pub fn clear_endInMilliseconds(&mut self) {
        self.endInMilliseconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_endInMilliseconds(&mut self, v: i64) {
        self.endInMilliseconds = v;
    }
}

impl ::protobuf::Message for TimeMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.beginInMilliseconds = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endInMilliseconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.beginInMilliseconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.beginInMilliseconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endInMilliseconds != 0 {
            my_size += ::protobuf::rt::value_size(2, self.endInMilliseconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.beginInMilliseconds != 0 {
            os.write_int64(1, self.beginInMilliseconds)?;
        }
        if self.endInMilliseconds != 0 {
            os.write_int64(2, self.endInMilliseconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeMessage {
        TimeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "beginInMilliseconds",
                    |m: &TimeMessage| { &m.beginInMilliseconds },
                    |m: &mut TimeMessage| { &mut m.beginInMilliseconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "endInMilliseconds",
                    |m: &TimeMessage| { &m.endInMilliseconds },
                    |m: &mut TimeMessage| { &mut m.endInMilliseconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeMessage>(
                    "TimeMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeMessage {
        static mut instance: ::protobuf::lazy::Lazy<TimeMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeMessage,
        };
        unsafe {
            instance.get(TimeMessage::new)
        }
    }
}

impl ::protobuf::Clear for TimeMessage {
    fn clear(&mut self) {
        self.beginInMilliseconds = 0;
        self.endInMilliseconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockLimit {
    // message fields
    pub startNum: i64,
    pub endNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockLimit {
    fn default() -> &'a BlockLimit {
        <BlockLimit as ::protobuf::Message>::default_instance()
    }
}

impl BlockLimit {
    pub fn new() -> BlockLimit {
        ::std::default::Default::default()
    }

    // int64 startNum = 1;


    pub fn get_startNum(&self) -> i64 {
        self.startNum
    }
    pub fn clear_startNum(&mut self) {
        self.startNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_startNum(&mut self, v: i64) {
        self.startNum = v;
    }

    // int64 endNum = 2;


    pub fn get_endNum(&self) -> i64 {
        self.endNum
    }
    pub fn clear_endNum(&mut self) {
        self.endNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_endNum(&mut self, v: i64) {
        self.endNum = v;
    }
}

impl ::protobuf::Message for BlockLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startNum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.startNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.startNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.endNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.startNum != 0 {
            os.write_int64(1, self.startNum)?;
        }
        if self.endNum != 0 {
            os.write_int64(2, self.endNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockLimit {
        BlockLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "startNum",
                    |m: &BlockLimit| { &m.startNum },
                    |m: &mut BlockLimit| { &mut m.startNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "endNum",
                    |m: &BlockLimit| { &m.endNum },
                    |m: &mut BlockLimit| { &mut m.endNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockLimit>(
                    "BlockLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockLimit {
        static mut instance: ::protobuf::lazy::Lazy<BlockLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockLimit,
        };
        unsafe {
            instance.get(BlockLimit::new)
        }
    }
}

impl ::protobuf::Clear for BlockLimit {
    fn clear(&mut self) {
        self.startNum = 0;
        self.endNum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionLimit {
    // message fields
    pub transactionId: ::std::vec::Vec<u8>,
    pub limitNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionLimit {
    fn default() -> &'a TransactionLimit {
        <TransactionLimit as ::protobuf::Message>::default_instance()
    }
}

impl TransactionLimit {
    pub fn new() -> TransactionLimit {
        ::std::default::Default::default()
    }

    // bytes transactionId = 1;


    pub fn get_transactionId(&self) -> &[u8] {
        &self.transactionId
    }
    pub fn clear_transactionId(&mut self) {
        self.transactionId.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactionId(&mut self, v: ::std::vec::Vec<u8>) {
        self.transactionId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transactionId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transactionId
    }

    // Take field
    pub fn take_transactionId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transactionId, ::std::vec::Vec::new())
    }

    // int64 limitNum = 2;


    pub fn get_limitNum(&self) -> i64 {
        self.limitNum
    }
    pub fn clear_limitNum(&mut self) {
        self.limitNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_limitNum(&mut self, v: i64) {
        self.limitNum = v;
    }
}

impl ::protobuf::Message for TransactionLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transactionId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limitNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transactionId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transactionId);
        }
        if self.limitNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limitNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.transactionId.is_empty() {
            os.write_bytes(1, &self.transactionId)?;
        }
        if self.limitNum != 0 {
            os.write_int64(2, self.limitNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionLimit {
        TransactionLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transactionId",
                    |m: &TransactionLimit| { &m.transactionId },
                    |m: &mut TransactionLimit| { &mut m.transactionId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limitNum",
                    |m: &TransactionLimit| { &m.limitNum },
                    |m: &mut TransactionLimit| { &mut m.limitNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionLimit>(
                    "TransactionLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionLimit {
        static mut instance: ::protobuf::lazy::Lazy<TransactionLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionLimit,
        };
        unsafe {
            instance.get(TransactionLimit::new)
        }
    }
}

impl ::protobuf::Clear for TransactionLimit {
    fn clear(&mut self) {
        self.transactionId.clear();
        self.limitNum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountPaginated {
    // message fields
    pub account: ::protobuf::SingularPtrField<super::Tron::Account>,
    pub offset: i64,
    pub limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountPaginated {
    fn default() -> &'a AccountPaginated {
        <AccountPaginated as ::protobuf::Message>::default_instance()
    }
}

impl AccountPaginated {
    pub fn new() -> AccountPaginated {
        ::std::default::Default::default()
    }

    // .protocol.Account account = 1;


    pub fn get_account(&self) -> &super::Tron::Account {
        self.account.as_ref().unwrap_or_else(|| super::Tron::Account::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: super::Tron::Account) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut super::Tron::Account {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> super::Tron::Account {
        self.account.take().unwrap_or_else(|| super::Tron::Account::new())
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 3;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for AccountPaginated {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountPaginated {
        AccountPaginated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Account>>(
                    "account",
                    |m: &AccountPaginated| { &m.account },
                    |m: &mut AccountPaginated| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &AccountPaginated| { &m.offset },
                    |m: &mut AccountPaginated| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &AccountPaginated| { &m.limit },
                    |m: &mut AccountPaginated| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountPaginated>(
                    "AccountPaginated",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountPaginated {
        static mut instance: ::protobuf::lazy::Lazy<AccountPaginated> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountPaginated,
        };
        unsafe {
            instance.get(AccountPaginated::new)
        }
    }
}

impl ::protobuf::Clear for AccountPaginated {
    fn clear(&mut self) {
        self.account.clear();
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountPaginated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountPaginated {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimePaginatedMessage {
    // message fields
    pub timeMessage: ::protobuf::SingularPtrField<TimeMessage>,
    pub offset: i64,
    pub limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimePaginatedMessage {
    fn default() -> &'a TimePaginatedMessage {
        <TimePaginatedMessage as ::protobuf::Message>::default_instance()
    }
}

impl TimePaginatedMessage {
    pub fn new() -> TimePaginatedMessage {
        ::std::default::Default::default()
    }

    // .protocol.TimeMessage timeMessage = 1;


    pub fn get_timeMessage(&self) -> &TimeMessage {
        self.timeMessage.as_ref().unwrap_or_else(|| TimeMessage::default_instance())
    }
    pub fn clear_timeMessage(&mut self) {
        self.timeMessage.clear();
    }

    pub fn has_timeMessage(&self) -> bool {
        self.timeMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeMessage(&mut self, v: TimeMessage) {
        self.timeMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeMessage(&mut self) -> &mut TimeMessage {
        if self.timeMessage.is_none() {
            self.timeMessage.set_default();
        }
        self.timeMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeMessage(&mut self) -> TimeMessage {
        self.timeMessage.take().unwrap_or_else(|| TimeMessage::new())
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 3;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for TimePaginatedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.timeMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeMessage)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.timeMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.timeMessage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimePaginatedMessage {
        TimePaginatedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeMessage>>(
                    "timeMessage",
                    |m: &TimePaginatedMessage| { &m.timeMessage },
                    |m: &mut TimePaginatedMessage| { &mut m.timeMessage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &TimePaginatedMessage| { &m.offset },
                    |m: &mut TimePaginatedMessage| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &TimePaginatedMessage| { &m.limit },
                    |m: &mut TimePaginatedMessage| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimePaginatedMessage>(
                    "TimePaginatedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimePaginatedMessage {
        static mut instance: ::protobuf::lazy::Lazy<TimePaginatedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimePaginatedMessage,
        };
        unsafe {
            instance.get(TimePaginatedMessage::new)
        }
    }
}

impl ::protobuf::Clear for TimePaginatedMessage {
    fn clear(&mut self) {
        self.timeMessage.clear();
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimePaginatedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimePaginatedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountNetMessage {
    // message fields
    pub freeNetUsed: i64,
    pub freeNetLimit: i64,
    pub NetUsed: i64,
    pub NetLimit: i64,
    pub assetNetUsed: ::std::collections::HashMap<::std::string::String, i64>,
    pub assetNetLimit: ::std::collections::HashMap<::std::string::String, i64>,
    pub TotalNetLimit: i64,
    pub TotalNetWeight: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountNetMessage {
    fn default() -> &'a AccountNetMessage {
        <AccountNetMessage as ::protobuf::Message>::default_instance()
    }
}

impl AccountNetMessage {
    pub fn new() -> AccountNetMessage {
        ::std::default::Default::default()
    }

    // int64 freeNetUsed = 1;


    pub fn get_freeNetUsed(&self) -> i64 {
        self.freeNetUsed
    }
    pub fn clear_freeNetUsed(&mut self) {
        self.freeNetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetUsed(&mut self, v: i64) {
        self.freeNetUsed = v;
    }

    // int64 freeNetLimit = 2;


    pub fn get_freeNetLimit(&self) -> i64 {
        self.freeNetLimit
    }
    pub fn clear_freeNetLimit(&mut self) {
        self.freeNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetLimit(&mut self, v: i64) {
        self.freeNetLimit = v;
    }

    // int64 NetUsed = 3;


    pub fn get_NetUsed(&self) -> i64 {
        self.NetUsed
    }
    pub fn clear_NetUsed(&mut self) {
        self.NetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetUsed(&mut self, v: i64) {
        self.NetUsed = v;
    }

    // int64 NetLimit = 4;


    pub fn get_NetLimit(&self) -> i64 {
        self.NetLimit
    }
    pub fn clear_NetLimit(&mut self) {
        self.NetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetLimit(&mut self, v: i64) {
        self.NetLimit = v;
    }

    // repeated .protocol.AccountNetMessage.AssetNetUsedEntry assetNetUsed = 5;


    pub fn get_assetNetUsed(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetUsed
    }
    pub fn clear_assetNetUsed(&mut self) {
        self.assetNetUsed.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetUsed(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetUsed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetUsed(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetUsed
    }

    // Take field
    pub fn take_assetNetUsed(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetUsed, ::std::collections::HashMap::new())
    }

    // repeated .protocol.AccountNetMessage.AssetNetLimitEntry assetNetLimit = 6;


    pub fn get_assetNetLimit(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetLimit
    }
    pub fn clear_assetNetLimit(&mut self) {
        self.assetNetLimit.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetLimit(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetLimit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetLimit(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetLimit
    }

    // Take field
    pub fn take_assetNetLimit(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetLimit, ::std::collections::HashMap::new())
    }

    // int64 TotalNetLimit = 7;


    pub fn get_TotalNetLimit(&self) -> i64 {
        self.TotalNetLimit
    }
    pub fn clear_TotalNetLimit(&mut self) {
        self.TotalNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetLimit(&mut self, v: i64) {
        self.TotalNetLimit = v;
    }

    // int64 TotalNetWeight = 8;


    pub fn get_TotalNetWeight(&self) -> i64 {
        self.TotalNetWeight
    }
    pub fn clear_TotalNetWeight(&mut self) {
        self.TotalNetWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetWeight(&mut self, v: i64) {
        self.TotalNetWeight = v;
    }
}

impl ::protobuf::Message for AccountNetMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetUsed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetLimit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetUsed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetUsed)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetLimit)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetLimit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetWeight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.freeNetUsed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.freeNetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.freeNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.freeNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetUsed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.NetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.NetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit);
        if self.TotalNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(7, self.TotalNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalNetWeight != 0 {
            my_size += ::protobuf::rt::value_size(8, self.TotalNetWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.freeNetUsed != 0 {
            os.write_int64(1, self.freeNetUsed)?;
        }
        if self.freeNetLimit != 0 {
            os.write_int64(2, self.freeNetLimit)?;
        }
        if self.NetUsed != 0 {
            os.write_int64(3, self.NetUsed)?;
        }
        if self.NetLimit != 0 {
            os.write_int64(4, self.NetLimit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit, os)?;
        if self.TotalNetLimit != 0 {
            os.write_int64(7, self.TotalNetLimit)?;
        }
        if self.TotalNetWeight != 0 {
            os.write_int64(8, self.TotalNetWeight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountNetMessage {
        AccountNetMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "freeNetUsed",
                    |m: &AccountNetMessage| { &m.freeNetUsed },
                    |m: &mut AccountNetMessage| { &mut m.freeNetUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "freeNetLimit",
                    |m: &AccountNetMessage| { &m.freeNetLimit },
                    |m: &mut AccountNetMessage| { &mut m.freeNetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "NetUsed",
                    |m: &AccountNetMessage| { &m.NetUsed },
                    |m: &mut AccountNetMessage| { &mut m.NetUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "NetLimit",
                    |m: &AccountNetMessage| { &m.NetLimit },
                    |m: &mut AccountNetMessage| { &mut m.NetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "assetNetUsed",
                    |m: &AccountNetMessage| { &m.assetNetUsed },
                    |m: &mut AccountNetMessage| { &mut m.assetNetUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "assetNetLimit",
                    |m: &AccountNetMessage| { &m.assetNetLimit },
                    |m: &mut AccountNetMessage| { &mut m.assetNetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TotalNetLimit",
                    |m: &AccountNetMessage| { &m.TotalNetLimit },
                    |m: &mut AccountNetMessage| { &mut m.TotalNetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TotalNetWeight",
                    |m: &AccountNetMessage| { &m.TotalNetWeight },
                    |m: &mut AccountNetMessage| { &mut m.TotalNetWeight },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountNetMessage>(
                    "AccountNetMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountNetMessage {
        static mut instance: ::protobuf::lazy::Lazy<AccountNetMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountNetMessage,
        };
        unsafe {
            instance.get(AccountNetMessage::new)
        }
    }
}

impl ::protobuf::Clear for AccountNetMessage {
    fn clear(&mut self) {
        self.freeNetUsed = 0;
        self.freeNetLimit = 0;
        self.NetUsed = 0;
        self.NetLimit = 0;
        self.assetNetUsed.clear();
        self.assetNetLimit.clear();
        self.TotalNetLimit = 0;
        self.TotalNetWeight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountNetMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountNetMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountResourceMessage {
    // message fields
    pub freeNetUsed: i64,
    pub freeNetLimit: i64,
    pub NetUsed: i64,
    pub NetLimit: i64,
    pub assetNetUsed: ::std::collections::HashMap<::std::string::String, i64>,
    pub assetNetLimit: ::std::collections::HashMap<::std::string::String, i64>,
    pub TotalNetLimit: i64,
    pub TotalNetWeight: i64,
    pub EnergyUsed: i64,
    pub EnergyLimit: i64,
    pub TotalEnergyLimit: i64,
    pub TotalEnergyWeight: i64,
    pub storageUsed: i64,
    pub storageLimit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountResourceMessage {
    fn default() -> &'a AccountResourceMessage {
        <AccountResourceMessage as ::protobuf::Message>::default_instance()
    }
}

impl AccountResourceMessage {
    pub fn new() -> AccountResourceMessage {
        ::std::default::Default::default()
    }

    // int64 freeNetUsed = 1;


    pub fn get_freeNetUsed(&self) -> i64 {
        self.freeNetUsed
    }
    pub fn clear_freeNetUsed(&mut self) {
        self.freeNetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetUsed(&mut self, v: i64) {
        self.freeNetUsed = v;
    }

    // int64 freeNetLimit = 2;


    pub fn get_freeNetLimit(&self) -> i64 {
        self.freeNetLimit
    }
    pub fn clear_freeNetLimit(&mut self) {
        self.freeNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetLimit(&mut self, v: i64) {
        self.freeNetLimit = v;
    }

    // int64 NetUsed = 3;


    pub fn get_NetUsed(&self) -> i64 {
        self.NetUsed
    }
    pub fn clear_NetUsed(&mut self) {
        self.NetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetUsed(&mut self, v: i64) {
        self.NetUsed = v;
    }

    // int64 NetLimit = 4;


    pub fn get_NetLimit(&self) -> i64 {
        self.NetLimit
    }
    pub fn clear_NetLimit(&mut self) {
        self.NetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetLimit(&mut self, v: i64) {
        self.NetLimit = v;
    }

    // repeated .protocol.AccountResourceMessage.AssetNetUsedEntry assetNetUsed = 5;


    pub fn get_assetNetUsed(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetUsed
    }
    pub fn clear_assetNetUsed(&mut self) {
        self.assetNetUsed.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetUsed(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetUsed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetUsed(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetUsed
    }

    // Take field
    pub fn take_assetNetUsed(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetUsed, ::std::collections::HashMap::new())
    }

    // repeated .protocol.AccountResourceMessage.AssetNetLimitEntry assetNetLimit = 6;


    pub fn get_assetNetLimit(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetLimit
    }
    pub fn clear_assetNetLimit(&mut self) {
        self.assetNetLimit.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetLimit(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetLimit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetLimit(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetLimit
    }

    // Take field
    pub fn take_assetNetLimit(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetLimit, ::std::collections::HashMap::new())
    }

    // int64 TotalNetLimit = 7;


    pub fn get_TotalNetLimit(&self) -> i64 {
        self.TotalNetLimit
    }
    pub fn clear_TotalNetLimit(&mut self) {
        self.TotalNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetLimit(&mut self, v: i64) {
        self.TotalNetLimit = v;
    }

    // int64 TotalNetWeight = 8;


    pub fn get_TotalNetWeight(&self) -> i64 {
        self.TotalNetWeight
    }
    pub fn clear_TotalNetWeight(&mut self) {
        self.TotalNetWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetWeight(&mut self, v: i64) {
        self.TotalNetWeight = v;
    }

    // int64 EnergyUsed = 13;


    pub fn get_EnergyUsed(&self) -> i64 {
        self.EnergyUsed
    }
    pub fn clear_EnergyUsed(&mut self) {
        self.EnergyUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_EnergyUsed(&mut self, v: i64) {
        self.EnergyUsed = v;
    }

    // int64 EnergyLimit = 14;


    pub fn get_EnergyLimit(&self) -> i64 {
        self.EnergyLimit
    }
    pub fn clear_EnergyLimit(&mut self) {
        self.EnergyLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_EnergyLimit(&mut self, v: i64) {
        self.EnergyLimit = v;
    }

    // int64 TotalEnergyLimit = 15;


    pub fn get_TotalEnergyLimit(&self) -> i64 {
        self.TotalEnergyLimit
    }
    pub fn clear_TotalEnergyLimit(&mut self) {
        self.TotalEnergyLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalEnergyLimit(&mut self, v: i64) {
        self.TotalEnergyLimit = v;
    }

    // int64 TotalEnergyWeight = 16;


    pub fn get_TotalEnergyWeight(&self) -> i64 {
        self.TotalEnergyWeight
    }
    pub fn clear_TotalEnergyWeight(&mut self) {
        self.TotalEnergyWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalEnergyWeight(&mut self, v: i64) {
        self.TotalEnergyWeight = v;
    }

    // int64 storageUsed = 21;


    pub fn get_storageUsed(&self) -> i64 {
        self.storageUsed
    }
    pub fn clear_storageUsed(&mut self) {
        self.storageUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_storageUsed(&mut self, v: i64) {
        self.storageUsed = v;
    }

    // int64 storageLimit = 22;


    pub fn get_storageLimit(&self) -> i64 {
        self.storageLimit
    }
    pub fn clear_storageLimit(&mut self) {
        self.storageLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_storageLimit(&mut self, v: i64) {
        self.storageLimit = v;
    }
}

impl ::protobuf::Message for AccountResourceMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetUsed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetLimit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetUsed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetUsed)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetLimit)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetLimit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetWeight = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.EnergyUsed = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.EnergyLimit = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalEnergyLimit = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalEnergyWeight = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storageUsed = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storageLimit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.freeNetUsed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.freeNetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.freeNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.freeNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetUsed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.NetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.NetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit);
        if self.TotalNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(7, self.TotalNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalNetWeight != 0 {
            my_size += ::protobuf::rt::value_size(8, self.TotalNetWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EnergyUsed != 0 {
            my_size += ::protobuf::rt::value_size(13, self.EnergyUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EnergyLimit != 0 {
            my_size += ::protobuf::rt::value_size(14, self.EnergyLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalEnergyLimit != 0 {
            my_size += ::protobuf::rt::value_size(15, self.TotalEnergyLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalEnergyWeight != 0 {
            my_size += ::protobuf::rt::value_size(16, self.TotalEnergyWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storageUsed != 0 {
            my_size += ::protobuf::rt::value_size(21, self.storageUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storageLimit != 0 {
            my_size += ::protobuf::rt::value_size(22, self.storageLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.freeNetUsed != 0 {
            os.write_int64(1, self.freeNetUsed)?;
        }
        if self.freeNetLimit != 0 {
            os.write_int64(2, self.freeNetLimit)?;
        }
        if self.NetUsed != 0 {
            os.write_int64(3, self.NetUsed)?;
        }
        if self.NetLimit != 0 {
            os.write_int64(4, self.NetLimit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit, os)?;
        if self.TotalNetLimit != 0 {
            os.write_int64(7, self.TotalNetLimit)?;
        }
        if self.TotalNetWeight != 0 {
            os.write_int64(8, self.TotalNetWeight)?;
        }
        if self.EnergyUsed != 0 {
            os.write_int64(13, self.EnergyUsed)?;
        }
        if self.EnergyLimit != 0 {
            os.write_int64(14, self.EnergyLimit)?;
        }
        if self.TotalEnergyLimit != 0 {
            os.write_int64(15, self.TotalEnergyLimit)?;
        }
        if self.TotalEnergyWeight != 0 {
            os.write_int64(16, self.TotalEnergyWeight)?;
        }
        if self.storageUsed != 0 {
            os.write_int64(21, self.storageUsed)?;
        }
        if self.storageLimit != 0 {
            os.write_int64(22, self.storageLimit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountResourceMessage {
        AccountResourceMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "freeNetUsed",
                    |m: &AccountResourceMessage| { &m.freeNetUsed },
                    |m: &mut AccountResourceMessage| { &mut m.freeNetUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "freeNetLimit",
                    |m: &AccountResourceMessage| { &m.freeNetLimit },
                    |m: &mut AccountResourceMessage| { &mut m.freeNetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "NetUsed",
                    |m: &AccountResourceMessage| { &m.NetUsed },
                    |m: &mut AccountResourceMessage| { &mut m.NetUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "NetLimit",
                    |m: &AccountResourceMessage| { &m.NetLimit },
                    |m: &mut AccountResourceMessage| { &mut m.NetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "assetNetUsed",
                    |m: &AccountResourceMessage| { &m.assetNetUsed },
                    |m: &mut AccountResourceMessage| { &mut m.assetNetUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "assetNetLimit",
                    |m: &AccountResourceMessage| { &m.assetNetLimit },
                    |m: &mut AccountResourceMessage| { &mut m.assetNetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TotalNetLimit",
                    |m: &AccountResourceMessage| { &m.TotalNetLimit },
                    |m: &mut AccountResourceMessage| { &mut m.TotalNetLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TotalNetWeight",
                    |m: &AccountResourceMessage| { &m.TotalNetWeight },
                    |m: &mut AccountResourceMessage| { &mut m.TotalNetWeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "EnergyUsed",
                    |m: &AccountResourceMessage| { &m.EnergyUsed },
                    |m: &mut AccountResourceMessage| { &mut m.EnergyUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "EnergyLimit",
                    |m: &AccountResourceMessage| { &m.EnergyLimit },
                    |m: &mut AccountResourceMessage| { &mut m.EnergyLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TotalEnergyLimit",
                    |m: &AccountResourceMessage| { &m.TotalEnergyLimit },
                    |m: &mut AccountResourceMessage| { &mut m.TotalEnergyLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TotalEnergyWeight",
                    |m: &AccountResourceMessage| { &m.TotalEnergyWeight },
                    |m: &mut AccountResourceMessage| { &mut m.TotalEnergyWeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storageUsed",
                    |m: &AccountResourceMessage| { &m.storageUsed },
                    |m: &mut AccountResourceMessage| { &mut m.storageUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storageLimit",
                    |m: &AccountResourceMessage| { &m.storageLimit },
                    |m: &mut AccountResourceMessage| { &mut m.storageLimit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountResourceMessage>(
                    "AccountResourceMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountResourceMessage {
        static mut instance: ::protobuf::lazy::Lazy<AccountResourceMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountResourceMessage,
        };
        unsafe {
            instance.get(AccountResourceMessage::new)
        }
    }
}

impl ::protobuf::Clear for AccountResourceMessage {
    fn clear(&mut self) {
        self.freeNetUsed = 0;
        self.freeNetLimit = 0;
        self.NetUsed = 0;
        self.NetLimit = 0;
        self.assetNetUsed.clear();
        self.assetNetLimit.clear();
        self.TotalNetLimit = 0;
        self.TotalNetWeight = 0;
        self.EnergyUsed = 0;
        self.EnergyLimit = 0;
        self.TotalEnergyLimit = 0;
        self.TotalEnergyWeight = 0;
        self.storageUsed = 0;
        self.storageLimit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountResourceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountResourceMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PaginatedMessage {
    // message fields
    pub offset: i64,
    pub limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaginatedMessage {
    fn default() -> &'a PaginatedMessage {
        <PaginatedMessage as ::protobuf::Message>::default_instance()
    }
}

impl PaginatedMessage {
    pub fn new() -> PaginatedMessage {
        ::std::default::Default::default()
    }

    // int64 offset = 1;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 2;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for PaginatedMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(1, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.offset != 0 {
            os.write_int64(1, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaginatedMessage {
        PaginatedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &PaginatedMessage| { &m.offset },
                    |m: &mut PaginatedMessage| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &PaginatedMessage| { &m.limit },
                    |m: &mut PaginatedMessage| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaginatedMessage>(
                    "PaginatedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PaginatedMessage {
        static mut instance: ::protobuf::lazy::Lazy<PaginatedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaginatedMessage,
        };
        unsafe {
            instance.get(PaginatedMessage::new)
        }
    }
}

impl ::protobuf::Clear for PaginatedMessage {
    fn clear(&mut self) {
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaginatedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaginatedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EasyTransferMessage {
    // message fields
    pub passPhrase: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferMessage {
    fn default() -> &'a EasyTransferMessage {
        <EasyTransferMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferMessage {
    pub fn new() -> EasyTransferMessage {
        ::std::default::Default::default()
    }

    // bytes passPhrase = 1;


    pub fn get_passPhrase(&self) -> &[u8] {
        &self.passPhrase
    }
    pub fn clear_passPhrase(&mut self) {
        self.passPhrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_passPhrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.passPhrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passPhrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.passPhrase
    }

    // Take field
    pub fn take_passPhrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.passPhrase, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // int64 amount = 3;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.passPhrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.passPhrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.passPhrase);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.passPhrase.is_empty() {
            os.write_bytes(1, &self.passPhrase)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferMessage {
        EasyTransferMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "passPhrase",
                    |m: &EasyTransferMessage| { &m.passPhrase },
                    |m: &mut EasyTransferMessage| { &mut m.passPhrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAddress",
                    |m: &EasyTransferMessage| { &m.toAddress },
                    |m: &mut EasyTransferMessage| { &mut m.toAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &EasyTransferMessage| { &m.amount },
                    |m: &mut EasyTransferMessage| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EasyTransferMessage>(
                    "EasyTransferMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EasyTransferMessage {
        static mut instance: ::protobuf::lazy::Lazy<EasyTransferMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EasyTransferMessage,
        };
        unsafe {
            instance.get(EasyTransferMessage::new)
        }
    }
}

impl ::protobuf::Clear for EasyTransferMessage {
    fn clear(&mut self) {
        self.passPhrase.clear();
        self.toAddress.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EasyTransferAssetMessage {
    // message fields
    pub passPhrase: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub assetId: ::std::string::String,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferAssetMessage {
    fn default() -> &'a EasyTransferAssetMessage {
        <EasyTransferAssetMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferAssetMessage {
    pub fn new() -> EasyTransferAssetMessage {
        ::std::default::Default::default()
    }

    // bytes passPhrase = 1;


    pub fn get_passPhrase(&self) -> &[u8] {
        &self.passPhrase
    }
    pub fn clear_passPhrase(&mut self) {
        self.passPhrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_passPhrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.passPhrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passPhrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.passPhrase
    }

    // Take field
    pub fn take_passPhrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.passPhrase, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // string assetId = 3;


    pub fn get_assetId(&self) -> &str {
        &self.assetId
    }
    pub fn clear_assetId(&mut self) {
        self.assetId.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetId(&mut self, v: ::std::string::String) {
        self.assetId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetId(&mut self) -> &mut ::std::string::String {
        &mut self.assetId
    }

    // Take field
    pub fn take_assetId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetId, ::std::string::String::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferAssetMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.passPhrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.passPhrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.passPhrase);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if !self.assetId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.assetId);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.passPhrase.is_empty() {
            os.write_bytes(1, &self.passPhrase)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if !self.assetId.is_empty() {
            os.write_string(3, &self.assetId)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferAssetMessage {
        EasyTransferAssetMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "passPhrase",
                    |m: &EasyTransferAssetMessage| { &m.passPhrase },
                    |m: &mut EasyTransferAssetMessage| { &mut m.passPhrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAddress",
                    |m: &EasyTransferAssetMessage| { &m.toAddress },
                    |m: &mut EasyTransferAssetMessage| { &mut m.toAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "assetId",
                    |m: &EasyTransferAssetMessage| { &m.assetId },
                    |m: &mut EasyTransferAssetMessage| { &mut m.assetId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &EasyTransferAssetMessage| { &m.amount },
                    |m: &mut EasyTransferAssetMessage| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EasyTransferAssetMessage>(
                    "EasyTransferAssetMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EasyTransferAssetMessage {
        static mut instance: ::protobuf::lazy::Lazy<EasyTransferAssetMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EasyTransferAssetMessage,
        };
        unsafe {
            instance.get(EasyTransferAssetMessage::new)
        }
    }
}

impl ::protobuf::Clear for EasyTransferAssetMessage {
    fn clear(&mut self) {
        self.passPhrase.clear();
        self.toAddress.clear();
        self.assetId.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferAssetMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferAssetMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EasyTransferByPrivateMessage {
    // message fields
    pub privateKey: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferByPrivateMessage {
    fn default() -> &'a EasyTransferByPrivateMessage {
        <EasyTransferByPrivateMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferByPrivateMessage {
    pub fn new() -> EasyTransferByPrivateMessage {
        ::std::default::Default::default()
    }

    // bytes privateKey = 1;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // int64 amount = 3;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferByPrivateMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.privateKey);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.privateKey.is_empty() {
            os.write_bytes(1, &self.privateKey)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferByPrivateMessage {
        EasyTransferByPrivateMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &EasyTransferByPrivateMessage| { &m.privateKey },
                    |m: &mut EasyTransferByPrivateMessage| { &mut m.privateKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAddress",
                    |m: &EasyTransferByPrivateMessage| { &m.toAddress },
                    |m: &mut EasyTransferByPrivateMessage| { &mut m.toAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &EasyTransferByPrivateMessage| { &m.amount },
                    |m: &mut EasyTransferByPrivateMessage| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EasyTransferByPrivateMessage>(
                    "EasyTransferByPrivateMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EasyTransferByPrivateMessage {
        static mut instance: ::protobuf::lazy::Lazy<EasyTransferByPrivateMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EasyTransferByPrivateMessage,
        };
        unsafe {
            instance.get(EasyTransferByPrivateMessage::new)
        }
    }
}

impl ::protobuf::Clear for EasyTransferByPrivateMessage {
    fn clear(&mut self) {
        self.privateKey.clear();
        self.toAddress.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferByPrivateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferByPrivateMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EasyTransferAssetByPrivateMessage {
    // message fields
    pub privateKey: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub assetId: ::std::string::String,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferAssetByPrivateMessage {
    fn default() -> &'a EasyTransferAssetByPrivateMessage {
        <EasyTransferAssetByPrivateMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferAssetByPrivateMessage {
    pub fn new() -> EasyTransferAssetByPrivateMessage {
        ::std::default::Default::default()
    }

    // bytes privateKey = 1;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // string assetId = 3;


    pub fn get_assetId(&self) -> &str {
        &self.assetId
    }
    pub fn clear_assetId(&mut self) {
        self.assetId.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetId(&mut self, v: ::std::string::String) {
        self.assetId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetId(&mut self) -> &mut ::std::string::String {
        &mut self.assetId
    }

    // Take field
    pub fn take_assetId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetId, ::std::string::String::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferAssetByPrivateMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.privateKey);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if !self.assetId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.assetId);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.privateKey.is_empty() {
            os.write_bytes(1, &self.privateKey)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if !self.assetId.is_empty() {
            os.write_string(3, &self.assetId)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferAssetByPrivateMessage {
        EasyTransferAssetByPrivateMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &EasyTransferAssetByPrivateMessage| { &m.privateKey },
                    |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.privateKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAddress",
                    |m: &EasyTransferAssetByPrivateMessage| { &m.toAddress },
                    |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.toAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "assetId",
                    |m: &EasyTransferAssetByPrivateMessage| { &m.assetId },
                    |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.assetId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &EasyTransferAssetByPrivateMessage| { &m.amount },
                    |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EasyTransferAssetByPrivateMessage>(
                    "EasyTransferAssetByPrivateMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EasyTransferAssetByPrivateMessage {
        static mut instance: ::protobuf::lazy::Lazy<EasyTransferAssetByPrivateMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EasyTransferAssetByPrivateMessage,
        };
        unsafe {
            instance.get(EasyTransferAssetByPrivateMessage::new)
        }
    }
}

impl ::protobuf::Clear for EasyTransferAssetByPrivateMessage {
    fn clear(&mut self) {
        self.privateKey.clear();
        self.toAddress.clear();
        self.assetId.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferAssetByPrivateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferAssetByPrivateMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EasyTransferResponse {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<super::Tron::Transaction>,
    pub result: ::protobuf::SingularPtrField<Return>,
    pub txid: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferResponse {
    fn default() -> &'a EasyTransferResponse {
        <EasyTransferResponse as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferResponse {
    pub fn new() -> EasyTransferResponse {
        ::std::default::Default::default()
    }

    // .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &super::Tron::Transaction {
        self.transaction.as_ref().unwrap_or_else(|| super::Tron::Transaction::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: super::Tron::Transaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut super::Tron::Transaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> super::Tron::Transaction {
        self.transaction.take().unwrap_or_else(|| super::Tron::Transaction::new())
    }

    // .protocol.Return result = 2;


    pub fn get_result(&self) -> &Return {
        self.result.as_ref().unwrap_or_else(|| Return::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Return) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Return {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Return {
        self.result.take().unwrap_or_else(|| Return::new())
    }

    // bytes txid = 3;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EasyTransferResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(3, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferResponse {
        EasyTransferResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Transaction>>(
                    "transaction",
                    |m: &EasyTransferResponse| { &m.transaction },
                    |m: &mut EasyTransferResponse| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Return>>(
                    "result",
                    |m: &EasyTransferResponse| { &m.result },
                    |m: &mut EasyTransferResponse| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &EasyTransferResponse| { &m.txid },
                    |m: &mut EasyTransferResponse| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EasyTransferResponse>(
                    "EasyTransferResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EasyTransferResponse {
        static mut instance: ::protobuf::lazy::Lazy<EasyTransferResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EasyTransferResponse,
        };
        unsafe {
            instance.get(EasyTransferResponse::new)
        }
    }
}

impl ::protobuf::Clear for EasyTransferResponse {
    fn clear(&mut self) {
        self.transaction.clear();
        self.result.clear();
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressPrKeyPairMessage {
    // message fields
    pub address: ::std::string::String,
    pub privateKey: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressPrKeyPairMessage {
    fn default() -> &'a AddressPrKeyPairMessage {
        <AddressPrKeyPairMessage as ::protobuf::Message>::default_instance()
    }
}

impl AddressPrKeyPairMessage {
    pub fn new() -> AddressPrKeyPairMessage {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string privateKey = 2;


    pub fn get_privateKey(&self) -> &str {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::string::String) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::string::String {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.privateKey, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddressPrKeyPairMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.privateKey.is_empty() {
            os.write_string(2, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressPrKeyPairMessage {
        AddressPrKeyPairMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AddressPrKeyPairMessage| { &m.address },
                    |m: &mut AddressPrKeyPairMessage| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "privateKey",
                    |m: &AddressPrKeyPairMessage| { &m.privateKey },
                    |m: &mut AddressPrKeyPairMessage| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddressPrKeyPairMessage>(
                    "AddressPrKeyPairMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddressPrKeyPairMessage {
        static mut instance: ::protobuf::lazy::Lazy<AddressPrKeyPairMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddressPrKeyPairMessage,
        };
        unsafe {
            instance.get(AddressPrKeyPairMessage::new)
        }
    }
}

impl ::protobuf::Clear for AddressPrKeyPairMessage {
    fn clear(&mut self) {
        self.address.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressPrKeyPairMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressPrKeyPairMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionExtention {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<super::Tron::Transaction>,
    pub txid: ::std::vec::Vec<u8>,
    pub constant_result: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub result: ::protobuf::SingularPtrField<Return>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionExtention {
    fn default() -> &'a TransactionExtention {
        <TransactionExtention as ::protobuf::Message>::default_instance()
    }
}

impl TransactionExtention {
    pub fn new() -> TransactionExtention {
        ::std::default::Default::default()
    }

    // .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &super::Tron::Transaction {
        self.transaction.as_ref().unwrap_or_else(|| super::Tron::Transaction::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: super::Tron::Transaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut super::Tron::Transaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> super::Tron::Transaction {
        self.transaction.take().unwrap_or_else(|| super::Tron::Transaction::new())
    }

    // bytes txid = 2;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // repeated bytes constant_result = 3;


    pub fn get_constant_result(&self) -> &[::std::vec::Vec<u8>] {
        &self.constant_result
    }
    pub fn clear_constant_result(&mut self) {
        self.constant_result.clear();
    }

    // Param is passed by value, moved
    pub fn set_constant_result(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.constant_result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_constant_result(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.constant_result
    }

    // Take field
    pub fn take_constant_result(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.constant_result, ::protobuf::RepeatedField::new())
    }

    // .protocol.Return result = 4;


    pub fn get_result(&self) -> &Return {
        self.result.as_ref().unwrap_or_else(|| Return::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Return) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Return {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Return {
        self.result.take().unwrap_or_else(|| Return::new())
    }
}

impl ::protobuf::Message for TransactionExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.constant_result)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.txid);
        }
        for value in &self.constant_result {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(2, &self.txid)?;
        }
        for v in &self.constant_result {
            os.write_bytes(3, &v)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionExtention {
        TransactionExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Transaction>>(
                    "transaction",
                    |m: &TransactionExtention| { &m.transaction },
                    |m: &mut TransactionExtention| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &TransactionExtention| { &m.txid },
                    |m: &mut TransactionExtention| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "constant_result",
                    |m: &TransactionExtention| { &m.constant_result },
                    |m: &mut TransactionExtention| { &mut m.constant_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Return>>(
                    "result",
                    |m: &TransactionExtention| { &m.result },
                    |m: &mut TransactionExtention| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionExtention>(
                    "TransactionExtention",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionExtention {
        static mut instance: ::protobuf::lazy::Lazy<TransactionExtention> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionExtention,
        };
        unsafe {
            instance.get(TransactionExtention::new)
        }
    }
}

impl ::protobuf::Clear for TransactionExtention {
    fn clear(&mut self) {
        self.transaction.clear();
        self.txid.clear();
        self.constant_result.clear();
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockExtention {
    // message fields
    pub transactions: ::protobuf::RepeatedField<TransactionExtention>,
    pub block_header: ::protobuf::SingularPtrField<super::Tron::BlockHeader>,
    pub blockid: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockExtention {
    fn default() -> &'a BlockExtention {
        <BlockExtention as ::protobuf::Message>::default_instance()
    }
}

impl BlockExtention {
    pub fn new() -> BlockExtention {
        ::std::default::Default::default()
    }

    // repeated .protocol.TransactionExtention transactions = 1;


    pub fn get_transactions(&self) -> &[TransactionExtention] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<TransactionExtention>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<TransactionExtention> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<TransactionExtention> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // .protocol.BlockHeader block_header = 2;


    pub fn get_block_header(&self) -> &super::Tron::BlockHeader {
        self.block_header.as_ref().unwrap_or_else(|| super::Tron::BlockHeader::default_instance())
    }
    pub fn clear_block_header(&mut self) {
        self.block_header.clear();
    }

    pub fn has_block_header(&self) -> bool {
        self.block_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_header(&mut self, v: super::Tron::BlockHeader) {
        self.block_header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_header(&mut self) -> &mut super::Tron::BlockHeader {
        if self.block_header.is_none() {
            self.block_header.set_default();
        }
        self.block_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_header(&mut self) -> super::Tron::BlockHeader {
        self.block_header.take().unwrap_or_else(|| super::Tron::BlockHeader::new())
    }

    // bytes blockid = 3;


    pub fn get_blockid(&self) -> &[u8] {
        &self.blockid
    }
    pub fn clear_blockid(&mut self) {
        self.blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockid
    }

    // Take field
    pub fn take_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_header)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blockid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.blockid.is_empty() {
            os.write_bytes(3, &self.blockid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockExtention {
        BlockExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                    "transactions",
                    |m: &BlockExtention| { &m.transactions },
                    |m: &mut BlockExtention| { &mut m.transactions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::BlockHeader>>(
                    "block_header",
                    |m: &BlockExtention| { &m.block_header },
                    |m: &mut BlockExtention| { &mut m.block_header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockid",
                    |m: &BlockExtention| { &m.blockid },
                    |m: &mut BlockExtention| { &mut m.blockid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockExtention>(
                    "BlockExtention",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockExtention {
        static mut instance: ::protobuf::lazy::Lazy<BlockExtention> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockExtention,
        };
        unsafe {
            instance.get(BlockExtention::new)
        }
    }
}

impl ::protobuf::Clear for BlockExtention {
    fn clear(&mut self) {
        self.transactions.clear();
        self.block_header.clear();
        self.blockid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockListExtention {
    // message fields
    pub block: ::protobuf::RepeatedField<BlockExtention>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockListExtention {
    fn default() -> &'a BlockListExtention {
        <BlockListExtention as ::protobuf::Message>::default_instance()
    }
}

impl BlockListExtention {
    pub fn new() -> BlockListExtention {
        ::std::default::Default::default()
    }

    // repeated .protocol.BlockExtention block = 1;


    pub fn get_block(&self) -> &[BlockExtention] {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::protobuf::RepeatedField<BlockExtention>) {
        self.block = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut ::protobuf::RepeatedField<BlockExtention> {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::protobuf::RepeatedField<BlockExtention> {
        ::std::mem::replace(&mut self.block, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockListExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.block {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.block {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockListExtention {
        BlockListExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockExtention>>(
                    "block",
                    |m: &BlockListExtention| { &m.block },
                    |m: &mut BlockListExtention| { &mut m.block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockListExtention>(
                    "BlockListExtention",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockListExtention {
        static mut instance: ::protobuf::lazy::Lazy<BlockListExtention> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockListExtention,
        };
        unsafe {
            instance.get(BlockListExtention::new)
        }
    }
}

impl ::protobuf::Clear for BlockListExtention {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockListExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockListExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionListExtention {
    // message fields
    pub transaction: ::protobuf::RepeatedField<TransactionExtention>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionListExtention {
    fn default() -> &'a TransactionListExtention {
        <TransactionListExtention as ::protobuf::Message>::default_instance()
    }
}

impl TransactionListExtention {
    pub fn new() -> TransactionListExtention {
        ::std::default::Default::default()
    }

    // repeated .protocol.TransactionExtention transaction = 1;


    pub fn get_transaction(&self) -> &[TransactionExtention] {
        &self.transaction
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::protobuf::RepeatedField<TransactionExtention>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::protobuf::RepeatedField<TransactionExtention> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::protobuf::RepeatedField<TransactionExtention> {
        ::std::mem::replace(&mut self.transaction, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionListExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transaction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transaction {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionListExtention {
        TransactionListExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                    "transaction",
                    |m: &TransactionListExtention| { &m.transaction },
                    |m: &mut TransactionListExtention| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionListExtention>(
                    "TransactionListExtention",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionListExtention {
        static mut instance: ::protobuf::lazy::Lazy<TransactionListExtention> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionListExtention,
        };
        unsafe {
            instance.get(TransactionListExtention::new)
        }
    }
}

impl ::protobuf::Clear for TransactionListExtention {
    fn clear(&mut self) {
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionListExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionListExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionSignWeight {
    // message fields
    pub permission: ::protobuf::SingularPtrField<super::Tron::Permission>,
    pub approved_list: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub current_weight: i64,
    pub result: ::protobuf::SingularPtrField<TransactionSignWeight_Result>,
    pub transaction: ::protobuf::SingularPtrField<TransactionExtention>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSignWeight {
    fn default() -> &'a TransactionSignWeight {
        <TransactionSignWeight as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSignWeight {
    pub fn new() -> TransactionSignWeight {
        ::std::default::Default::default()
    }

    // .protocol.Permission permission = 1;


    pub fn get_permission(&self) -> &super::Tron::Permission {
        self.permission.as_ref().unwrap_or_else(|| super::Tron::Permission::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::Tron::Permission) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::Tron::Permission {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::Tron::Permission {
        self.permission.take().unwrap_or_else(|| super::Tron::Permission::new())
    }

    // repeated bytes approved_list = 2;


    pub fn get_approved_list(&self) -> &[::std::vec::Vec<u8>] {
        &self.approved_list
    }
    pub fn clear_approved_list(&mut self) {
        self.approved_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_approved_list(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.approved_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_approved_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.approved_list
    }

    // Take field
    pub fn take_approved_list(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.approved_list, ::protobuf::RepeatedField::new())
    }

    // int64 current_weight = 3;


    pub fn get_current_weight(&self) -> i64 {
        self.current_weight
    }
    pub fn clear_current_weight(&mut self) {
        self.current_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_weight(&mut self, v: i64) {
        self.current_weight = v;
    }

    // .protocol.TransactionSignWeight.Result result = 4;


    pub fn get_result(&self) -> &TransactionSignWeight_Result {
        self.result.as_ref().unwrap_or_else(|| TransactionSignWeight_Result::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: TransactionSignWeight_Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut TransactionSignWeight_Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> TransactionSignWeight_Result {
        self.result.take().unwrap_or_else(|| TransactionSignWeight_Result::new())
    }

    // .protocol.TransactionExtention transaction = 5;


    pub fn get_transaction(&self) -> &TransactionExtention {
        self.transaction.as_ref().unwrap_or_else(|| TransactionExtention::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: TransactionExtention) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut TransactionExtention {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> TransactionExtention {
        self.transaction.take().unwrap_or_else(|| TransactionExtention::new())
    }
}

impl ::protobuf::Message for TransactionSignWeight {
    fn is_initialized(&self) -> bool {
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.approved_list)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.current_weight = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.approved_list {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.current_weight != 0 {
            my_size += ::protobuf::rt::value_size(3, self.current_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.approved_list {
            os.write_bytes(2, &v)?;
        };
        if self.current_weight != 0 {
            os.write_int64(3, self.current_weight)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSignWeight {
        TransactionSignWeight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                    "permission",
                    |m: &TransactionSignWeight| { &m.permission },
                    |m: &mut TransactionSignWeight| { &mut m.permission },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "approved_list",
                    |m: &TransactionSignWeight| { &m.approved_list },
                    |m: &mut TransactionSignWeight| { &mut m.approved_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "current_weight",
                    |m: &TransactionSignWeight| { &m.current_weight },
                    |m: &mut TransactionSignWeight| { &mut m.current_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionSignWeight_Result>>(
                    "result",
                    |m: &TransactionSignWeight| { &m.result },
                    |m: &mut TransactionSignWeight| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                    "transaction",
                    |m: &TransactionSignWeight| { &m.transaction },
                    |m: &mut TransactionSignWeight| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionSignWeight>(
                    "TransactionSignWeight",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionSignWeight {
        static mut instance: ::protobuf::lazy::Lazy<TransactionSignWeight> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionSignWeight,
        };
        unsafe {
            instance.get(TransactionSignWeight::new)
        }
    }
}

impl ::protobuf::Clear for TransactionSignWeight {
    fn clear(&mut self) {
        self.permission.clear();
        self.approved_list.clear();
        self.current_weight = 0;
        self.result.clear();
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSignWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSignWeight {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionSignWeight_Result {
    // message fields
    pub code: TransactionSignWeight_Result_response_code,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSignWeight_Result {
    fn default() -> &'a TransactionSignWeight_Result {
        <TransactionSignWeight_Result as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSignWeight_Result {
    pub fn new() -> TransactionSignWeight_Result {
        ::std::default::Default::default()
    }

    // .protocol.TransactionSignWeight.Result.response_code code = 1;


    pub fn get_code(&self) -> TransactionSignWeight_Result_response_code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: TransactionSignWeight_Result_response_code) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TransactionSignWeight_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION {
            os.write_enum(1, self.code.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSignWeight_Result {
        TransactionSignWeight_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionSignWeight_Result_response_code>>(
                    "code",
                    |m: &TransactionSignWeight_Result| { &m.code },
                    |m: &mut TransactionSignWeight_Result| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &TransactionSignWeight_Result| { &m.message },
                    |m: &mut TransactionSignWeight_Result| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionSignWeight_Result>(
                    "TransactionSignWeight_Result",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionSignWeight_Result {
        static mut instance: ::protobuf::lazy::Lazy<TransactionSignWeight_Result> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionSignWeight_Result,
        };
        unsafe {
            instance.get(TransactionSignWeight_Result::new)
        }
    }
}

impl ::protobuf::Clear for TransactionSignWeight_Result {
    fn clear(&mut self) {
        self.code = TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSignWeight_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSignWeight_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransactionSignWeight_Result_response_code {
    ENOUGH_PERMISSION = 0,
    NOT_ENOUGH_PERMISSION = 1,
    SIGNATURE_FORMAT_ERROR = 2,
    COMPUTE_ADDRESS_ERROR = 3,
    PERMISSION_ERROR = 4,
    OTHER_ERROR = 20,
}

impl ::protobuf::ProtobufEnum for TransactionSignWeight_Result_response_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionSignWeight_Result_response_code> {
        match value {
            0 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION),
            1 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::NOT_ENOUGH_PERMISSION),
            2 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::SIGNATURE_FORMAT_ERROR),
            3 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::COMPUTE_ADDRESS_ERROR),
            4 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::PERMISSION_ERROR),
            20 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionSignWeight_Result_response_code] = &[
            TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION,
            TransactionSignWeight_Result_response_code::NOT_ENOUGH_PERMISSION,
            TransactionSignWeight_Result_response_code::SIGNATURE_FORMAT_ERROR,
            TransactionSignWeight_Result_response_code::COMPUTE_ADDRESS_ERROR,
            TransactionSignWeight_Result_response_code::PERMISSION_ERROR,
            TransactionSignWeight_Result_response_code::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TransactionSignWeight_Result_response_code", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TransactionSignWeight_Result_response_code {
}

impl ::std::default::Default for TransactionSignWeight_Result_response_code {
    fn default() -> Self {
        TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSignWeight_Result_response_code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionApprovedList {
    // message fields
    pub approved_list: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub result: ::protobuf::SingularPtrField<TransactionApprovedList_Result>,
    pub transaction: ::protobuf::SingularPtrField<TransactionExtention>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionApprovedList {
    fn default() -> &'a TransactionApprovedList {
        <TransactionApprovedList as ::protobuf::Message>::default_instance()
    }
}

impl TransactionApprovedList {
    pub fn new() -> TransactionApprovedList {
        ::std::default::Default::default()
    }

    // repeated bytes approved_list = 2;


    pub fn get_approved_list(&self) -> &[::std::vec::Vec<u8>] {
        &self.approved_list
    }
    pub fn clear_approved_list(&mut self) {
        self.approved_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_approved_list(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.approved_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_approved_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.approved_list
    }

    // Take field
    pub fn take_approved_list(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.approved_list, ::protobuf::RepeatedField::new())
    }

    // .protocol.TransactionApprovedList.Result result = 4;


    pub fn get_result(&self) -> &TransactionApprovedList_Result {
        self.result.as_ref().unwrap_or_else(|| TransactionApprovedList_Result::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: TransactionApprovedList_Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut TransactionApprovedList_Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> TransactionApprovedList_Result {
        self.result.take().unwrap_or_else(|| TransactionApprovedList_Result::new())
    }

    // .protocol.TransactionExtention transaction = 5;


    pub fn get_transaction(&self) -> &TransactionExtention {
        self.transaction.as_ref().unwrap_or_else(|| TransactionExtention::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: TransactionExtention) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut TransactionExtention {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> TransactionExtention {
        self.transaction.take().unwrap_or_else(|| TransactionExtention::new())
    }
}

impl ::protobuf::Message for TransactionApprovedList {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.approved_list)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.approved_list {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.approved_list {
            os.write_bytes(2, &v)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionApprovedList {
        TransactionApprovedList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "approved_list",
                    |m: &TransactionApprovedList| { &m.approved_list },
                    |m: &mut TransactionApprovedList| { &mut m.approved_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionApprovedList_Result>>(
                    "result",
                    |m: &TransactionApprovedList| { &m.result },
                    |m: &mut TransactionApprovedList| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                    "transaction",
                    |m: &TransactionApprovedList| { &m.transaction },
                    |m: &mut TransactionApprovedList| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionApprovedList>(
                    "TransactionApprovedList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionApprovedList {
        static mut instance: ::protobuf::lazy::Lazy<TransactionApprovedList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionApprovedList,
        };
        unsafe {
            instance.get(TransactionApprovedList::new)
        }
    }
}

impl ::protobuf::Clear for TransactionApprovedList {
    fn clear(&mut self) {
        self.approved_list.clear();
        self.result.clear();
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionApprovedList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionApprovedList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionApprovedList_Result {
    // message fields
    pub code: TransactionApprovedList_Result_response_code,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionApprovedList_Result {
    fn default() -> &'a TransactionApprovedList_Result {
        <TransactionApprovedList_Result as ::protobuf::Message>::default_instance()
    }
}

impl TransactionApprovedList_Result {
    pub fn new() -> TransactionApprovedList_Result {
        ::std::default::Default::default()
    }

    // .protocol.TransactionApprovedList.Result.response_code code = 1;


    pub fn get_code(&self) -> TransactionApprovedList_Result_response_code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = TransactionApprovedList_Result_response_code::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: TransactionApprovedList_Result_response_code) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TransactionApprovedList_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != TransactionApprovedList_Result_response_code::SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != TransactionApprovedList_Result_response_code::SUCCESS {
            os.write_enum(1, self.code.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionApprovedList_Result {
        TransactionApprovedList_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionApprovedList_Result_response_code>>(
                    "code",
                    |m: &TransactionApprovedList_Result| { &m.code },
                    |m: &mut TransactionApprovedList_Result| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &TransactionApprovedList_Result| { &m.message },
                    |m: &mut TransactionApprovedList_Result| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionApprovedList_Result>(
                    "TransactionApprovedList_Result",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionApprovedList_Result {
        static mut instance: ::protobuf::lazy::Lazy<TransactionApprovedList_Result> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionApprovedList_Result,
        };
        unsafe {
            instance.get(TransactionApprovedList_Result::new)
        }
    }
}

impl ::protobuf::Clear for TransactionApprovedList_Result {
    fn clear(&mut self) {
        self.code = TransactionApprovedList_Result_response_code::SUCCESS;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionApprovedList_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionApprovedList_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransactionApprovedList_Result_response_code {
    SUCCESS = 0,
    SIGNATURE_FORMAT_ERROR = 1,
    COMPUTE_ADDRESS_ERROR = 2,
    OTHER_ERROR = 20,
}

impl ::protobuf::ProtobufEnum for TransactionApprovedList_Result_response_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionApprovedList_Result_response_code> {
        match value {
            0 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::SUCCESS),
            1 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::SIGNATURE_FORMAT_ERROR),
            2 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::COMPUTE_ADDRESS_ERROR),
            20 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionApprovedList_Result_response_code] = &[
            TransactionApprovedList_Result_response_code::SUCCESS,
            TransactionApprovedList_Result_response_code::SIGNATURE_FORMAT_ERROR,
            TransactionApprovedList_Result_response_code::COMPUTE_ADDRESS_ERROR,
            TransactionApprovedList_Result_response_code::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TransactionApprovedList_Result_response_code", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TransactionApprovedList_Result_response_code {
}

impl ::std::default::Default for TransactionApprovedList_Result_response_code {
    fn default() -> Self {
        TransactionApprovedList_Result_response_code::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionApprovedList_Result_response_code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rapi/api.proto\x12\x08protocol\x1a\x0fcore/Tron.proto\x1a\x13core/Con\
    tract.proto\x1a\x1cgoogle/api/annotations.proto\"\xab\x03\n\x06Return\
    \x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\x122\n\x04code\x18\
    \x02\x20\x01(\x0e2\x1e.protocol.Return.response_codeR\x04code\x12\x18\n\
    \x07message\x18\x03\x20\x01(\x0cR\x07message\"\xba\x02\n\rresponse_code\
    \x12\x0b\n\x07SUCCESS\x10\0\x12\x0c\n\x08SIGERROR\x10\x01\x12\x1b\n\x17C\
    ONTRACT_VALIDATE_ERROR\x10\x02\x12\x16\n\x12CONTRACT_EXE_ERROR\x10\x03\
    \x12\x12\n\x0eBANDWITH_ERROR\x10\x04\x12\x19\n\x15DUP_TRANSACTION_ERROR\
    \x10\x05\x12\x0f\n\x0bTAPOS_ERROR\x10\x06\x12\x1d\n\x19TOO_BIG_TRANSACTI\
    ON_ERROR\x10\x07\x12\x20\n\x1cTRANSACTION_EXPIRATION_ERROR\x10\x08\x12\
    \x0f\n\x0bSERVER_BUSY\x10\t\x12\x11\n\rNO_CONNECTION\x10\n\x12#\n\x1fNOT\
    _ENOUGH_EFFECTIVE_CONNECTION\x10\x0b\x12\x0f\n\x0bOTHER_ERROR\x10\x14\"L\
    \n\x0eBlockReference\x12\x1b\n\tblock_num\x18\x01\x20\x01(\x03R\x08block\
    Num\x12\x1d\n\nblock_hash\x18\x02\x20\x01(\x0cR\tblockHash\">\n\x0bWitne\
    ssList\x12/\n\twitnesses\x18\x01\x20\x03(\x0b2\x11.protocol.WitnessR\twi\
    tnesses\"@\n\x0cProposalList\x120\n\tproposals\x18\x01\x20\x03(\x0b2\x12\
    .protocol.ProposalR\tproposals\"@\n\x0cExchangeList\x120\n\texchanges\
    \x18\x01\x20\x03(\x0b2\x12.protocol.ExchangeR\texchanges\"N\n\x0eAssetIs\
    sueList\x12<\n\nassetIssue\x18\x01\x20\x03(\x0b2\x1c.protocol.AssetIssue\
    ContractR\nassetIssue\"2\n\tBlockList\x12%\n\x05block\x18\x01\x20\x03(\
    \x0b2\x0f.protocol.BlockR\x05block\"J\n\x0fTransactionList\x127\n\x0btra\
    nsaction\x18\x01\x20\x03(\x0b2\x15.protocol.TransactionR\x0btransaction\
    \"Z\n\x18DelegatedResourceMessage\x12\x20\n\x0bfromAddress\x18\x01\x20\
    \x01(\x0cR\x0bfromAddress\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\x0cR\tto\
    Address\"b\n\x15DelegatedResourceList\x12I\n\x11delegatedResource\x18\
    \x01\x20\x03(\x0b2\x1b.protocol.DelegatedResourceR\x11delegatedResource\
    \"0\n\x08NodeList\x12$\n\x05nodes\x18\x01\x20\x03(\x0b2\x0e.protocol.Nod\
    eR\x05nodes\"3\n\x04Node\x12+\n\x07address\x18\x01\x20\x01(\x0b2\x11.pro\
    tocol.AddressR\x07address\"1\n\x07Address\x12\x12\n\x04host\x18\x01\x20\
    \x01(\x0cR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\"\x0e\
    \n\x0cEmptyMessage\"!\n\rNumberMessage\x12\x10\n\x03num\x18\x01\x20\x01(\
    \x03R\x03num\"$\n\x0cBytesMessage\x12\x14\n\x05value\x18\x01\x20\x01(\
    \x0cR\x05value\"m\n\x0bTimeMessage\x120\n\x13beginInMilliseconds\x18\x01\
    \x20\x01(\x03R\x13beginInMilliseconds\x12,\n\x11endInMilliseconds\x18\
    \x02\x20\x01(\x03R\x11endInMilliseconds\"@\n\nBlockLimit\x12\x1a\n\x08st\
    artNum\x18\x01\x20\x01(\x03R\x08startNum\x12\x16\n\x06endNum\x18\x02\x20\
    \x01(\x03R\x06endNum\"T\n\x10TransactionLimit\x12$\n\rtransactionId\x18\
    \x01\x20\x01(\x0cR\rtransactionId\x12\x1a\n\x08limitNum\x18\x02\x20\x01(\
    \x03R\x08limitNum\"m\n\x10AccountPaginated\x12+\n\x07account\x18\x01\x20\
    \x01(\x0b2\x11.protocol.AccountR\x07account\x12\x16\n\x06offset\x18\x02\
    \x20\x01(\x03R\x06offset\x12\x14\n\x05limit\x18\x03\x20\x01(\x03R\x05lim\
    it\"}\n\x14TimePaginatedMessage\x127\n\x0btimeMessage\x18\x01\x20\x01(\
    \x0b2\x15.protocol.TimeMessageR\x0btimeMessage\x12\x16\n\x06offset\x18\
    \x02\x20\x01(\x03R\x06offset\x12\x14\n\x05limit\x18\x03\x20\x01(\x03R\
    \x05limit\"\x89\x04\n\x11AccountNetMessage\x12\x20\n\x0bfreeNetUsed\x18\
    \x01\x20\x01(\x03R\x0bfreeNetUsed\x12\"\n\x0cfreeNetLimit\x18\x02\x20\
    \x01(\x03R\x0cfreeNetLimit\x12\x18\n\x07NetUsed\x18\x03\x20\x01(\x03R\
    \x07NetUsed\x12\x1a\n\x08NetLimit\x18\x04\x20\x01(\x03R\x08NetLimit\x12Q\
    \n\x0cassetNetUsed\x18\x05\x20\x03(\x0b2-.protocol.AccountNetMessage.Ass\
    etNetUsedEntryR\x0cassetNetUsed\x12T\n\rassetNetLimit\x18\x06\x20\x03(\
    \x0b2..protocol.AccountNetMessage.AssetNetLimitEntryR\rassetNetLimit\x12\
    $\n\rTotalNetLimit\x18\x07\x20\x01(\x03R\rTotalNetLimit\x12&\n\x0eTotalN\
    etWeight\x18\x08\x20\x01(\x03R\x0eTotalNetWeight\x1a?\n\x11AssetNetUsedE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x03R\x05value:\x028\x01\x1a@\n\x12AssetNetLimitEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x03R\x05value:\x028\x01\"\xfa\x05\n\x16AccountResourceMessage\x12\
    \x20\n\x0bfreeNetUsed\x18\x01\x20\x01(\x03R\x0bfreeNetUsed\x12\"\n\x0cfr\
    eeNetLimit\x18\x02\x20\x01(\x03R\x0cfreeNetLimit\x12\x18\n\x07NetUsed\
    \x18\x03\x20\x01(\x03R\x07NetUsed\x12\x1a\n\x08NetLimit\x18\x04\x20\x01(\
    \x03R\x08NetLimit\x12V\n\x0cassetNetUsed\x18\x05\x20\x03(\x0b22.protocol\
    .AccountResourceMessage.AssetNetUsedEntryR\x0cassetNetUsed\x12Y\n\rasset\
    NetLimit\x18\x06\x20\x03(\x0b23.protocol.AccountResourceMessage.AssetNet\
    LimitEntryR\rassetNetLimit\x12$\n\rTotalNetLimit\x18\x07\x20\x01(\x03R\r\
    TotalNetLimit\x12&\n\x0eTotalNetWeight\x18\x08\x20\x01(\x03R\x0eTotalNet\
    Weight\x12\x1e\n\nEnergyUsed\x18\r\x20\x01(\x03R\nEnergyUsed\x12\x20\n\
    \x0bEnergyLimit\x18\x0e\x20\x01(\x03R\x0bEnergyLimit\x12*\n\x10TotalEner\
    gyLimit\x18\x0f\x20\x01(\x03R\x10TotalEnergyLimit\x12,\n\x11TotalEnergyW\
    eight\x18\x10\x20\x01(\x03R\x11TotalEnergyWeight\x12\x20\n\x0bstorageUse\
    d\x18\x15\x20\x01(\x03R\x0bstorageUsed\x12\"\n\x0cstorageLimit\x18\x16\
    \x20\x01(\x03R\x0cstorageLimit\x1a?\n\x11AssetNetUsedEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\
    \x05value:\x028\x01\x1a@\n\x12AssetNetLimitEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05valu\
    e:\x028\x01\"@\n\x10PaginatedMessage\x12\x16\n\x06offset\x18\x01\x20\x01\
    (\x03R\x06offset\x12\x14\n\x05limit\x18\x02\x20\x01(\x03R\x05limit\"k\n\
    \x13EasyTransferMessage\x12\x1e\n\npassPhrase\x18\x01\x20\x01(\x0cR\npas\
    sPhrase\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\x0cR\ttoAddress\x12\x16\n\
    \x06amount\x18\x03\x20\x01(\x03R\x06amount\"\x8a\x01\n\x18EasyTransferAs\
    setMessage\x12\x1e\n\npassPhrase\x18\x01\x20\x01(\x0cR\npassPhrase\x12\
    \x1c\n\ttoAddress\x18\x02\x20\x01(\x0cR\ttoAddress\x12\x18\n\x07assetId\
    \x18\x03\x20\x01(\tR\x07assetId\x12\x16\n\x06amount\x18\x04\x20\x01(\x03\
    R\x06amount\"t\n\x1cEasyTransferByPrivateMessage\x12\x1e\n\nprivateKey\
    \x18\x01\x20\x01(\x0cR\nprivateKey\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\
    \x0cR\ttoAddress\x12\x16\n\x06amount\x18\x03\x20\x01(\x03R\x06amount\"\
    \x93\x01\n!EasyTransferAssetByPrivateMessage\x12\x1e\n\nprivateKey\x18\
    \x01\x20\x01(\x0cR\nprivateKey\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\x0c\
    R\ttoAddress\x12\x18\n\x07assetId\x18\x03\x20\x01(\tR\x07assetId\x12\x16\
    \n\x06amount\x18\x04\x20\x01(\x03R\x06amount\"\x8d\x01\n\x14EasyTransfer\
    Response\x127\n\x0btransaction\x18\x01\x20\x01(\x0b2\x15.protocol.Transa\
    ctionR\x0btransaction\x12(\n\x06result\x18\x02\x20\x01(\x0b2\x10.protoco\
    l.ReturnR\x06result\x12\x12\n\x04txid\x18\x03\x20\x01(\x0cR\x04txid\"S\n\
    \x17AddressPrKeyPairMessage\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07\
    address\x12\x1e\n\nprivateKey\x18\x02\x20\x01(\tR\nprivateKey\"\xb6\x01\
    \n\x14TransactionExtention\x127\n\x0btransaction\x18\x01\x20\x01(\x0b2\
    \x15.protocol.TransactionR\x0btransaction\x12\x12\n\x04txid\x18\x02\x20\
    \x01(\x0cR\x04txid\x12'\n\x0fconstant_result\x18\x03\x20\x03(\x0cR\x0eco\
    nstantResult\x12(\n\x06result\x18\x04\x20\x01(\x0b2\x10.protocol.ReturnR\
    \x06result\"\xa8\x01\n\x0eBlockExtention\x12B\n\x0ctransactions\x18\x01\
    \x20\x03(\x0b2\x1e.protocol.TransactionExtentionR\x0ctransactions\x128\n\
    \x0cblock_header\x18\x02\x20\x01(\x0b2\x15.protocol.BlockHeaderR\x0bbloc\
    kHeader\x12\x18\n\x07blockid\x18\x03\x20\x01(\x0cR\x07blockid\"D\n\x12Bl\
    ockListExtention\x12.\n\x05block\x18\x01\x20\x03(\x0b2\x18.protocol.Bloc\
    kExtentionR\x05block\"\\\n\x18TransactionListExtention\x12@\n\x0btransac\
    tion\x18\x01\x20\x03(\x0b2\x1e.protocol.TransactionExtentionR\x0btransac\
    tion\"\xac\x04\n\x15TransactionSignWeight\x124\n\npermission\x18\x01\x20\
    \x01(\x0b2\x14.protocol.PermissionR\npermission\x12#\n\rapproved_list\
    \x18\x02\x20\x03(\x0cR\x0capprovedList\x12%\n\x0ecurrent_weight\x18\x03\
    \x20\x01(\x03R\rcurrentWeight\x12>\n\x06result\x18\x04\x20\x01(\x0b2&.pr\
    otocol.TransactionSignWeight.ResultR\x06result\x12@\n\x0btransaction\x18\
    \x05\x20\x01(\x0b2\x1e.protocol.TransactionExtentionR\x0btransaction\x1a\
    \x8e\x02\n\x06Result\x12H\n\x04code\x18\x01\x20\x01(\x0e24.protocol.Tran\
    sactionSignWeight.Result.response_codeR\x04code\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"\x9f\x01\n\rresponse_code\x12\x15\n\x11ENOU\
    GH_PERMISSION\x10\0\x12\x19\n\x15NOT_ENOUGH_PERMISSION\x10\x01\x12\x1a\n\
    \x16SIGNATURE_FORMAT_ERROR\x10\x02\x12\x19\n\x15COMPUTE_ADDRESS_ERROR\
    \x10\x03\x12\x14\n\x10PERMISSION_ERROR\x10\x04\x12\x0f\n\x0bOTHER_ERROR\
    \x10\x14\"\x99\x03\n\x17TransactionApprovedList\x12#\n\rapproved_list\
    \x18\x02\x20\x03(\x0cR\x0capprovedList\x12@\n\x06result\x18\x04\x20\x01(\
    \x0b2(.protocol.TransactionApprovedList.ResultR\x06result\x12@\n\x0btran\
    saction\x18\x05\x20\x01(\x0b2\x1e.protocol.TransactionExtentionR\x0btran\
    saction\x1a\xd4\x01\n\x06Result\x12J\n\x04code\x18\x01\x20\x01(\x0e26.pr\
    otocol.TransactionApprovedList.Result.response_codeR\x04code\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\"d\n\rresponse_code\x12\x0b\n\
    \x07SUCCESS\x10\0\x12\x1a\n\x16SIGNATURE_FORMAT_ERROR\x10\x01\x12\x19\n\
    \x15COMPUTE_ADDRESS_ERROR\x10\x02\x12\x0f\n\x0bOTHER_ERROR\x10\x142\x9dR\
    \n\x06Wallet\x12g\n\nGetAccount\x12\x11.protocol.Account\x1a\x11.protoco\
    l.Account\"3\x82\xd3\xe4\x93\x02-\"\x12/wallet/getaccount:\x01*Z\x14\x12\
    \x12/wallet/getaccount\x12s\n\x0eGetAccountById\x12\x11.protocol.Account\
    \x1a\x11.protocol.Account\";\x82\xd3\xe4\x93\x025\"\x16/wallet/getaccoun\
    tbyid:\x01*Z\x18\x12\x16/wallet/getaccountbyid\x12\x89\x01\n\x11CreateTr\
    ansaction\x12\x1a.protocol.TransferContract\x1a\x15.protocol.Transaction\
    \"A\x82\xd3\xe4\x93\x02;\"\x19/wallet/createtransaction:\x01*Z\x1b\x12\
    \x19/wallet/createtransaction\x12R\n\x12CreateTransaction2\x12\x1a.proto\
    col.TransferContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x88\
    \x01\n\x14BroadcastTransaction\x12\x15.protocol.Transaction\x1a\x10.prot\
    ocol.Return\"G\x82\xd3\xe4\x93\x02A\"\x1c/wallet/broadcasttransaction:\
    \x01*Z\x1e\x12\x1c/wallet/broadcasttransaction\x12\x82\x01\n\rUpdateAcco\
    unt\x12\x1f.protocol.AccountUpdateContract\x1a\x15.protocol.Transaction\
    \"9\x82\xd3\xe4\x93\x023\"\x15/wallet/updateaccount:\x01*Z\x17\x12\x15/w\
    allet/updateaccount\x12~\n\x0cSetAccountId\x12\x1e.protocol.SetAccountId\
    Contract\x1a\x15.protocol.Transaction\"7\x82\xd3\xe4\x93\x021\"\x14/wall\
    et/setaccountid:\x01*Z\x16\x12\x14/wallet/setaccountid\x12S\n\x0eUpdateA\
    ccount2\x12\x1f.protocol.AccountUpdateContract\x1a\x1e.protocol.Transact\
    ionExtention\"\0\x12\x8f\x01\n\x12VoteWitnessAccount\x12\x1d.protocol.Vo\
    teWitnessContract\x1a\x15.protocol.Transaction\"C\x82\xd3\xe4\x93\x02=\"\
    \x1a/wallet/votewitnessaccount:\x01*Z\x1c\x12\x1a/wallet/votewitnessacco\
    unt\x12R\n\rUpdateSetting\x12\x1f.protocol.UpdateSettingContract\x1a\x1e\
    .protocol.TransactionExtention\"\0\x12Z\n\x11UpdateEnergyLimit\x12#.prot\
    ocol.UpdateEnergyLimitContract\x1a\x1e.protocol.TransactionExtention\"\0\
    \x12V\n\x13VoteWitnessAccount2\x12\x1d.protocol.VoteWitnessContract\x1a\
    \x1e.protocol.TransactionExtention\"\0\x12\x88\x01\n\x10CreateAssetIssue\
    \x12\x1c.protocol.AssetIssueContract\x1a\x15.protocol.Transaction\"?\x82\
    \xd3\xe4\x93\x029\"\x18/wallet/createassetissue:\x01*Z\x1a\x12\x18/walle\
    t/createassetissue\x12S\n\x11CreateAssetIssue2\x12\x1c.protocol.AssetIss\
    ueContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x82\x01\n\rUpda\
    teWitness\x12\x1f.protocol.WitnessUpdateContract\x1a\x15.protocol.Transa\
    ction\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/updatewitness:\x01*Z\x17\x12\
    \x15/wallet/updatewitness\x12S\n\x0eUpdateWitness2\x12\x1f.protocol.Witn\
    essUpdateContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x82\x01\
    \n\rCreateAccount\x12\x1f.protocol.AccountCreateContract\x1a\x15.protoco\
    l.Transaction\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/createaccount:\x01*Z\
    \x17\x12\x15/wallet/createaccount\x12S\n\x0eCreateAccount2\x12\x1f.proto\
    col.AccountCreateContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\
    \x82\x01\n\rCreateWitness\x12\x1f.protocol.WitnessCreateContract\x1a\x15\
    .protocol.Transaction\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/createwitness\
    :\x01*Z\x17\x12\x15/wallet/createwitness\x12S\n\x0eCreateWitness2\x12\
    \x1f.protocol.WitnessCreateContract\x1a\x1e.protocol.TransactionExtentio\
    n\"\0\x12\x82\x01\n\rTransferAsset\x12\x1f.protocol.TransferAssetContrac\
    t\x1a\x15.protocol.Transaction\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/tran\
    sferasset:\x01*Z\x17\x12\x15/wallet/transferasset\x12S\n\x0eTransferAsse\
    t2\x12\x1f.protocol.TransferAssetContract\x1a\x1e.protocol.TransactionEx\
    tention\"\0\x12\xa2\x01\n\x15ParticipateAssetIssue\x12'.protocol.Partici\
    pateAssetIssueContract\x1a\x15.protocol.Transaction\"I\x82\xd3\xe4\x93\
    \x02C\"\x1d/wallet/participateassetissue:\x01*Z\x1f\x12\x1d/wallet/parti\
    cipateassetissue\x12c\n\x16ParticipateAssetIssue2\x12'.protocol.Particip\
    ateAssetIssueContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x82\
    \x01\n\rFreezeBalance\x12\x1f.protocol.FreezeBalanceContract\x1a\x15.pro\
    tocol.Transaction\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/freezebalance:\
    \x01*Z\x17\x12\x15/wallet/freezebalance\x12S\n\x0eFreezeBalance2\x12\x1f\
    .protocol.FreezeBalanceContract\x1a\x1e.protocol.TransactionExtention\"\
    \0\x12\x8a\x01\n\x0fUnfreezeBalance\x12!.protocol.UnfreezeBalanceContrac\
    t\x1a\x15.protocol.Transaction\"=\x82\xd3\xe4\x93\x027\"\x17/wallet/unfr\
    eezebalance:\x01*Z\x19\x12\x17/wallet/unfreezebalance\x12W\n\x10Unfreeze\
    Balance2\x12!.protocol.UnfreezeBalanceContract\x1a\x1e.protocol.Transact\
    ionExtention\"\0\x12\x82\x01\n\rUnfreezeAsset\x12\x1f.protocol.UnfreezeA\
    ssetContract\x1a\x15.protocol.Transaction\"9\x82\xd3\xe4\x93\x023\"\x15/\
    wallet/unfreezeasset:\x01*Z\x17\x12\x15/wallet/unfreezeasset\x12S\n\x0eU\
    nfreezeAsset2\x12\x1f.protocol.UnfreezeAssetContract\x1a\x1e.protocol.Tr\
    ansactionExtention\"\0\x12\x8a\x01\n\x0fWithdrawBalance\x12!.protocol.Wi\
    thdrawBalanceContract\x1a\x15.protocol.Transaction\"=\x82\xd3\xe4\x93\
    \x027\"\x17/wallet/withdrawbalance:\x01*Z\x19\x12\x17/wallet/withdrawbal\
    ance\x12W\n\x10WithdrawBalance2\x12!.protocol.WithdrawBalanceContract\
    \x1a\x1e.protocol.TransactionExtention\"\0\x12z\n\x0bUpdateAsset\x12\x1d\
    .protocol.UpdateAssetContract\x1a\x15.protocol.Transaction\"5\x82\xd3\
    \xe4\x93\x02/\"\x13/wallet/updateasset:\x01*Z\x15\x12\x13/wallet/updatea\
    sset\x12O\n\x0cUpdateAsset2\x12\x1d.protocol.UpdateAssetContract\x1a\x1e\
    .protocol.TransactionExtention\"\0\x12T\n\x0eProposalCreate\x12\x20.prot\
    ocol.ProposalCreateContract\x1a\x1e.protocol.TransactionExtention\"\0\
    \x12V\n\x0fProposalApprove\x12!.protocol.ProposalApproveContract\x1a\x1e\
    .protocol.TransactionExtention\"\0\x12T\n\x0eProposalDelete\x12\x20.prot\
    ocol.ProposalDeleteContract\x1a\x1e.protocol.TransactionExtention\"\0\
    \x12L\n\nBuyStorage\x12\x1c.protocol.BuyStorageContract\x1a\x1e.protocol\
    .TransactionExtention\"\0\x12V\n\x0fBuyStorageBytes\x12!.protocol.BuySto\
    rageBytesContract\x1a\x1e.protocol.TransactionExtention\"\0\x12N\n\x0bSe\
    llStorage\x12\x1d.protocol.SellStorageContract\x1a\x1e.protocol.Transact\
    ionExtention\"\0\x12T\n\x0eExchangeCreate\x12\x20.protocol.ExchangeCreat\
    eContract\x1a\x1e.protocol.TransactionExtention\"\0\x12T\n\x0eExchangeIn\
    ject\x12\x20.protocol.ExchangeInjectContract\x1a\x1e.protocol.Transactio\
    nExtention\"\0\x12X\n\x10ExchangeWithdraw\x12\".protocol.ExchangeWithdra\
    wContract\x1a\x1e.protocol.TransactionExtention\"\0\x12^\n\x13ExchangeTr\
    ansaction\x12%.protocol.ExchangeTransactionContract\x1a\x1e.protocol.Tra\
    nsactionExtention\"\0\x12j\n\tListNodes\x12\x16.protocol.EmptyMessage\
    \x1a\x12.protocol.NodeList\"1\x82\xd3\xe4\x93\x02+\"\x11/wallet/listnode\
    s:\x01*Z\x13\x12\x11/wallet/listnodes\x12\x92\x01\n\x16GetAssetIssueByAc\
    count\x12\x11.protocol.Account\x1a\x18.protocol.AssetIssueList\"K\x82\
    \xd3\xe4\x93\x02E\"\x1e/wallet/getassetissuebyaccount:\x01*Z\x20\x12\x1e\
    /wallet/getassetissuebyaccount\x12z\n\rGetAccountNet\x12\x11.protocol.Ac\
    count\x1a\x1b.protocol.AccountNetMessage\"9\x82\xd3\xe4\x93\x023\"\x15/w\
    allet/getaccountnet:\x01*Z\x17\x12\x15/wallet/getaccountnet\x12K\n\x12Ge\
    tAccountResource\x12\x11.protocol.Account\x1a\x20.protocol.AccountResour\
    ceMessage\"\0\x12\x92\x01\n\x13GetAssetIssueByName\x12\x16.protocol.Byte\
    sMessage\x1a\x1c.protocol.AssetIssueContract\"E\x82\xd3\xe4\x93\x02?\"\
    \x1b/wallet/getassetissuebyname:\x01*Z\x1d\x12\x1b/wallet/getassetissueb\
    yname\x12M\n\x17GetAssetIssueListByName\x12\x16.protocol.BytesMessage\
    \x1a\x18.protocol.AssetIssueList\"\0\x12K\n\x11GetAssetIssueById\x12\x16\
    .protocol.BytesMessage\x1a\x1c.protocol.AssetIssueContract\"\0\x12m\n\
    \x0bGetNowBlock\x12\x16.protocol.EmptyMessage\x1a\x0f.protocol.Block\"5\
    \x82\xd3\xe4\x93\x02/\"\x13/wallet/getnowblock:\x01*Z\x15\x12\x13/wallet\
    /getnowblock\x12B\n\x0cGetNowBlock2\x12\x16.protocol.EmptyMessage\x1a\
    \x18.protocol.BlockExtention\"\0\x12t\n\rGetBlockByNum\x12\x17.protocol.\
    NumberMessage\x1a\x0f.protocol.Block\"9\x82\xd3\xe4\x93\x023\"\x15/walle\
    t/getblockbynum:\x01*Z\x17\x12\x15/wallet/getblockbynum\x12E\n\x0eGetBlo\
    ckByNum2\x12\x17.protocol.NumberMessage\x1a\x18.protocol.BlockExtention\
    \"\0\x12S\n\x1dGetTransactionCountByBlockNum\x12\x17.protocol.NumberMess\
    age\x1a\x17.protocol.NumberMessage\"\0\x12p\n\x0cGetBlockById\x12\x16.pr\
    otocol.BytesMessage\x1a\x0f.protocol.Block\"7\x82\xd3\xe4\x93\x021\"\x14\
    /wallet/getblockbyid:\x01*Z\x16\x12\x14/wallet/getblockbyid\x12\x87\x01\
    \n\x13GetBlockByLimitNext\x12\x14.protocol.BlockLimit\x1a\x13.protocol.B\
    lockList\"E\x82\xd3\xe4\x93\x02?\"\x1b/wallet/getblockbylimitnext:\x01*Z\
    \x1d\x12\x1b/wallet/getblockbylimitnext\x12L\n\x14GetBlockByLimitNext2\
    \x12\x14.protocol.BlockLimit\x1a\x1c.protocol.BlockListExtention\"\0\x12\
    \x8a\x01\n\x13GetBlockByLatestNum\x12\x17.protocol.NumberMessage\x1a\x13\
    .protocol.BlockList\"E\x82\xd3\xe4\x93\x02?\"\x1b/wallet/getblockbylates\
    tnum:\x01*Z\x1d\x12\x1b/wallet/getblockbylatestnum\x12O\n\x14GetBlockByL\
    atestNum2\x12\x17.protocol.NumberMessage\x1a\x1c.protocol.BlockListExten\
    tion\"\0\x12\x88\x01\n\x12GetTransactionById\x12\x16.protocol.BytesMessa\
    ge\x1a\x15.protocol.Transaction\"C\x82\xd3\xe4\x93\x02=\"\x1a/wallet/get\
    transactionbyid:\x01*Z\x1c\x12\x1a/wallet/gettransactionbyid\x12Q\n\x0eD\
    eployContract\x12\x1d.protocol.CreateSmartContract\x1a\x1e.protocol.Tran\
    sactionExtention\"\0\x12@\n\x0bGetContract\x12\x16.protocol.BytesMessage\
    \x1a\x17.protocol.SmartContract\"\0\x12S\n\x0fTriggerContract\x12\x1e.pr\
    otocol.TriggerSmartContract\x1a\x1e.protocol.TransactionExtention\"\0\
    \x12[\n\x17TriggerConstantContract\x12\x1e.protocol.TriggerSmartContract\
    \x1a\x1e.protocol.TransactionExtention\"\0\x12P\n\x10ClearContractABI\
    \x12\x1a.protocol.ClearABIContract\x1a\x1e.protocol.TransactionExtention\
    \"\0\x12y\n\rListWitnesses\x12\x16.protocol.EmptyMessage\x1a\x15.protoco\
    l.WitnessList\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/listwitnesses:\x01*Z\
    \x17\x12\x15/wallet/listwitnesses\x12]\n\x14GetDelegatedResource\x12\".p\
    rotocol.DelegatedResourceMessage\x1a\x1f.protocol.DelegatedResourceList\
    \"\0\x12e\n\x20GetDelegatedResourceAccountIndex\x12\x16.protocol.BytesMe\
    ssage\x1a'.protocol.DelegatedResourceAccountIndex\"\0\x12z\n\rListPropos\
    als\x12\x16.protocol.EmptyMessage\x1a\x16.protocol.ProposalList\"9\x82\
    \xd3\xe4\x93\x023\"\x15/wallet/listproposals:\x01*Z\x17\x12\x15/wallet/l\
    istproposals\x12\x9f\x01\n\x18GetPaginatedProposalList\x12\x1a.protocol.\
    PaginatedMessage\x1a\x16.protocol.ProposalList\"O\x82\xd3\xe4\x93\x02I\"\
    \x20/wallet/getpaginatedproposallist:\x01*Z\"\x12\x20/wallet/getpaginate\
    dproposallist\x12|\n\x0fGetProposalById\x12\x16.protocol.BytesMessage\
    \x1a\x12.protocol.Proposal\"=\x82\xd3\xe4\x93\x027\"\x17/wallet/getpropo\
    salbyid:\x01*Z\x19\x12\x17/wallet/getproposalbyid\x12z\n\rListExchanges\
    \x12\x16.protocol.EmptyMessage\x1a\x16.protocol.ExchangeList\"9\x82\xd3\
    \xe4\x93\x023\"\x15/wallet/listexchanges:\x01*Z\x17\x12\x15/wallet/liste\
    xchanges\x12\x9f\x01\n\x18GetPaginatedExchangeList\x12\x1a.protocol.Pagi\
    natedMessage\x1a\x16.protocol.ExchangeList\"O\x82\xd3\xe4\x93\x02I\"\x20\
    /wallet/getpaginatedexchangelist:\x01*Z\"\x12\x20/wallet/getpaginatedexc\
    hangelist\x12|\n\x0fGetExchangeById\x12\x16.protocol.BytesMessage\x1a\
    \x12.protocol.Exchange\"=\x82\xd3\xe4\x93\x027\"\x17/wallet/getexchangeb\
    yid:\x01*Z\x19\x12\x17/wallet/getexchangebyid\x12\x8c\x01\n\x12GetChainP\
    arameters\x12\x16.protocol.EmptyMessage\x1a\x19.protocol.ChainParameters\
    \"C\x82\xd3\xe4\x93\x02=\"\x1a/wallet/getchainparameters:\x01*Z\x1c\x12\
    \x1a/wallet/getchainparameters\x12\x88\x01\n\x11GetAssetIssueList\x12\
    \x16.protocol.EmptyMessage\x1a\x18.protocol.AssetIssueList\"A\x82\xd3\
    \xe4\x93\x02;\"\x19/wallet/getassetissuelist:\x01*Z\x1b\x12\x19/wallet/g\
    etassetissuelist\x12\xa7\x01\n\x1aGetPaginatedAssetIssueList\x12\x1a.pro\
    tocol.PaginatedMessage\x1a\x18.protocol.AssetIssueList\"S\x82\xd3\xe4\
    \x93\x02M\"\"/wallet/getpaginatedassetissuelist:\x01*Z$\x12\"/wallet/get\
    paginatedassetissuelist\x12\x84\x01\n\x10TotalTransaction\x12\x16.protoc\
    ol.EmptyMessage\x1a\x17.protocol.NumberMessage\"?\x82\xd3\xe4\x93\x029\"\
    \x18/wallet/totaltransaction:\x01*Z\x1a\x12\x18/wallet/totaltransaction\
    \x12\x96\x01\n\x16GetNextMaintenanceTime\x12\x16.protocol.EmptyMessage\
    \x1a\x17.protocol.NumberMessage\"K\x82\xd3\xe4\x93\x02E\"\x1e/wallet/get\
    nextmaintenancetime:\x01*Z\x20\x12\x1e/wallet/getnextmaintenancetime\x12\
    \x8b\x01\n\x12GetTransactionSign\x12\x19.protocol.TransactionSign\x1a\
    \x15.protocol.Transaction\"C\x82\xd3\xe4\x93\x02=\"\x1a/wallet/gettransa\
    ctionsign:\x01*Z\x1c\x12\x1a/wallet/gettransactionsign\x12R\n\x13GetTran\
    sactionSign2\x12\x19.protocol.TransactionSign\x1a\x1e.protocol.Transacti\
    onExtention\"\0\x12z\n\rCreateAddress\x12\x16.protocol.BytesMessage\x1a\
    \x16.protocol.BytesMessage\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/createad\
    dress:\x01*Z\x17\x12\x15/wallet/createaddress\x12Y\n\x11EasyTransferAsse\
    t\x12\".protocol.EasyTransferAssetMessage\x1a\x1e.protocol.EasyTransferR\
    esponse\"\0\x12k\n\x1aEasyTransferAssetByPrivate\x12+.protocol.EasyTrans\
    ferAssetByPrivateMessage\x1a\x1e.protocol.EasyTransferResponse\"\0\x12\
    \x86\x01\n\x0cEasyTransfer\x12\x1d.protocol.EasyTransferMessage\x1a\x1e.\
    protocol.EasyTransferResponse\"7\x82\xd3\xe4\x93\x021\"\x14/wallet/easyt\
    ransfer:\x01*Z\x16\x12\x14/wallet/easytransfer\x12\xaa\x01\n\x15EasyTran\
    sferByPrivate\x12&.protocol.EasyTransferByPrivateMessage\x1a\x1e.protoco\
    l.EasyTransferResponse\"I\x82\xd3\xe4\x93\x02C\"\x1d/wallet/easytransfer\
    byprivate:\x01*Z\x1f\x12\x1d/wallet/easytransferbyprivate\x12\x8b\x01\n\
    \x0fGenerateAddress\x12\x16.protocol.EmptyMessage\x1a!.protocol.AddressP\
    rKeyPairMessage\"=\x82\xd3\xe4\x93\x027\"\x17/wallet/generateaddress:\
    \x01*Z\x19\x12\x17/wallet/generateaddress\x12\x98\x01\n\x16GetTransactio\
    nInfoById\x12\x16.protocol.BytesMessage\x1a\x19.protocol.TransactionInfo\
    \"K\x82\xd3\xe4\x93\x02E\"\x1e/wallet/gettransactioninfobyid:\x01*Z\x20\
    \x12\x1e/wallet/gettransactioninfobyid\x12\xb3\x01\n\x17AccountPermissio\
    nUpdate\x12).protocol.AccountPermissionUpdateContract\x1a\x1e.protocol.T\
    ransactionExtention\"M\x82\xd3\xe4\x93\x02G\"\x1f/wallet/accountpermissi\
    onupdate:\x01*Z!\x12\x1f/wallet/accountpermissionupdate\x12F\n\x07AddSig\
    n\x12\x19.protocol.TransactionSign\x1a\x1e.protocol.TransactionExtention\
    \"\0\x12T\n\x18GetTransactionSignWeight\x12\x15.protocol.Transaction\x1a\
    \x1f.protocol.TransactionSignWeight\"\0\x12X\n\x1aGetTransactionApproved\
    List\x12\x15.protocol.Transaction\x1a!.protocol.TransactionApprovedList\
    \"\0\x12;\n\x0bGetNodeInfo\x12\x16.protocol.EmptyMessage\x1a\x12.protoco\
    l.NodeInfo\"\02\xef\x11\n\x0eWalletSolidity\x12w\n\nGetAccount\x12\x11.p\
    rotocol.Account\x1a\x11.protocol.Account\"C\x82\xd3\xe4\x93\x02=\"\x1a/w\
    alletsolidity/getaccount:\x01*Z\x1c\x12\x1a/walletsolidity/getaccount\
    \x12\x83\x01\n\x0eGetAccountById\x12\x11.protocol.Account\x1a\x11.protoc\
    ol.Account\"K\x82\xd3\xe4\x93\x02E\"\x1e/walletsolidity/getaccountbyid:\
    \x01*Z\x20\x12\x1e/walletsolidity/getaccountbyid\x12\x89\x01\n\rListWitn\
    esses\x12\x16.protocol.EmptyMessage\x1a\x15.protocol.WitnessList\"I\x82\
    \xd3\xe4\x93\x02C\"\x1d/walletsolidity/listwitnesses:\x01*Z\x1f\x12\x1d/\
    walletsolidity/listwitnesses\x12\x98\x01\n\x11GetAssetIssueList\x12\x16.\
    protocol.EmptyMessage\x1a\x18.protocol.AssetIssueList\"Q\x82\xd3\xe4\x93\
    \x02K\"!/walletsolidity/getassetissuelist:\x01*Z#\x12!/walletsolidity/ge\
    tassetissuelist\x12\xb7\x01\n\x1aGetPaginatedAssetIssueList\x12\x1a.prot\
    ocol.PaginatedMessage\x1a\x18.protocol.AssetIssueList\"c\x82\xd3\xe4\x93\
    \x02]\"*/walletsolidity/getpaginatedassetissuelist:\x01*Z,\x12*/walletso\
    lidity/getpaginatedassetissuelist\x12M\n\x13GetAssetIssueByName\x12\x16.\
    protocol.BytesMessage\x1a\x1c.protocol.AssetIssueContract\"\0\x12M\n\x17\
    GetAssetIssueListByName\x12\x16.protocol.BytesMessage\x1a\x18.protocol.A\
    ssetIssueList\"\0\x12K\n\x11GetAssetIssueById\x12\x16.protocol.BytesMess\
    age\x1a\x1c.protocol.AssetIssueContract\"\0\x12}\n\x0bGetNowBlock\x12\
    \x16.protocol.EmptyMessage\x1a\x0f.protocol.Block\"E\x82\xd3\xe4\x93\x02\
    ?\"\x1b/walletsolidity/getnowblock:\x01*Z\x1d\x12\x1b/walletsolidity/get\
    nowblock\x12B\n\x0cGetNowBlock2\x12\x16.protocol.EmptyMessage\x1a\x18.pr\
    otocol.BlockExtention\"\0\x12\x84\x01\n\rGetBlockByNum\x12\x17.protocol.\
    NumberMessage\x1a\x0f.protocol.Block\"I\x82\xd3\xe4\x93\x02C\"\x1d/walle\
    tsolidity/getblockbynum:\x01*Z\x1f\x12\x1d/walletsolidity/getblockbynum\
    \x12E\n\x0eGetBlockByNum2\x12\x17.protocol.NumberMessage\x1a\x18.protoco\
    l.BlockExtention\"\0\x12S\n\x1dGetTransactionCountByBlockNum\x12\x17.pro\
    tocol.NumberMessage\x1a\x17.protocol.NumberMessage\"\0\x12]\n\x14GetDele\
    gatedResource\x12\".protocol.DelegatedResourceMessage\x1a\x1f.protocol.D\
    elegatedResourceList\"\0\x12e\n\x20GetDelegatedResourceAccountIndex\x12\
    \x16.protocol.BytesMessage\x1a'.protocol.DelegatedResourceAccountIndex\"\
    \0\x12?\n\x0fGetExchangeById\x12\x16.protocol.BytesMessage\x1a\x12.proto\
    col.Exchange\"\0\x12A\n\rListExchanges\x12\x16.protocol.EmptyMessage\x1a\
    \x16.protocol.ExchangeList\"\0\x12\x98\x01\n\x12GetTransactionById\x12\
    \x16.protocol.BytesMessage\x1a\x15.protocol.Transaction\"S\x82\xd3\xe4\
    \x93\x02M\"\"/walletsolidity/gettransactionbyid:\x01*Z$\x12\"/walletsoli\
    dity/gettransactionbyid\x12\xa8\x01\n\x16GetTransactionInfoById\x12\x16.\
    protocol.BytesMessage\x1a\x19.protocol.TransactionInfo\"[\x82\xd3\xe4\
    \x93\x02U\"&/walletsolidity/gettransactioninfobyid:\x01*Z(\x12&/walletso\
    lidity/gettransactioninfobyid\x12\x9b\x01\n\x0fGenerateAddress\x12\x16.p\
    rotocol.EmptyMessage\x1a!.protocol.AddressPrKeyPairMessage\"M\x82\xd3\
    \xe4\x93\x02G\"\x1f/walletsolidity/generateaddress:\x01*Z!\x12\x1f/walle\
    tsolidity/generateaddress2\xad\x04\n\x0fWalletExtension\x12\xb1\x01\n\
    \x17GetTransactionsFromThis\x12\x1a.protocol.AccountPaginated\x1a\x19.pr\
    otocol.TransactionList\"_\x82\xd3\xe4\x93\x02Y\"(/walletextension/gettra\
    nsactionsfromthis:\x01*Z*\x12(/walletextension/gettransactionsfromthis\
    \x12\\\n\x18GetTransactionsFromThis2\x12\x1a.protocol.AccountPaginated\
    \x1a\".protocol.TransactionListExtention\"\0\x12\xab\x01\n\x15GetTransac\
    tionsToThis\x12\x1a.protocol.AccountPaginated\x1a\x19.protocol.Transacti\
    onList\"[\x82\xd3\xe4\x93\x02U\"&/walletextension/gettransactionstothis:\
    \x01*Z(\x12&/walletextension/gettransactionstothis\x12Z\n\x16GetTransact\
    ionsToThis2\x12\x1a.protocol.AccountPaginated\x1a\".protocol.Transaction\
    ListExtention\"\02\x99\x02\n\x08Database\x12G\n\x11getBlockReference\x12\
    \x16.protocol.EmptyMessage\x1a\x18.protocol.BlockReference\"\0\x12M\n\
    \x14GetDynamicProperties\x12\x16.protocol.EmptyMessage\x1a\x1b.protocol.\
    DynamicProperties\"\0\x128\n\x0bGetNowBlock\x12\x16.protocol.EmptyMessag\
    e\x1a\x0f.protocol.Block\"\0\x12;\n\rGetBlockByNum\x12\x17.protocol.Numb\
    erMessage\x1a\x0f.protocol.Block\"\02\t\n\x07NetworkBA\n\x0corg.tron.api\
    B\x07GrpcAPIZ(github.com/tronprotocol/grpc-gateway/apiJ\xcd\xb3\x01\n\
    \x07\x12\x05\0\0\x94\x08\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x01\x08\x10\n\t\n\x02\x03\0\x12\x03\x03\x07\x18\n\t\n\x02\
    \x03\x01\x12\x03\x04\x07\x1c\n\t\n\x02\x03\x02\x12\x03\x05\x07%\n\x08\n\
    \x01\x08\x12\x03\x08\0%\nH\n\x02\x08\x01\x12\x03\x08\0%\"=Specify\x20the\
    \x20name\x20of\x20the\x20package\x20that\x20generated\x20the\x20Java\x20\
    file\n\n\x08\n\x01\x08\x12\x03\t\0(\n=\n\x02\x08\x08\x12\x03\t\0(\"2Spec\
    ify\x20the\x20class\x20name\x20of\x20the\x20generated\x20Java\x20file\n\
    \n\x08\n\x01\x08\x12\x03\n\0?\n\t\n\x02\x08\x0b\x12\x03\n\0?\n\x0b\n\x02\
    \x06\0\x12\x05\x0c\0\xf7\x04\x01\n\n\n\x03\x06\0\x01\x12\x03\x0c\x08\x0e\
    \n\x0c\n\x04\x06\0\x02\0\x12\x04\x0e\x02\x16\x03\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x03\x0e\x06\x10\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x0e\x12\x19\
    \n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x0e$+\n\r\n\x05\x06\0\x02\0\x04\x12\
    \x04\x0f\x04\x15\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04\x0f\
    \x04\x15\x06\n\x0c\n\x04\x06\0\x02\x01\x12\x04\x18\x02\x20\x03\n\x0c\n\
    \x05\x06\0\x02\x01\x01\x12\x03\x18\x06\x14\n\x0c\n\x05\x06\0\x02\x01\x02\
    \x12\x03\x18\x16\x1d\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x18(/\n\r\n\
    \x05\x06\0\x02\x01\x04\x12\x04\x19\x04\x1f\x06\n\x11\n\t\x06\0\x02\x01\
    \x04\xb0\xca\xbc\"\x12\x04\x19\x04\x1f\x06\nF\n\x04\x06\0\x02\x02\x12\
    \x04#\x02+\x03\x1a8Please\x20use\x20CreateTransaction2\x20instead\x20of\
    \x20this\x20function.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03#\x06\x17\n\
    \x0c\n\x05\x06\0\x02\x02\x02\x12\x03#\x19)\n\x0c\n\x05\x06\0\x02\x02\x03\
    \x12\x03#4?\n\r\n\x05\x06\0\x02\x02\x04\x12\x04$\x04*\x06\n\x11\n\t\x06\
    \0\x02\x02\x04\xb0\xca\xbc\"\x12\x04$\x04*\x06\n>\n\x04\x06\0\x02\x03\
    \x12\x04-\x02.\x03\x1a0Use\x20this\x20function\x20instead\x20of\x20Creat\
    eTransaction.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03-\x06\x18\n\x0c\n\
    \x05\x06\0\x02\x03\x02\x12\x03-\x1a*\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03-5I\n\x0c\n\x04\x06\0\x02\x04\x12\x040\x028\x03\n\x0c\n\x05\x06\0\
    \x02\x04\x01\x12\x030\x06\x1a\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x030\x1c\
    '\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03028\n\r\n\x05\x06\0\x02\x04\x04\
    \x12\x041\x047\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x041\
    \x047\x06\nB\n\x04\x06\0\x02\x05\x12\x04:\x02B\x03\x1a4Please\x20use\x20\
    UpdateAccount2\x20instead\x20of\x20this\x20function.\n\n\x0c\n\x05\x06\0\
    \x02\x05\x01\x12\x03:\x06\x13\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03:\x15\
    *\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03:5@\n\r\n\x05\x06\0\x02\x05\x04\
    \x12\x04;\x04A\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04;\
    \x04A\x06\n\x0c\n\x04\x06\0\x02\x06\x12\x04E\x02M\x03\n\x0c\n\x05\x06\0\
    \x02\x06\x01\x12\x03E\x06\x12\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03E\x14\
    (\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03E3>\n\r\n\x05\x06\0\x02\x06\x04\
    \x12\x04F\x04L\x06\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04F\
    \x04L\x06\n:\n\x04\x06\0\x02\x07\x12\x04P\x02Q\x03\x1a,Use\x20this\x20fu\
    nction\x20instead\x20of\x20UpdateAccount.\n\n\x0c\n\x05\x06\0\x02\x07\
    \x01\x12\x03P\x06\x14\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03P\x16+\n\x0c\
    \n\x05\x06\0\x02\x07\x03\x12\x03P6J\nG\n\x04\x06\0\x02\x08\x12\x04T\x02\
    \\\x03\x1a9Please\x20use\x20VoteWitnessAccount2\x20instead\x20of\x20this\
    \x20function.\n\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03T\x06\x18\n\x0c\n\
    \x05\x06\0\x02\x08\x02\x12\x03T\x1a-\n\x0c\n\x05\x06\0\x02\x08\x03\x12\
    \x03T8C\n\r\n\x05\x06\0\x02\x08\x04\x12\x04U\x04[\x06\n\x11\n\t\x06\0\
    \x02\x08\x04\xb0\xca\xbc\"\x12\x04U\x04[\x06\n7\n\x04\x06\0\x02\t\x12\
    \x04_\x02`\x03\x1a)modify\x20the\x20consume_user_resource_percent\n\n\
    \x0c\n\x05\x06\0\x02\t\x01\x12\x03_\x06\x13\n\x0c\n\x05\x06\0\x02\t\x02\
    \x12\x03_\x15*\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03_5I\n&\n\x04\x06\0\x02\
    \n\x12\x04c\x02d\x03\x1a\x18modify\x20the\x20energy_limit\n\n\x0c\n\x05\
    \x06\0\x02\n\x01\x12\x03c\x06\x17\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03c\
    \x192\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03c=Q\n?\n\x04\x06\0\x02\x0b\x12\
    \x04g\x02h\x03\x1a1Use\x20this\x20function\x20instead\x20of\x20VoteWitne\
    ssAccount.\n\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03g\x06\x19\n\x0c\n\x05\
    \x06\0\x02\x0b\x02\x12\x03g\x1b.\n\x0c\n\x05\x06\0\x02\x0b\x03\x12\x03g9\
    M\nE\n\x04\x06\0\x02\x0c\x12\x04j\x02r\x03\x1a7Please\x20use\x20CreateAs\
    setIssue2\x20instead\x20of\x20this\x20function.\n\n\x0c\n\x05\x06\0\x02\
    \x0c\x01\x12\x03j\x06\x16\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03j\x18*\n\
    \x0c\n\x05\x06\0\x02\x0c\x03\x12\x03j5@\n\r\n\x05\x06\0\x02\x0c\x04\x12\
    \x04k\x04q\x06\n\x11\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x04k\x04q\
    \x06\n=\n\x04\x06\0\x02\r\x12\x04t\x02u\x03\x1a/Use\x20this\x20function\
    \x20instead\x20of\x20CreateAssetIssue.\n\n\x0c\n\x05\x06\0\x02\r\x01\x12\
    \x03t\x06\x17\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03t\x19+\n\x0c\n\x05\x06\
    \0\x02\r\x03\x12\x03t6J\nB\n\x04\x06\0\x02\x0e\x12\x04w\x02\x7f\x03\x1a4\
    Please\x20use\x20UpdateWitness2\x20instead\x20of\x20this\x20function.\n\
    \n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03w\x06\x13\n\x0c\n\x05\x06\0\x02\
    \x0e\x02\x12\x03w\x15*\n\x0c\n\x05\x06\0\x02\x0e\x03\x12\x03w5@\n\r\n\
    \x05\x06\0\x02\x0e\x04\x12\x04x\x04~\x06\n\x11\n\t\x06\0\x02\x0e\x04\xb0\
    \xca\xbc\"\x12\x04x\x04~\x06\n<\n\x04\x06\0\x02\x0f\x12\x06\x81\x01\x02\
    \x82\x01\x03\x1a,Use\x20this\x20function\x20instead\x20of\x20UpdateWitne\
    ss.\n\n\r\n\x05\x06\0\x02\x0f\x01\x12\x04\x81\x01\x06\x14\n\r\n\x05\x06\
    \0\x02\x0f\x02\x12\x04\x81\x01\x16+\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\
    \x81\x016J\nD\n\x04\x06\0\x02\x10\x12\x06\x84\x01\x02\x8c\x01\x03\x1a4Pl\
    ease\x20use\x20CreateAccount2\x20instead\x20of\x20this\x20function.\n\n\
    \r\n\x05\x06\0\x02\x10\x01\x12\x04\x84\x01\x06\x13\n\r\n\x05\x06\0\x02\
    \x10\x02\x12\x04\x84\x01\x15*\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\x84\
    \x015@\n\x0f\n\x05\x06\0\x02\x10\x04\x12\x06\x85\x01\x04\x8b\x01\x06\n\
    \x13\n\t\x06\0\x02\x10\x04\xb0\xca\xbc\"\x12\x06\x85\x01\x04\x8b\x01\x06\
    \n<\n\x04\x06\0\x02\x11\x12\x06\x8e\x01\x02\x8f\x01\x03\x1a,Use\x20this\
    \x20function\x20instead\x20of\x20CreateAccount.\n\n\r\n\x05\x06\0\x02\
    \x11\x01\x12\x04\x8e\x01\x06\x14\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\x8e\
    \x01\x16+\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\x8e\x016J\nD\n\x04\x06\0\
    \x02\x12\x12\x06\x91\x01\x02\x99\x01\x03\x1a4Please\x20use\x20CreateWitn\
    ess2\x20instead\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\x02\x12\x01\
    \x12\x04\x91\x01\x06\x13\n\r\n\x05\x06\0\x02\x12\x02\x12\x04\x91\x01\x15\
    *\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\x91\x015@\n\x0f\n\x05\x06\0\x02\
    \x12\x04\x12\x06\x92\x01\x04\x98\x01\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\
    \xca\xbc\"\x12\x06\x92\x01\x04\x98\x01\x06\n<\n\x04\x06\0\x02\x13\x12\
    \x06\x9b\x01\x02\x9c\x01\x03\x1a,Use\x20this\x20function\x20instead\x20o\
    f\x20CreateWitness.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\x9b\x01\x06\
    \x14\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\x9b\x01\x16+\n\r\n\x05\x06\0\
    \x02\x13\x03\x12\x04\x9b\x016J\nD\n\x04\x06\0\x02\x14\x12\x06\x9e\x01\
    \x02\xa6\x01\x03\x1a4Please\x20use\x20TransferAsset2\x20instead\x20of\
    \x20this\x20function.\n\n\r\n\x05\x06\0\x02\x14\x01\x12\x04\x9e\x01\x06\
    \x13\n\r\n\x05\x06\0\x02\x14\x02\x12\x04\x9e\x01\x15*\n\r\n\x05\x06\0\
    \x02\x14\x03\x12\x04\x9e\x015@\n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\x9f\
    \x01\x04\xa5\x01\x06\n\x13\n\t\x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\
    \x9f\x01\x04\xa5\x01\x06\n<\n\x04\x06\0\x02\x15\x12\x06\xa8\x01\x02\xa9\
    \x01\x03\x1a,Use\x20this\x20function\x20instead\x20of\x20TransferAsset.\
    \n\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\xa8\x01\x06\x14\n\r\n\x05\x06\0\
    \x02\x15\x02\x12\x04\xa8\x01\x16+\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\
    \xa8\x016J\nL\n\x04\x06\0\x02\x16\x12\x06\xab\x01\x02\xb3\x01\x03\x1a<Pl\
    ease\x20use\x20ParticipateAssetIssue2\x20instead\x20of\x20this\x20functi\
    on.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\xab\x01\x06\x1b\n\r\n\x05\x06\
    \0\x02\x16\x02\x12\x04\xab\x01\x1d:\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\
    \xab\x01EP\n\x0f\n\x05\x06\0\x02\x16\x04\x12\x06\xac\x01\x04\xb2\x01\x06\
    \n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\x12\x06\xac\x01\x04\xb2\x01\
    \x06\nD\n\x04\x06\0\x02\x17\x12\x06\xb5\x01\x02\xb6\x01\x03\x1a4Use\x20t\
    his\x20function\x20instead\x20of\x20ParticipateAssetIssue.\n\n\r\n\x05\
    \x06\0\x02\x17\x01\x12\x04\xb5\x01\x06\x1c\n\r\n\x05\x06\0\x02\x17\x02\
    \x12\x04\xb5\x01\x1e;\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\xb5\x01FZ\nD\n\
    \x04\x06\0\x02\x18\x12\x06\xb8\x01\x02\xc0\x01\x03\x1a4Please\x20use\x20\
    FreezeBalance2\x20instead\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\
    \x02\x18\x01\x12\x04\xb8\x01\x06\x13\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\
    \xb8\x01\x15*\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\xb8\x015@\n\x0f\n\x05\
    \x06\0\x02\x18\x04\x12\x06\xb9\x01\x04\xbf\x01\x06\n\x13\n\t\x06\0\x02\
    \x18\x04\xb0\xca\xbc\"\x12\x06\xb9\x01\x04\xbf\x01\x06\n<\n\x04\x06\0\
    \x02\x19\x12\x06\xc2\x01\x02\xc3\x01\x03\x1a,Use\x20this\x20function\x20\
    instead\x20of\x20FreezeBalance.\n\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\
    \xc2\x01\x06\x14\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xc2\x01\x16+\n\r\n\
    \x05\x06\0\x02\x19\x03\x12\x04\xc2\x016J\nF\n\x04\x06\0\x02\x1a\x12\x06\
    \xc5\x01\x02\xcd\x01\x03\x1a6Please\x20use\x20UnfreezeBalance2\x20instea\
    d\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\x02\x1a\x01\x12\x04\xc5\
    \x01\x06\x15\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xc5\x01\x17.\n\r\n\x05\
    \x06\0\x02\x1a\x03\x12\x04\xc5\x019D\n\x0f\n\x05\x06\0\x02\x1a\x04\x12\
    \x06\xc6\x01\x04\xcc\x01\x06\n\x13\n\t\x06\0\x02\x1a\x04\xb0\xca\xbc\"\
    \x12\x06\xc6\x01\x04\xcc\x01\x06\n>\n\x04\x06\0\x02\x1b\x12\x06\xcf\x01\
    \x02\xd0\x01\x03\x1a.Use\x20this\x20function\x20instead\x20of\x20Unfreez\
    eBalance.\n\n\r\n\x05\x06\0\x02\x1b\x01\x12\x04\xcf\x01\x06\x16\n\r\n\
    \x05\x06\0\x02\x1b\x02\x12\x04\xcf\x01\x18/\n\r\n\x05\x06\0\x02\x1b\x03\
    \x12\x04\xcf\x01:N\nD\n\x04\x06\0\x02\x1c\x12\x06\xd2\x01\x02\xda\x01\
    \x03\x1a4Please\x20use\x20UnfreezeAsset2\x20instead\x20of\x20this\x20fun\
    ction.\n\n\r\n\x05\x06\0\x02\x1c\x01\x12\x04\xd2\x01\x06\x13\n\r\n\x05\
    \x06\0\x02\x1c\x02\x12\x04\xd2\x01\x15*\n\r\n\x05\x06\0\x02\x1c\x03\x12\
    \x04\xd2\x015@\n\x0f\n\x05\x06\0\x02\x1c\x04\x12\x06\xd3\x01\x04\xd9\x01\
    \x06\n\x13\n\t\x06\0\x02\x1c\x04\xb0\xca\xbc\"\x12\x06\xd3\x01\x04\xd9\
    \x01\x06\n<\n\x04\x06\0\x02\x1d\x12\x06\xdc\x01\x02\xdd\x01\x03\x1a,Use\
    \x20this\x20function\x20instead\x20of\x20UnfreezeAsset.\n\n\r\n\x05\x06\
    \0\x02\x1d\x01\x12\x04\xdc\x01\x06\x14\n\r\n\x05\x06\0\x02\x1d\x02\x12\
    \x04\xdc\x01\x16+\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\xdc\x016J\nF\n\x04\
    \x06\0\x02\x1e\x12\x06\xdf\x01\x02\xe7\x01\x03\x1a6Please\x20use\x20With\
    drawBalance2\x20instead\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\x02\
    \x1e\x01\x12\x04\xdf\x01\x06\x15\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\xdf\
    \x01\x17.\n\r\n\x05\x06\0\x02\x1e\x03\x12\x04\xdf\x019D\n\x0f\n\x05\x06\
    \0\x02\x1e\x04\x12\x06\xe0\x01\x04\xe6\x01\x06\n\x13\n\t\x06\0\x02\x1e\
    \x04\xb0\xca\xbc\"\x12\x06\xe0\x01\x04\xe6\x01\x06\n>\n\x04\x06\0\x02\
    \x1f\x12\x06\xe9\x01\x02\xea\x01\x03\x1a.Use\x20this\x20function\x20inst\
    ead\x20of\x20WithdrawBalance.\n\n\r\n\x05\x06\0\x02\x1f\x01\x12\x04\xe9\
    \x01\x06\x16\n\r\n\x05\x06\0\x02\x1f\x02\x12\x04\xe9\x01\x18/\n\r\n\x05\
    \x06\0\x02\x1f\x03\x12\x04\xe9\x01:N\nB\n\x04\x06\0\x02\x20\x12\x06\xec\
    \x01\x02\xf4\x01\x03\x1a2Please\x20use\x20UpdateAsset2\x20instead\x20of\
    \x20this\x20function.\n\n\r\n\x05\x06\0\x02\x20\x01\x12\x04\xec\x01\x06\
    \x11\n\r\n\x05\x06\0\x02\x20\x02\x12\x04\xec\x01\x13&\n\r\n\x05\x06\0\
    \x02\x20\x03\x12\x04\xec\x011<\n\x0f\n\x05\x06\0\x02\x20\x04\x12\x06\xed\
    \x01\x04\xf3\x01\x06\n\x13\n\t\x06\0\x02\x20\x04\xb0\xca\xbc\"\x12\x06\
    \xed\x01\x04\xf3\x01\x06\n:\n\x04\x06\0\x02!\x12\x06\xf6\x01\x02\xf7\x01\
    \x03\x1a*Use\x20this\x20function\x20instead\x20of\x20UpdateAsset.\n\n\r\
    \n\x05\x06\0\x02!\x01\x12\x04\xf6\x01\x06\x12\n\r\n\x05\x06\0\x02!\x02\
    \x12\x04\xf6\x01\x14'\n\r\n\x05\x06\0\x02!\x03\x12\x04\xf6\x012F\n\x0e\n\
    \x04\x06\0\x02\"\x12\x06\xf9\x01\x02\xfa\x01\x03\n\r\n\x05\x06\0\x02\"\
    \x01\x12\x04\xf9\x01\x06\x14\n\r\n\x05\x06\0\x02\"\x02\x12\x04\xf9\x01\
    \x16,\n\r\n\x05\x06\0\x02\"\x03\x12\x04\xf9\x017K\n\x0e\n\x04\x06\0\x02#\
    \x12\x06\xfc\x01\x02\xfd\x01\x03\n\r\n\x05\x06\0\x02#\x01\x12\x04\xfc\
    \x01\x06\x15\n\r\n\x05\x06\0\x02#\x02\x12\x04\xfc\x01\x17.\n\r\n\x05\x06\
    \0\x02#\x03\x12\x04\xfc\x019M\n\x0e\n\x04\x06\0\x02$\x12\x06\xff\x01\x02\
    \x80\x02\x03\n\r\n\x05\x06\0\x02$\x01\x12\x04\xff\x01\x06\x14\n\r\n\x05\
    \x06\0\x02$\x02\x12\x04\xff\x01\x16,\n\r\n\x05\x06\0\x02$\x03\x12\x04\
    \xff\x017K\n\x0e\n\x04\x06\0\x02%\x12\x06\x82\x02\x02\x83\x02\x03\n\r\n\
    \x05\x06\0\x02%\x01\x12\x04\x82\x02\x06\x10\n\r\n\x05\x06\0\x02%\x02\x12\
    \x04\x82\x02\x12$\n\r\n\x05\x06\0\x02%\x03\x12\x04\x82\x02/C\n\x0e\n\x04\
    \x06\0\x02&\x12\x06\x85\x02\x02\x86\x02\x03\n\r\n\x05\x06\0\x02&\x01\x12\
    \x04\x85\x02\x06\x15\n\r\n\x05\x06\0\x02&\x02\x12\x04\x85\x02\x17.\n\r\n\
    \x05\x06\0\x02&\x03\x12\x04\x85\x029M\n\x0e\n\x04\x06\0\x02'\x12\x06\x88\
    \x02\x02\x89\x02\x03\n\r\n\x05\x06\0\x02'\x01\x12\x04\x88\x02\x06\x11\n\
    \r\n\x05\x06\0\x02'\x02\x12\x04\x88\x02\x13&\n\r\n\x05\x06\0\x02'\x03\
    \x12\x04\x88\x021E\n\x0e\n\x04\x06\0\x02(\x12\x06\x8b\x02\x02\x8c\x02\
    \x03\n\r\n\x05\x06\0\x02(\x01\x12\x04\x8b\x02\x06\x14\n\r\n\x05\x06\0\
    \x02(\x02\x12\x04\x8b\x02\x16,\n\r\n\x05\x06\0\x02(\x03\x12\x04\x8b\x027\
    K\n\x0e\n\x04\x06\0\x02)\x12\x06\x8e\x02\x02\x8f\x02\x03\n\r\n\x05\x06\0\
    \x02)\x01\x12\x04\x8e\x02\x06\x14\n\r\n\x05\x06\0\x02)\x02\x12\x04\x8e\
    \x02\x16,\n\r\n\x05\x06\0\x02)\x03\x12\x04\x8e\x027K\n\x0e\n\x04\x06\0\
    \x02*\x12\x06\x91\x02\x02\x92\x02\x03\n\r\n\x05\x06\0\x02*\x01\x12\x04\
    \x91\x02\x06\x16\n\r\n\x05\x06\0\x02*\x02\x12\x04\x91\x02\x180\n\r\n\x05\
    \x06\0\x02*\x03\x12\x04\x91\x02;O\n\x0e\n\x04\x06\0\x02+\x12\x06\x94\x02\
    \x02\x95\x02\x03\n\r\n\x05\x06\0\x02+\x01\x12\x04\x94\x02\x06\x19\n\r\n\
    \x05\x06\0\x02+\x02\x12\x04\x94\x02\x1b6\n\r\n\x05\x06\0\x02+\x03\x12\
    \x04\x94\x02AU\n\x0e\n\x04\x06\0\x02,\x12\x06\x97\x02\x02\x9f\x02\x03\n\
    \r\n\x05\x06\0\x02,\x01\x12\x04\x97\x02\x06\x0f\n\r\n\x05\x06\0\x02,\x02\
    \x12\x04\x97\x02\x11\x1d\n\r\n\x05\x06\0\x02,\x03\x12\x04\x97\x02(0\n\
    \x0f\n\x05\x06\0\x02,\x04\x12\x06\x98\x02\x04\x9e\x02\x06\n\x13\n\t\x06\
    \0\x02,\x04\xb0\xca\xbc\"\x12\x06\x98\x02\x04\x9e\x02\x06\n\x0e\n\x04\
    \x06\0\x02-\x12\x06\xa1\x02\x02\xa9\x02\x03\n\r\n\x05\x06\0\x02-\x01\x12\
    \x04\xa1\x02\x06\x1c\n\r\n\x05\x06\0\x02-\x02\x12\x04\xa1\x02\x1e%\n\r\n\
    \x05\x06\0\x02-\x03\x12\x04\xa1\x020>\n\x0f\n\x05\x06\0\x02-\x04\x12\x06\
    \xa2\x02\x04\xa8\x02\x06\n\x13\n\t\x06\0\x02-\x04\xb0\xca\xbc\"\x12\x06\
    \xa2\x02\x04\xa8\x02\x06\n\x0e\n\x04\x06\0\x02.\x12\x06\xaa\x02\x02\xb2\
    \x02\x03\n\r\n\x05\x06\0\x02.\x01\x12\x04\xaa\x02\x06\x13\n\r\n\x05\x06\
    \0\x02.\x02\x12\x04\xaa\x02\x15\x1c\n\r\n\x05\x06\0\x02.\x03\x12\x04\xaa\
    \x02'8\n\x0f\n\x05\x06\0\x02.\x04\x12\x06\xab\x02\x04\xb1\x02\x08\n\x13\
    \n\t\x06\0\x02.\x04\xb0\xca\xbc\"\x12\x06\xab\x02\x04\xb1\x02\x08\n\x0e\
    \n\x04\x06\0\x02/\x12\x06\xb3\x02\x02\xb4\x02\x03\n\r\n\x05\x06\0\x02/\
    \x01\x12\x04\xb3\x02\x06\x18\n\r\n\x05\x06\0\x02/\x02\x12\x04\xb3\x02\
    \x1a!\n\r\n\x05\x06\0\x02/\x03\x12\x04\xb3\x02,B\n\x0e\n\x04\x06\0\x020\
    \x12\x06\xb5\x02\x02\xbd\x02\x03\n\r\n\x05\x06\0\x020\x01\x12\x04\xb5\
    \x02\x06\x19\n\r\n\x05\x06\0\x020\x02\x12\x04\xb5\x02\x1b'\n\r\n\x05\x06\
    \0\x020\x03\x12\x04\xb5\x022D\n\x0f\n\x05\x06\0\x020\x04\x12\x06\xb6\x02\
    \x04\xbc\x02\x06\n\x13\n\t\x06\0\x020\x04\xb0\xca\xbc\"\x12\x06\xb6\x02\
    \x04\xbc\x02\x06\n\x0e\n\x04\x06\0\x021\x12\x06\xbe\x02\x02\xbf\x02\x03\
    \n\r\n\x05\x06\0\x021\x01\x12\x04\xbe\x02\x06\x1d\n\r\n\x05\x06\0\x021\
    \x02\x12\x04\xbe\x02\x1f+\n\r\n\x05\x06\0\x021\x03\x12\x04\xbe\x026D\n\
    \x0e\n\x04\x06\0\x022\x12\x06\xc0\x02\x02\xc1\x02\x03\n\r\n\x05\x06\0\
    \x022\x01\x12\x04\xc0\x02\x06\x17\n\r\n\x05\x06\0\x022\x02\x12\x04\xc0\
    \x02\x19%\n\r\n\x05\x06\0\x022\x03\x12\x04\xc0\x020B\nB\n\x04\x06\0\x023\
    \x12\x06\xc3\x02\x02\xcb\x02\x03\x1a2Please\x20use\x20GetNowBlock2\x20in\
    stead\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\x023\x01\x12\x04\xc3\
    \x02\x06\x11\n\r\n\x05\x06\0\x023\x02\x12\x04\xc3\x02\x13\x1f\n\r\n\x05\
    \x06\0\x023\x03\x12\x04\xc3\x02*/\n\x0f\n\x05\x06\0\x023\x04\x12\x06\xc4\
    \x02\x04\xca\x02\x06\n\x13\n\t\x06\0\x023\x04\xb0\xca\xbc\"\x12\x06\xc4\
    \x02\x04\xca\x02\x06\n:\n\x04\x06\0\x024\x12\x06\xcd\x02\x02\xce\x02\x03\
    \x1a*Use\x20this\x20function\x20instead\x20of\x20GetNowBlock.\n\n\r\n\
    \x05\x06\0\x024\x01\x12\x04\xcd\x02\x06\x12\n\r\n\x05\x06\0\x024\x02\x12\
    \x04\xcd\x02\x14\x20\n\r\n\x05\x06\0\x024\x03\x12\x04\xcd\x02+9\nD\n\x04\
    \x06\0\x025\x12\x06\xd0\x02\x02\xd8\x02\x03\x1a4Please\x20use\x20GetBloc\
    kByNum2\x20instead\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\x025\x01\
    \x12\x04\xd0\x02\x06\x13\n\r\n\x05\x06\0\x025\x02\x12\x04\xd0\x02\x15\"\
    \n\r\n\x05\x06\0\x025\x03\x12\x04\xd0\x02-2\n\x0f\n\x05\x06\0\x025\x04\
    \x12\x06\xd1\x02\x04\xd7\x02\x06\n\x13\n\t\x06\0\x025\x04\xb0\xca\xbc\"\
    \x12\x06\xd1\x02\x04\xd7\x02\x06\n<\n\x04\x06\0\x026\x12\x06\xda\x02\x02\
    \xdb\x02\x03\x1a,Use\x20this\x20function\x20instead\x20of\x20GetBlockByN\
    um.\n\n\r\n\x05\x06\0\x026\x01\x12\x04\xda\x02\x06\x14\n\r\n\x05\x06\0\
    \x026\x02\x12\x04\xda\x02\x16#\n\r\n\x05\x06\0\x026\x03\x12\x04\xda\x02.\
    <\n\x0e\n\x04\x06\0\x027\x12\x06\xdd\x02\x02\xde\x02\x03\n\r\n\x05\x06\0\
    \x027\x01\x12\x04\xdd\x02\x06#\n\r\n\x05\x06\0\x027\x02\x12\x04\xdd\x02%\
    2\n\r\n\x05\x06\0\x027\x03\x12\x04\xdd\x02=J\n\x0e\n\x04\x06\0\x028\x12\
    \x06\xe0\x02\x02\xe8\x02\x03\n\r\n\x05\x06\0\x028\x01\x12\x04\xe0\x02\
    \x06\x12\n\r\n\x05\x06\0\x028\x02\x12\x04\xe0\x02\x14\x20\n\r\n\x05\x06\
    \0\x028\x03\x12\x04\xe0\x02+0\n\x0f\n\x05\x06\0\x028\x04\x12\x06\xe1\x02\
    \x04\xe7\x02\x06\n\x13\n\t\x06\0\x028\x04\xb0\xca\xbc\"\x12\x06\xe1\x02\
    \x04\xe7\x02\x06\nJ\n\x04\x06\0\x029\x12\x06\xea\x02\x02\xf2\x02\x03\x1a\
    :Please\x20use\x20GetBlockByLimitNext2\x20instead\x20of\x20this\x20funct\
    ion.\n\n\r\n\x05\x06\0\x029\x01\x12\x04\xea\x02\x06\x19\n\r\n\x05\x06\0\
    \x029\x02\x12\x04\xea\x02\x1b%\n\r\n\x05\x06\0\x029\x03\x12\x04\xea\x020\
    9\n\x0f\n\x05\x06\0\x029\x04\x12\x06\xeb\x02\x04\xf1\x02\x06\n\x13\n\t\
    \x06\0\x029\x04\xb0\xca\xbc\"\x12\x06\xeb\x02\x04\xf1\x02\x06\nB\n\x04\
    \x06\0\x02:\x12\x06\xf4\x02\x02\xf5\x02\x03\x1a2Use\x20this\x20function\
    \x20instead\x20of\x20GetBlockByLimitNext.\n\n\r\n\x05\x06\0\x02:\x01\x12\
    \x04\xf4\x02\x06\x1a\n\r\n\x05\x06\0\x02:\x02\x12\x04\xf4\x02\x1c&\n\r\n\
    \x05\x06\0\x02:\x03\x12\x04\xf4\x021C\nJ\n\x04\x06\0\x02;\x12\x06\xf7\
    \x02\x02\xff\x02\x03\x1a:Please\x20use\x20GetBlockByLatestNum2\x20instea\
    d\x20of\x20this\x20function.\n\n\r\n\x05\x06\0\x02;\x01\x12\x04\xf7\x02\
    \x06\x19\n\r\n\x05\x06\0\x02;\x02\x12\x04\xf7\x02\x1b(\n\r\n\x05\x06\0\
    \x02;\x03\x12\x04\xf7\x023<\n\x0f\n\x05\x06\0\x02;\x04\x12\x06\xf8\x02\
    \x04\xfe\x02\x06\n\x13\n\t\x06\0\x02;\x04\xb0\xca\xbc\"\x12\x06\xf8\x02\
    \x04\xfe\x02\x06\nB\n\x04\x06\0\x02<\x12\x06\x81\x03\x02\x82\x03\x03\x1a\
    2Use\x20this\x20function\x20instead\x20of\x20GetBlockByLatestNum.\n\n\r\
    \n\x05\x06\0\x02<\x01\x12\x04\x81\x03\x06\x1a\n\r\n\x05\x06\0\x02<\x02\
    \x12\x04\x81\x03\x1c)\n\r\n\x05\x06\0\x02<\x03\x12\x04\x81\x034F\n\x0e\n\
    \x04\x06\0\x02=\x12\x06\x83\x03\x02\x8b\x03\x03\n\r\n\x05\x06\0\x02=\x01\
    \x12\x04\x83\x03\x06\x18\n\r\n\x05\x06\0\x02=\x02\x12\x04\x83\x03\x1a&\n\
    \r\n\x05\x06\0\x02=\x03\x12\x04\x83\x031<\n\x0f\n\x05\x06\0\x02=\x04\x12\
    \x06\x84\x03\x04\x8a\x03\x06\n\x13\n\t\x06\0\x02=\x04\xb0\xca\xbc\"\x12\
    \x06\x84\x03\x04\x8a\x03\x06\n\x0e\n\x04\x06\0\x02>\x12\x06\x8d\x03\x02\
    \x8e\x03\x03\n\r\n\x05\x06\0\x02>\x01\x12\x04\x8d\x03\x06\x14\n\r\n\x05\
    \x06\0\x02>\x02\x12\x04\x8d\x03\x16)\n\r\n\x05\x06\0\x02>\x03\x12\x04\
    \x8d\x034H\n\x0e\n\x04\x06\0\x02?\x12\x06\x90\x03\x02\x91\x03\x03\n\r\n\
    \x05\x06\0\x02?\x01\x12\x04\x90\x03\x06\x11\n\r\n\x05\x06\0\x02?\x02\x12\
    \x04\x90\x03\x13\x1f\n\r\n\x05\x06\0\x02?\x03\x12\x04\x90\x03*7\n\x0e\n\
    \x04\x06\0\x02@\x12\x06\x93\x03\x02\x94\x03\x03\n\r\n\x05\x06\0\x02@\x01\
    \x12\x04\x93\x03\x06\x15\n\r\n\x05\x06\0\x02@\x02\x12\x04\x93\x03\x17+\n\
    \r\n\x05\x06\0\x02@\x03\x12\x04\x93\x036J\n\x0e\n\x04\x06\0\x02A\x12\x06\
    \x96\x03\x02\x97\x03\x03\n\r\n\x05\x06\0\x02A\x01\x12\x04\x96\x03\x06\
    \x1d\n\r\n\x05\x06\0\x02A\x02\x12\x04\x96\x03\x1f3\n\r\n\x05\x06\0\x02A\
    \x03\x12\x04\x96\x03>R\n\x0e\n\x04\x06\0\x02B\x12\x06\x99\x03\x02\x9a\
    \x03\x03\n\r\n\x05\x06\0\x02B\x01\x12\x04\x99\x03\x06\x16\n\r\n\x05\x06\
    \0\x02B\x02\x12\x04\x99\x03\x18(\n\r\n\x05\x06\0\x02B\x03\x12\x04\x99\
    \x033G\n\x0e\n\x04\x06\0\x02C\x12\x06\x9c\x03\x02\xa4\x03\x03\n\r\n\x05\
    \x06\0\x02C\x01\x12\x04\x9c\x03\x06\x13\n\r\n\x05\x06\0\x02C\x02\x12\x04\
    \x9c\x03\x15!\n\r\n\x05\x06\0\x02C\x03\x12\x04\x9c\x03,7\n\x0f\n\x05\x06\
    \0\x02C\x04\x12\x06\x9d\x03\x04\xa3\x03\x06\n\x13\n\t\x06\0\x02C\x04\xb0\
    \xca\xbc\"\x12\x06\x9d\x03\x04\xa3\x03\x06\n\x0e\n\x04\x06\0\x02D\x12\
    \x06\xa7\x03\x02\xa8\x03\x03\n\r\n\x05\x06\0\x02D\x01\x12\x04\xa7\x03\
    \x06\x1a\n\r\n\x05\x06\0\x02D\x02\x12\x04\xa7\x03\x1c4\n\r\n\x05\x06\0\
    \x02D\x03\x12\x04\xa7\x03?T\n\x0e\n\x04\x06\0\x02E\x12\x06\xaa\x03\x02\
    \xab\x03\x03\n\r\n\x05\x06\0\x02E\x01\x12\x04\xaa\x03\x06&\n\r\n\x05\x06\
    \0\x02E\x02\x12\x04\xaa\x03(4\n\r\n\x05\x06\0\x02E\x03\x12\x04\xaa\x03?\
    \\\n\x0e\n\x04\x06\0\x02F\x12\x06\xad\x03\x02\xb5\x03\x03\n\r\n\x05\x06\
    \0\x02F\x01\x12\x04\xad\x03\x06\x13\n\r\n\x05\x06\0\x02F\x02\x12\x04\xad\
    \x03\x15!\n\r\n\x05\x06\0\x02F\x03\x12\x04\xad\x03,8\n\x0f\n\x05\x06\0\
    \x02F\x04\x12\x06\xae\x03\x04\xb4\x03\x06\n\x13\n\t\x06\0\x02F\x04\xb0\
    \xca\xbc\"\x12\x06\xae\x03\x04\xb4\x03\x06\n\x0e\n\x04\x06\0\x02G\x12\
    \x06\xb6\x03\x02\xbe\x03\x03\n\r\n\x05\x06\0\x02G\x01\x12\x04\xb6\x03\
    \x06\x1e\n\r\n\x05\x06\0\x02G\x02\x12\x04\xb6\x03\x200\n\r\n\x05\x06\0\
    \x02G\x03\x12\x04\xb6\x03;G\n\x0f\n\x05\x06\0\x02G\x04\x12\x06\xb7\x03\
    \x04\xbd\x03\n\n\x13\n\t\x06\0\x02G\x04\xb0\xca\xbc\"\x12\x06\xb7\x03\
    \x04\xbd\x03\n\n\x0e\n\x04\x06\0\x02H\x12\x06\xbf\x03\x02\xc7\x03\x03\n\
    \r\n\x05\x06\0\x02H\x01\x12\x04\xbf\x03\x06\x15\n\r\n\x05\x06\0\x02H\x02\
    \x12\x04\xbf\x03\x17#\n\r\n\x05\x06\0\x02H\x03\x12\x04\xbf\x03.6\n\x0f\n\
    \x05\x06\0\x02H\x04\x12\x06\xc0\x03\x04\xc6\x03\x08\n\x13\n\t\x06\0\x02H\
    \x04\xb0\xca\xbc\"\x12\x06\xc0\x03\x04\xc6\x03\x08\n\x0e\n\x04\x06\0\x02\
    I\x12\x06\xc9\x03\x02\xd1\x03\x03\n\r\n\x05\x06\0\x02I\x01\x12\x04\xc9\
    \x03\x06\x13\n\r\n\x05\x06\0\x02I\x02\x12\x04\xc9\x03\x15!\n\r\n\x05\x06\
    \0\x02I\x03\x12\x04\xc9\x03,8\n\x0f\n\x05\x06\0\x02I\x04\x12\x06\xca\x03\
    \x04\xd0\x03\x06\n\x13\n\t\x06\0\x02I\x04\xb0\xca\xbc\"\x12\x06\xca\x03\
    \x04\xd0\x03\x06\n\x0e\n\x04\x06\0\x02J\x12\x06\xd2\x03\x02\xda\x03\x03\
    \n\r\n\x05\x06\0\x02J\x01\x12\x04\xd2\x03\x06\x1e\n\r\n\x05\x06\0\x02J\
    \x02\x12\x04\xd2\x03\x200\n\r\n\x05\x06\0\x02J\x03\x12\x04\xd2\x03;G\n\
    \x0f\n\x05\x06\0\x02J\x04\x12\x06\xd3\x03\x04\xd9\x03\n\n\x13\n\t\x06\0\
    \x02J\x04\xb0\xca\xbc\"\x12\x06\xd3\x03\x04\xd9\x03\n\n\x0e\n\x04\x06\0\
    \x02K\x12\x06\xdb\x03\x02\xe3\x03\x03\n\r\n\x05\x06\0\x02K\x01\x12\x04\
    \xdb\x03\x06\x15\n\r\n\x05\x06\0\x02K\x02\x12\x04\xdb\x03\x17#\n\r\n\x05\
    \x06\0\x02K\x03\x12\x04\xdb\x03.6\n\x0f\n\x05\x06\0\x02K\x04\x12\x06\xdc\
    \x03\x04\xe2\x03\x08\n\x13\n\t\x06\0\x02K\x04\xb0\xca\xbc\"\x12\x06\xdc\
    \x03\x04\xe2\x03\x08\n\x0e\n\x04\x06\0\x02L\x12\x06\xe5\x03\x02\xed\x03\
    \x03\n\r\n\x05\x06\0\x02L\x01\x12\x04\xe5\x03\x06\x18\n\r\n\x05\x06\0\
    \x02L\x02\x12\x04\xe5\x03\x1a&\n\r\n\x05\x06\0\x02L\x03\x12\x04\xe5\x031\
    @\n\x0f\n\x05\x06\0\x02L\x04\x12\x06\xe6\x03\x04\xec\x03\t\n\x13\n\t\x06\
    \0\x02L\x04\xb0\xca\xbc\"\x12\x06\xe6\x03\x04\xec\x03\t\n\x0e\n\x04\x06\
    \0\x02M\x12\x06\xef\x03\x02\xf7\x03\x03\n\r\n\x05\x06\0\x02M\x01\x12\x04\
    \xef\x03\x06\x17\n\r\n\x05\x06\0\x02M\x02\x12\x04\xef\x03\x19%\n\r\n\x05\
    \x06\0\x02M\x03\x12\x04\xef\x030>\n\x0f\n\x05\x06\0\x02M\x04\x12\x06\xf0\
    \x03\x04\xf6\x03\x08\n\x13\n\t\x06\0\x02M\x04\xb0\xca\xbc\"\x12\x06\xf0\
    \x03\x04\xf6\x03\x08\n\x0e\n\x04\x06\0\x02N\x12\x06\xf8\x03\x02\x80\x04\
    \x03\n\r\n\x05\x06\0\x02N\x01\x12\x04\xf8\x03\x06\x20\n\r\n\x05\x06\0\
    \x02N\x02\x12\x04\xf8\x03\"2\n\r\n\x05\x06\0\x02N\x03\x12\x04\xf8\x03=K\
    \n\x0f\n\x05\x06\0\x02N\x04\x12\x06\xf9\x03\x04\xff\x03\x08\n\x13\n\t\
    \x06\0\x02N\x04\xb0\xca\xbc\"\x12\x06\xf9\x03\x04\xff\x03\x08\n\x0e\n\
    \x04\x06\0\x02O\x12\x06\x83\x04\x02\x8b\x04\x03\n\r\n\x05\x06\0\x02O\x01\
    \x12\x04\x83\x04\x06\x16\n\r\n\x05\x06\0\x02O\x02\x12\x04\x83\x04\x18$\n\
    \r\n\x05\x06\0\x02O\x03\x12\x04\x83\x04/<\n\x0f\n\x05\x06\0\x02O\x04\x12\
    \x06\x84\x04\x04\x8a\x04\x06\n\x13\n\t\x06\0\x02O\x04\xb0\xca\xbc\"\x12\
    \x06\x84\x04\x04\x8a\x04\x06\n\x0e\n\x04\x06\0\x02P\x12\x06\x8c\x04\x02\
    \x94\x04\x03\n\r\n\x05\x06\0\x02P\x01\x12\x04\x8c\x04\x06\x1c\n\r\n\x05\
    \x06\0\x02P\x02\x12\x04\x8c\x04\x1e*\n\r\n\x05\x06\0\x02P\x03\x12\x04\
    \x8c\x045B\n\x0f\n\x05\x06\0\x02P\x04\x12\x06\x8d\x04\x04\x93\x04\x06\n\
    \x13\n\t\x06\0\x02P\x04\xb0\xca\xbc\"\x12\x06\x8d\x04\x04\x93\x04\x06\n\
    \x83\x01\n\x04\x06\0\x02Q\x12\x06\x97\x04\x02\x9f\x04\x03\x1asWarning:\
    \x20do\x20not\x20invoke\x20this\x20interface\x20provided\x20by\x20others\
    .\nPlease\x20use\x20GetTransactionSign2\x20instead\x20of\x20this\x20func\
    tion.\n\n\r\n\x05\x06\0\x02Q\x01\x12\x04\x97\x04\x06\x18\n\r\n\x05\x06\0\
    \x02Q\x02\x12\x04\x97\x04\x1a)\n\r\n\x05\x06\0\x02Q\x03\x12\x04\x97\x044\
    ?\n\x0f\n\x05\x06\0\x02Q\x04\x12\x06\x98\x04\x04\x9e\x04\x06\n\x13\n\t\
    \x06\0\x02Q\x04\xb0\xca\xbc\"\x12\x06\x98\x04\x04\x9e\x04\x06\n{\n\x04\
    \x06\0\x02R\x12\x06\xa2\x04\x02\xa3\x04\x03\x1akWarning:\x20do\x20not\
    \x20invoke\x20this\x20interface\x20provided\x20by\x20others.\nUse\x20thi\
    s\x20function\x20instead\x20of\x20GetTransactionSign.\n\n\r\n\x05\x06\0\
    \x02R\x01\x12\x04\xa2\x04\x06\x19\n\r\n\x05\x06\0\x02R\x02\x12\x04\xa2\
    \x04\x1b*\n\r\n\x05\x06\0\x02R\x03\x12\x04\xa2\x045I\nJ\n\x04\x06\0\x02S\
    \x12\x06\xa5\x04\x02\xad\x04\x03\x1a:Warning:\x20do\x20not\x20invoke\x20\
    this\x20interface\x20provided\x20by\x20others.\n\n\r\n\x05\x06\0\x02S\
    \x01\x12\x04\xa5\x04\x06\x13\n\r\n\x05\x06\0\x02S\x02\x12\x04\xa5\x04\
    \x15!\n\r\n\x05\x06\0\x02S\x03\x12\x04\xa5\x04,8\n\x0f\n\x05\x06\0\x02S\
    \x04\x12\x06\xa6\x04\x04\xac\x04\x06\n\x13\n\t\x06\0\x02S\x04\xb0\xca\
    \xbc\"\x12\x06\xa6\x04\x04\xac\x04\x06\nJ\n\x04\x06\0\x02T\x12\x06\xaf\
    \x04\x02\xb0\x04\x03\x1a:Warning:\x20do\x20not\x20invoke\x20this\x20inte\
    rface\x20provided\x20by\x20others.\n\n\r\n\x05\x06\0\x02T\x01\x12\x04\
    \xaf\x04\x06\x17\n\r\n\x05\x06\0\x02T\x02\x12\x04\xaf\x04\x191\n\r\n\x05\
    \x06\0\x02T\x03\x12\x04\xaf\x04<P\nJ\n\x04\x06\0\x02U\x12\x06\xb2\x04\
    \x02\xb3\x04\x03\x1a:Warning:\x20do\x20not\x20invoke\x20this\x20interfac\
    e\x20provided\x20by\x20others.\n\n\r\n\x05\x06\0\x02U\x01\x12\x04\xb2\
    \x04\x06\x20\n\r\n\x05\x06\0\x02U\x02\x12\x04\xb2\x04\"C\n\r\n\x05\x06\0\
    \x02U\x03\x12\x04\xb2\x04Nb\nJ\n\x04\x06\0\x02V\x12\x06\xb5\x04\x02\xbd\
    \x04\x03\x1a:Warning:\x20do\x20not\x20invoke\x20this\x20interface\x20pro\
    vided\x20by\x20others.\n\n\r\n\x05\x06\0\x02V\x01\x12\x04\xb5\x04\x06\
    \x12\n\r\n\x05\x06\0\x02V\x02\x12\x04\xb5\x04\x14'\n\r\n\x05\x06\0\x02V\
    \x03\x12\x04\xb5\x042F\n\x0f\n\x05\x06\0\x02V\x04\x12\x06\xb6\x04\x04\
    \xbc\x04\x06\n\x13\n\t\x06\0\x02V\x04\xb0\xca\xbc\"\x12\x06\xb6\x04\x04\
    \xbc\x04\x06\nJ\n\x04\x06\0\x02W\x12\x06\xbf\x04\x02\xc7\x04\x03\x1a:War\
    ning:\x20do\x20not\x20invoke\x20this\x20interface\x20provided\x20by\x20o\
    thers.\n\n\r\n\x05\x06\0\x02W\x01\x12\x04\xbf\x04\x06\x1b\n\r\n\x05\x06\
    \0\x02W\x02\x12\x04\xbf\x04\x1d9\n\r\n\x05\x06\0\x02W\x03\x12\x04\xbf\
    \x04DX\n\x0f\n\x05\x06\0\x02W\x04\x12\x06\xc0\x04\x04\xc6\x04\x06\n\x13\
    \n\t\x06\0\x02W\x04\xb0\xca\xbc\"\x12\x06\xc0\x04\x04\xc6\x04\x06\nJ\n\
    \x04\x06\0\x02X\x12\x06\xc9\x04\x02\xd2\x04\x03\x1a:Warning:\x20do\x20no\
    t\x20invoke\x20this\x20interface\x20provided\x20by\x20others.\n\n\r\n\
    \x05\x06\0\x02X\x01\x12\x04\xc9\x04\x06\x15\n\r\n\x05\x06\0\x02X\x02\x12\
    \x04\xc9\x04\x17#\n\r\n\x05\x06\0\x02X\x03\x12\x04\xc9\x04.E\n\x0f\n\x05\
    \x06\0\x02X\x04\x12\x06\xcb\x04\x04\xd1\x04\x06\n\x13\n\t\x06\0\x02X\x04\
    \xb0\xca\xbc\"\x12\x06\xcb\x04\x04\xd1\x04\x06\n\x0e\n\x04\x06\0\x02Y\
    \x12\x06\xd4\x04\x02\xdc\x04\x03\n\r\n\x05\x06\0\x02Y\x01\x12\x04\xd4\
    \x04\x06\x1c\n\r\n\x05\x06\0\x02Y\x02\x12\x04\xd4\x04\x1e*\n\r\n\x05\x06\
    \0\x02Y\x03\x12\x04\xd4\x045D\n\x0f\n\x05\x06\0\x02Y\x04\x12\x06\xd5\x04\
    \x04\xdb\x04\x06\n\x13\n\t\x06\0\x02Y\x04\xb0\xca\xbc\"\x12\x06\xd5\x04\
    \x04\xdb\x04\x06\n\x0e\n\x04\x06\0\x02Z\x12\x06\xde\x04\x02\xe6\x04\x03\
    \n\r\n\x05\x06\0\x02Z\x01\x12\x04\xde\x04\x06\x1d\n\r\n\x05\x06\0\x02Z\
    \x02\x12\x04\xde\x04\x1f>\n\r\n\x05\x06\0\x02Z\x03\x12\x04\xde\x04I]\n\
    \x0f\n\x05\x06\0\x02Z\x04\x12\x06\xdf\x04\x04\xe5\x04\x06\n\x13\n\t\x06\
    \0\x02Z\x04\xb0\xca\xbc\"\x12\x06\xdf\x04\x04\xe5\x04\x06\n\x0e\n\x04\
    \x06\0\x02[\x12\x06\xe9\x04\x02\xeb\x04\x03\n\r\n\x05\x06\0\x02[\x01\x12\
    \x04\xe9\x04\x06\r\n\r\n\x05\x06\0\x02[\x02\x12\x04\xe9\x04\x0f\x1e\n\r\
    \n\x05\x06\0\x02[\x03\x12\x04\xe9\x04)=\n\x0e\n\x04\x06\0\x02\\\x12\x06\
    \xed\x04\x02\xef\x04\x03\n\r\n\x05\x06\0\x02\\\x01\x12\x04\xed\x04\x06\
    \x1e\n\r\n\x05\x06\0\x02\\\x02\x12\x04\xed\x04\x20+\n\r\n\x05\x06\0\x02\
    \\\x03\x12\x04\xed\x046K\n\x0e\n\x04\x06\0\x02]\x12\x06\xf1\x04\x02\xf3\
    \x04\x03\n\r\n\x05\x06\0\x02]\x01\x12\x04\xf1\x04\x06\x20\n\r\n\x05\x06\
    \0\x02]\x02\x12\x04\xf1\x04!,\n\r\n\x05\x06\0\x02]\x03\x12\x04\xf1\x047N\
    \n\x0e\n\x04\x06\0\x02^\x12\x06\xf5\x04\x02\xf6\x04\x03\n\r\n\x05\x06\0\
    \x02^\x01\x12\x04\xf5\x04\x06\x11\n\r\n\x05\x06\0\x02^\x02\x12\x04\xf5\
    \x04\x13\x1f\n\r\n\x05\x06\0\x02^\x03\x12\x04\xf5\x04*2\n\x0c\n\x02\x06\
    \x01\x12\x06\xfa\x04\0\xfb\x05\x01\n\x0b\n\x03\x06\x01\x01\x12\x04\xfa\
    \x04\x08\x16\n\x0e\n\x04\x06\x01\x02\0\x12\x06\xfc\x04\x02\x84\x05\x03\n\
    \r\n\x05\x06\x01\x02\0\x01\x12\x04\xfc\x04\x06\x10\n\r\n\x05\x06\x01\x02\
    \0\x02\x12\x04\xfc\x04\x12\x19\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\xfc\
    \x04$+\n\x0f\n\x05\x06\x01\x02\0\x04\x12\x06\xfd\x04\x04\x83\x05\x06\n\
    \x13\n\t\x06\x01\x02\0\x04\xb0\xca\xbc\"\x12\x06\xfd\x04\x04\x83\x05\x06\
    \n\x0e\n\x04\x06\x01\x02\x01\x12\x06\x85\x05\x02\x8d\x05\x03\n\r\n\x05\
    \x06\x01\x02\x01\x01\x12\x04\x85\x05\x06\x14\n\r\n\x05\x06\x01\x02\x01\
    \x02\x12\x04\x85\x05\x16\x1d\n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\x85\
    \x05(/\n\x0f\n\x05\x06\x01\x02\x01\x04\x12\x06\x86\x05\x04\x8c\x05\x06\n\
    \x13\n\t\x06\x01\x02\x01\x04\xb0\xca\xbc\"\x12\x06\x86\x05\x04\x8c\x05\
    \x06\n\x0e\n\x04\x06\x01\x02\x02\x12\x06\x8f\x05\x02\x97\x05\x03\n\r\n\
    \x05\x06\x01\x02\x02\x01\x12\x04\x8f\x05\x06\x13\n\r\n\x05\x06\x01\x02\
    \x02\x02\x12\x04\x8f\x05\x15!\n\r\n\x05\x06\x01\x02\x02\x03\x12\x04\x8f\
    \x05,7\n\x0f\n\x05\x06\x01\x02\x02\x04\x12\x06\x90\x05\x04\x96\x05\x06\n\
    \x13\n\t\x06\x01\x02\x02\x04\xb0\xca\xbc\"\x12\x06\x90\x05\x04\x96\x05\
    \x06\n\x0e\n\x04\x06\x01\x02\x03\x12\x06\x98\x05\x02\xa0\x05\x03\n\r\n\
    \x05\x06\x01\x02\x03\x01\x12\x04\x98\x05\x06\x17\n\r\n\x05\x06\x01\x02\
    \x03\x02\x12\x04\x98\x05\x19%\n\r\n\x05\x06\x01\x02\x03\x03\x12\x04\x98\
    \x050>\n\x0f\n\x05\x06\x01\x02\x03\x04\x12\x06\x99\x05\x04\x9f\x05\x06\n\
    \x13\n\t\x06\x01\x02\x03\x04\xb0\xca\xbc\"\x12\x06\x99\x05\x04\x9f\x05\
    \x06\n\x0e\n\x04\x06\x01\x02\x04\x12\x06\xa1\x05\x02\xa9\x05\x03\n\r\n\
    \x05\x06\x01\x02\x04\x01\x12\x04\xa1\x05\x06\x20\n\r\n\x05\x06\x01\x02\
    \x04\x02\x12\x04\xa1\x05\"2\n\r\n\x05\x06\x01\x02\x04\x03\x12\x04\xa1\
    \x05=K\n\x0f\n\x05\x06\x01\x02\x04\x04\x12\x06\xa2\x05\x04\xa8\x05\x08\n\
    \x13\n\t\x06\x01\x02\x04\x04\xb0\xca\xbc\"\x12\x06\xa2\x05\x04\xa8\x05\
    \x08\n\x0e\n\x04\x06\x01\x02\x05\x12\x06\xab\x05\x02\xac\x05\x03\n\r\n\
    \x05\x06\x01\x02\x05\x01\x12\x04\xab\x05\x06\x19\n\r\n\x05\x06\x01\x02\
    \x05\x02\x12\x04\xab\x05\x1b'\n\r\n\x05\x06\x01\x02\x05\x03\x12\x04\xab\
    \x052D\n\x0e\n\x04\x06\x01\x02\x06\x12\x06\xad\x05\x02\xae\x05\x03\n\r\n\
    \x05\x06\x01\x02\x06\x01\x12\x04\xad\x05\x06\x1d\n\r\n\x05\x06\x01\x02\
    \x06\x02\x12\x04\xad\x05\x1f+\n\r\n\x05\x06\x01\x02\x06\x03\x12\x04\xad\
    \x056D\n\x0e\n\x04\x06\x01\x02\x07\x12\x06\xaf\x05\x02\xb0\x05\x03\n\r\n\
    \x05\x06\x01\x02\x07\x01\x12\x04\xaf\x05\x06\x17\n\r\n\x05\x06\x01\x02\
    \x07\x02\x12\x04\xaf\x05\x19%\n\r\n\x05\x06\x01\x02\x07\x03\x12\x04\xaf\
    \x050B\nB\n\x04\x06\x01\x02\x08\x12\x06\xb3\x05\x02\xbb\x05\x03\x1a2Plea\
    se\x20use\x20GetNowBlock2\x20instead\x20of\x20this\x20function.\n\n\r\n\
    \x05\x06\x01\x02\x08\x01\x12\x04\xb3\x05\x06\x11\n\r\n\x05\x06\x01\x02\
    \x08\x02\x12\x04\xb3\x05\x13\x1f\n\r\n\x05\x06\x01\x02\x08\x03\x12\x04\
    \xb3\x05*/\n\x0f\n\x05\x06\x01\x02\x08\x04\x12\x06\xb4\x05\x04\xba\x05\
    \x06\n\x13\n\t\x06\x01\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xb4\x05\x04\xba\
    \x05\x06\n:\n\x04\x06\x01\x02\t\x12\x06\xbd\x05\x02\xbe\x05\x03\x1a*Use\
    \x20this\x20function\x20instead\x20of\x20GetNowBlock.\n\n\r\n\x05\x06\
    \x01\x02\t\x01\x12\x04\xbd\x05\x06\x12\n\r\n\x05\x06\x01\x02\t\x02\x12\
    \x04\xbd\x05\x14\x20\n\r\n\x05\x06\x01\x02\t\x03\x12\x04\xbd\x05+9\nD\n\
    \x04\x06\x01\x02\n\x12\x06\xc0\x05\x02\xc8\x05\x03\x1a4Please\x20use\x20\
    GetBlockByNum2\x20instead\x20of\x20this\x20function.\n\n\r\n\x05\x06\x01\
    \x02\n\x01\x12\x04\xc0\x05\x06\x13\n\r\n\x05\x06\x01\x02\n\x02\x12\x04\
    \xc0\x05\x15\"\n\r\n\x05\x06\x01\x02\n\x03\x12\x04\xc0\x05-2\n\x0f\n\x05\
    \x06\x01\x02\n\x04\x12\x06\xc1\x05\x04\xc7\x05\x06\n\x13\n\t\x06\x01\x02\
    \n\x04\xb0\xca\xbc\"\x12\x06\xc1\x05\x04\xc7\x05\x06\n<\n\x04\x06\x01\
    \x02\x0b\x12\x06\xca\x05\x02\xcb\x05\x03\x1a,Use\x20this\x20function\x20\
    instead\x20of\x20GetBlockByNum.\n\n\r\n\x05\x06\x01\x02\x0b\x01\x12\x04\
    \xca\x05\x06\x14\n\r\n\x05\x06\x01\x02\x0b\x02\x12\x04\xca\x05\x16#\n\r\
    \n\x05\x06\x01\x02\x0b\x03\x12\x04\xca\x05.<\n\x0e\n\x04\x06\x01\x02\x0c\
    \x12\x06\xcd\x05\x02\xce\x05\x03\n\r\n\x05\x06\x01\x02\x0c\x01\x12\x04\
    \xcd\x05\x06#\n\r\n\x05\x06\x01\x02\x0c\x02\x12\x04\xcd\x05%2\n\r\n\x05\
    \x06\x01\x02\x0c\x03\x12\x04\xcd\x05=J\n\x0e\n\x04\x06\x01\x02\r\x12\x06\
    \xd0\x05\x02\xd1\x05\x03\n\r\n\x05\x06\x01\x02\r\x01\x12\x04\xd0\x05\x06\
    \x1a\n\r\n\x05\x06\x01\x02\r\x02\x12\x04\xd0\x05\x1c4\n\r\n\x05\x06\x01\
    \x02\r\x03\x12\x04\xd0\x05?T\n\x0e\n\x04\x06\x01\x02\x0e\x12\x06\xd3\x05\
    \x02\xd4\x05\x03\n\r\n\x05\x06\x01\x02\x0e\x01\x12\x04\xd3\x05\x06&\n\r\
    \n\x05\x06\x01\x02\x0e\x02\x12\x04\xd3\x05(4\n\r\n\x05\x06\x01\x02\x0e\
    \x03\x12\x04\xd3\x05?\\\n\x0e\n\x04\x06\x01\x02\x0f\x12\x06\xd6\x05\x02\
    \xd7\x05\x03\n\r\n\x05\x06\x01\x02\x0f\x01\x12\x04\xd6\x05\x06\x15\n\r\n\
    \x05\x06\x01\x02\x0f\x02\x12\x04\xd6\x05\x17#\n\r\n\x05\x06\x01\x02\x0f\
    \x03\x12\x04\xd6\x05.6\n\x0e\n\x04\x06\x01\x02\x10\x12\x06\xd9\x05\x02\
    \xda\x05\x03\n\r\n\x05\x06\x01\x02\x10\x01\x12\x04\xd9\x05\x06\x13\n\r\n\
    \x05\x06\x01\x02\x10\x02\x12\x04\xd9\x05\x15!\n\r\n\x05\x06\x01\x02\x10\
    \x03\x12\x04\xd9\x05,8\n\x0e\n\x04\x06\x01\x02\x11\x12\x06\xdd\x05\x02\
    \xe5\x05\x03\n\r\n\x05\x06\x01\x02\x11\x01\x12\x04\xdd\x05\x06\x18\n\r\n\
    \x05\x06\x01\x02\x11\x02\x12\x04\xdd\x05\x1a&\n\r\n\x05\x06\x01\x02\x11\
    \x03\x12\x04\xdd\x051<\n\x0f\n\x05\x06\x01\x02\x11\x04\x12\x06\xde\x05\
    \x04\xe4\x05\x06\n\x13\n\t\x06\x01\x02\x11\x04\xb0\xca\xbc\"\x12\x06\xde\
    \x05\x04\xe4\x05\x06\n\x0e\n\x04\x06\x01\x02\x12\x12\x06\xe7\x05\x02\xef\
    \x05\x03\n\r\n\x05\x06\x01\x02\x12\x01\x12\x04\xe7\x05\x06\x1c\n\r\n\x05\
    \x06\x01\x02\x12\x02\x12\x04\xe7\x05\x1e*\n\r\n\x05\x06\x01\x02\x12\x03\
    \x12\x04\xe7\x055D\n\x0f\n\x05\x06\x01\x02\x12\x04\x12\x06\xe8\x05\x04\
    \xee\x05\x06\n\x13\n\t\x06\x01\x02\x12\x04\xb0\xca\xbc\"\x12\x06\xe8\x05\
    \x04\xee\x05\x06\nJ\n\x04\x06\x01\x02\x13\x12\x06\xf2\x05\x02\xfa\x05\
    \x03\x1a:Warning:\x20do\x20not\x20invoke\x20this\x20interface\x20provide\
    d\x20by\x20others.\n\n\r\n\x05\x06\x01\x02\x13\x01\x12\x04\xf2\x05\x06\
    \x15\n\r\n\x05\x06\x01\x02\x13\x02\x12\x04\xf2\x05\x17#\n\r\n\x05\x06\
    \x01\x02\x13\x03\x12\x04\xf2\x05.E\n\x0f\n\x05\x06\x01\x02\x13\x04\x12\
    \x06\xf3\x05\x04\xf9\x05\x06\n\x13\n\t\x06\x01\x02\x13\x04\xb0\xca\xbc\"\
    \x12\x06\xf3\x05\x04\xf9\x05\x06\n\x0c\n\x02\x06\x02\x12\x06\xfd\x05\0\
    \x98\x06\x01\n\x0b\n\x03\x06\x02\x01\x12\x04\xfd\x05\x08\x17\nN\n\x04\
    \x06\x02\x02\0\x12\x06\xff\x05\x02\x87\x06\x03\x1a>Please\x20use\x20GetT\
    ransactionsFromThis2\x20instead\x20of\x20this\x20function.\n\n\r\n\x05\
    \x06\x02\x02\0\x01\x12\x04\xff\x05\x06\x1d\n\r\n\x05\x06\x02\x02\0\x02\
    \x12\x04\xff\x05\x1f/\n\r\n\x05\x06\x02\x02\0\x03\x12\x04\xff\x05:I\n\
    \x0f\n\x05\x06\x02\x02\0\x04\x12\x06\x80\x06\x04\x86\x06\x06\n\x13\n\t\
    \x06\x02\x02\0\x04\xb0\xca\xbc\"\x12\x06\x80\x06\x04\x86\x06\x06\nF\n\
    \x04\x06\x02\x02\x01\x12\x06\x89\x06\x02\x8a\x06\x03\x1a6Use\x20this\x20\
    function\x20instead\x20of\x20GetTransactionsFromThis.\n\n\r\n\x05\x06\
    \x02\x02\x01\x01\x12\x04\x89\x06\x06\x1e\n\r\n\x05\x06\x02\x02\x01\x02\
    \x12\x04\x89\x06\x200\n\r\n\x05\x06\x02\x02\x01\x03\x12\x04\x89\x06;S\nL\
    \n\x04\x06\x02\x02\x02\x12\x06\x8c\x06\x02\x94\x06\x03\x1a<Please\x20use\
    \x20GetTransactionsToThis2\x20instead\x20of\x20this\x20function.\n\n\r\n\
    \x05\x06\x02\x02\x02\x01\x12\x04\x8c\x06\x06\x1b\n\r\n\x05\x06\x02\x02\
    \x02\x02\x12\x04\x8c\x06\x1d-\n\r\n\x05\x06\x02\x02\x02\x03\x12\x04\x8c\
    \x068G\n\x0f\n\x05\x06\x02\x02\x02\x04\x12\x06\x8d\x06\x04\x93\x06\x06\n\
    \x13\n\t\x06\x02\x02\x02\x04\xb0\xca\xbc\"\x12\x06\x8d\x06\x04\x93\x06\
    \x06\nD\n\x04\x06\x02\x02\x03\x12\x06\x96\x06\x02\x97\x06\x03\x1a4Use\
    \x20this\x20function\x20instead\x20of\x20GetTransactionsToThis.\n\n\r\n\
    \x05\x06\x02\x02\x03\x01\x12\x04\x96\x06\x06\x1c\n\r\n\x05\x06\x02\x02\
    \x03\x02\x12\x04\x96\x06\x1e.\n\r\n\x05\x06\x02\x02\x03\x03\x12\x04\x96\
    \x069Q\n$\n\x02\x06\x03\x12\x06\x9b\x06\0\xa9\x06\x01\x1a\x16\x20the\x20\
    api\x20of\x20tron's\x20db\n\n\x0b\n\x03\x06\x03\x01\x12\x04\x9b\x06\x08\
    \x10\n\x1b\n\x04\x06\x03\x02\0\x12\x06\x9d\x06\x02\x9f\x06\x03\x1a\x0b\
    \x20for\x20tapos\n\n\r\n\x05\x06\x03\x02\0\x01\x12\x04\x9d\x06\x06\x17\n\
    \r\n\x05\x06\x03\x02\0\x02\x12\x04\x9d\x06\x19%\n\r\n\x05\x06\x03\x02\0\
    \x03\x12\x04\x9d\x060>\n\x0e\n\x04\x06\x03\x02\x01\x12\x06\xa0\x06\x02\
    \xa2\x06\x03\n\r\n\x05\x06\x03\x02\x01\x01\x12\x04\xa0\x06\x06\x1a\n\r\n\
    \x05\x06\x03\x02\x01\x02\x12\x04\xa0\x06\x1c(\n\r\n\x05\x06\x03\x02\x01\
    \x03\x12\x04\xa0\x063D\n\x0e\n\x04\x06\x03\x02\x02\x12\x06\xa3\x06\x02\
    \xa5\x06\x03\n\r\n\x05\x06\x03\x02\x02\x01\x12\x04\xa3\x06\x06\x11\n\r\n\
    \x05\x06\x03\x02\x02\x02\x12\x04\xa3\x06\x13\x1f\n\r\n\x05\x06\x03\x02\
    \x02\x03\x12\x04\xa3\x06*/\n\x0e\n\x04\x06\x03\x02\x03\x12\x06\xa6\x06\
    \x02\xa8\x06\x03\n\r\n\x05\x06\x03\x02\x03\x01\x12\x04\xa6\x06\x06\x13\n\
    \r\n\x05\x06\x03\x02\x03\x02\x12\x04\xa6\x06\x15\"\n\r\n\x05\x06\x03\x02\
    \x03\x03\x12\x04\xa6\x06-2\n\x0c\n\x02\x04\0\x12\x06\xab\x06\0\xbf\x06\
    \x01\n\x0b\n\x03\x04\0\x01\x12\x04\xab\x06\x08\x0e\n\x0e\n\x04\x04\0\x04\
    \0\x12\x06\xac\x06\x02\xba\x06\x03\n\r\n\x05\x04\0\x04\0\x01\x12\x04\xac\
    \x06\x07\x14\n\x0e\n\x06\x04\0\x04\0\x02\0\x12\x04\xad\x06\x04\x10\n\x0f\
    \n\x07\x04\0\x04\0\x02\0\x01\x12\x04\xad\x06\x04\x0b\n\x0f\n\x07\x04\0\
    \x04\0\x02\0\x02\x12\x04\xad\x06\x0e\x0f\n$\n\x06\x04\0\x04\0\x02\x01\
    \x12\x04\xae\x06\x04\x11\"\x14\x20error\x20in\x20signature\n\n\x0f\n\x07\
    \x04\0\x04\0\x02\x01\x01\x12\x04\xae\x06\x04\x0c\n\x0f\n\x07\x04\0\x04\0\
    \x02\x01\x02\x12\x04\xae\x06\x0f\x10\n\x0e\n\x06\x04\0\x04\0\x02\x02\x12\
    \x04\xaf\x06\x04\x20\n\x0f\n\x07\x04\0\x04\0\x02\x02\x01\x12\x04\xaf\x06\
    \x04\x1b\n\x0f\n\x07\x04\0\x04\0\x02\x02\x02\x12\x04\xaf\x06\x1e\x1f\n\
    \x0e\n\x06\x04\0\x04\0\x02\x03\x12\x04\xb0\x06\x04\x1b\n\x0f\n\x07\x04\0\
    \x04\0\x02\x03\x01\x12\x04\xb0\x06\x04\x16\n\x0f\n\x07\x04\0\x04\0\x02\
    \x03\x02\x12\x04\xb0\x06\x19\x1a\n\x0e\n\x06\x04\0\x04\0\x02\x04\x12\x04\
    \xb1\x06\x04\x17\n\x0f\n\x07\x04\0\x04\0\x02\x04\x01\x12\x04\xb1\x06\x04\
    \x12\n\x0f\n\x07\x04\0\x04\0\x02\x04\x02\x12\x04\xb1\x06\x15\x16\n\x0e\n\
    \x06\x04\0\x04\0\x02\x05\x12\x04\xb2\x06\x04\x1e\n\x0f\n\x07\x04\0\x04\0\
    \x02\x05\x01\x12\x04\xb2\x06\x04\x19\n\x0f\n\x07\x04\0\x04\0\x02\x05\x02\
    \x12\x04\xb2\x06\x1c\x1d\n\x0e\n\x06\x04\0\x04\0\x02\x06\x12\x04\xb3\x06\
    \x04\x14\n\x0f\n\x07\x04\0\x04\0\x02\x06\x01\x12\x04\xb3\x06\x04\x0f\n\
    \x0f\n\x07\x04\0\x04\0\x02\x06\x02\x12\x04\xb3\x06\x12\x13\n\x0e\n\x06\
    \x04\0\x04\0\x02\x07\x12\x04\xb4\x06\x04\"\n\x0f\n\x07\x04\0\x04\0\x02\
    \x07\x01\x12\x04\xb4\x06\x04\x1d\n\x0f\n\x07\x04\0\x04\0\x02\x07\x02\x12\
    \x04\xb4\x06\x20!\n\x0e\n\x06\x04\0\x04\0\x02\x08\x12\x04\xb5\x06\x04%\n\
    \x0f\n\x07\x04\0\x04\0\x02\x08\x01\x12\x04\xb5\x06\x04\x20\n\x0f\n\x07\
    \x04\0\x04\0\x02\x08\x02\x12\x04\xb5\x06#$\n\x0e\n\x06\x04\0\x04\0\x02\t\
    \x12\x04\xb6\x06\x04\x14\n\x0f\n\x07\x04\0\x04\0\x02\t\x01\x12\x04\xb6\
    \x06\x04\x0f\n\x0f\n\x07\x04\0\x04\0\x02\t\x02\x12\x04\xb6\x06\x12\x13\n\
    \x0e\n\x06\x04\0\x04\0\x02\n\x12\x04\xb7\x06\x04\x17\n\x0f\n\x07\x04\0\
    \x04\0\x02\n\x01\x12\x04\xb7\x06\x04\x11\n\x0f\n\x07\x04\0\x04\0\x02\n\
    \x02\x12\x04\xb7\x06\x14\x16\n\x0e\n\x06\x04\0\x04\0\x02\x0b\x12\x04\xb8\
    \x06\x04)\n\x0f\n\x07\x04\0\x04\0\x02\x0b\x01\x12\x04\xb8\x06\x04#\n\x0f\
    \n\x07\x04\0\x04\0\x02\x0b\x02\x12\x04\xb8\x06&(\n\x0e\n\x06\x04\0\x04\0\
    \x02\x0c\x12\x04\xb9\x06\x04\x15\n\x0f\n\x07\x04\0\x04\0\x02\x0c\x01\x12\
    \x04\xb9\x06\x04\x0f\n\x0f\n\x07\x04\0\x04\0\x02\x0c\x02\x12\x04\xb9\x06\
    \x12\x14\n\x0c\n\x04\x04\0\x02\0\x12\x04\xbc\x06\x02\x12\n\x0f\n\x05\x04\
    \0\x02\0\x04\x12\x06\xbc\x06\x02\xba\x06\x03\n\r\n\x05\x04\0\x02\0\x05\
    \x12\x04\xbc\x06\x02\x06\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xbc\x06\x07\r\
    \n\r\n\x05\x04\0\x02\0\x03\x12\x04\xbc\x06\x10\x11\n\x0c\n\x04\x04\0\x02\
    \x01\x12\x04\xbd\x06\x02\x19\n\x0f\n\x05\x04\0\x02\x01\x04\x12\x06\xbd\
    \x06\x02\xbc\x06\x12\n\r\n\x05\x04\0\x02\x01\x06\x12\x04\xbd\x06\x02\x0f\
    \n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xbd\x06\x10\x14\n\r\n\x05\x04\0\x02\
    \x01\x03\x12\x04\xbd\x06\x17\x18\n\x0c\n\x04\x04\0\x02\x02\x12\x04\xbe\
    \x06\x02\x14\n\x0f\n\x05\x04\0\x02\x02\x04\x12\x06\xbe\x06\x02\xbd\x06\
    \x19\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xbe\x06\x02\x07\n\r\n\x05\x04\0\
    \x02\x02\x01\x12\x04\xbe\x06\x08\x0f\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\
    \xbe\x06\x12\x13\n\x0c\n\x02\x04\x01\x12\x06\xc1\x06\0\xc4\x06\x01\n\x0b\
    \n\x03\x04\x01\x01\x12\x04\xc1\x06\x08\x16\n\x0c\n\x04\x04\x01\x02\0\x12\
    \x04\xc2\x06\x02\x16\n\x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xc2\x06\x02\
    \xc1\x06\x18\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xc2\x06\x02\x07\n\r\n\
    \x05\x04\x01\x02\0\x01\x12\x04\xc2\x06\x08\x11\n\r\n\x05\x04\x01\x02\0\
    \x03\x12\x04\xc2\x06\x14\x15\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\xc3\x06\
    \x02\x17\n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\xc3\x06\x02\xc2\x06\x16\
    \n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xc3\x06\x02\x07\n\r\n\x05\x04\x01\
    \x02\x01\x01\x12\x04\xc3\x06\x08\x12\n\r\n\x05\x04\x01\x02\x01\x03\x12\
    \x04\xc3\x06\x15\x16\n<\n\x02\x06\x04\x12\x06\xc7\x06\0\xc9\x06\x01\x1a.\
    \x20the\x20api\x20of\x20tron's\x20network\x20such\x20as\x20node\x20list.\
    \n\n\x0b\n\x03\x06\x04\x01\x12\x04\xc7\x06\x08\x0f\n\x0c\n\x02\x04\x02\
    \x12\x06\xcb\x06\0\xcd\x06\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\xcb\x06\
    \x08\x13\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xcc\x06\x02!\n\r\n\x05\x04\
    \x02\x02\0\x04\x12\x04\xcc\x06\x02\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\
    \xcc\x06\x0b\x12\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xcc\x06\x13\x1c\n\r\
    \n\x05\x04\x02\x02\0\x03\x12\x04\xcc\x06\x1f\x20\n\x0c\n\x02\x04\x03\x12\
    \x06\xce\x06\0\xd0\x06\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xce\x06\x08\
    \x14\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xcf\x06\x02\"\n\r\n\x05\x04\x03\
    \x02\0\x04\x12\x04\xcf\x06\x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xcf\
    \x06\x0b\x13\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xcf\x06\x14\x1d\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\xcf\x06\x20!\n\x0c\n\x02\x04\x04\x12\x06\
    \xd1\x06\0\xd3\x06\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xd1\x06\x08\x14\n\
    \x0c\n\x04\x04\x04\x02\0\x12\x04\xd2\x06\x02\"\n\r\n\x05\x04\x04\x02\0\
    \x04\x12\x04\xd2\x06\x02\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xd2\x06\
    \x0b\x13\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xd2\x06\x14\x1d\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\xd2\x06\x20!\n\x0c\n\x02\x04\x05\x12\x06\xd4\
    \x06\0\xd6\x06\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xd4\x06\x08\x16\n\x0c\
    \n\x04\x04\x05\x02\0\x12\x04\xd5\x06\x02-\n\r\n\x05\x04\x05\x02\0\x04\
    \x12\x04\xd5\x06\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xd5\x06\x0b\
    \x1d\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xd5\x06\x1e(\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\xd5\x06+,\n\x0c\n\x02\x04\x06\x12\x06\xd7\x06\0\xd9\
    \x06\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xd7\x06\x08\x11\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\xd8\x06\x02\x1b\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\
    \xd8\x06\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xd8\x06\x0b\x10\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xd8\x06\x11\x16\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\xd8\x06\x19\x1a\n\x0c\n\x02\x04\x07\x12\x06\xda\x06\0\xdc\
    \x06\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xda\x06\x08\x17\n\x0c\n\x04\x04\
    \x07\x02\0\x12\x04\xdb\x06\x02'\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xdb\
    \x06\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xdb\x06\x0b\x16\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\xdb\x06\x17\"\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xdb\x06%&\n\x0c\n\x02\x04\x08\x12\x06\xdd\x06\0\xe0\x06\x01\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\xdd\x06\x08\x20\n\x0c\n\x04\x04\x08\x02\0\x12\
    \x04\xde\x06\x02\x18\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xde\x06\x02\
    \xdd\x06\"\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xde\x06\x02\x07\n\r\n\x05\
    \x04\x08\x02\0\x01\x12\x04\xde\x06\x08\x13\n\r\n\x05\x04\x08\x02\0\x03\
    \x12\x04\xde\x06\x16\x17\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xdf\x06\x02\
    \x16\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xdf\x06\x02\xde\x06\x18\n\r\
    \n\x05\x04\x08\x02\x01\x05\x12\x04\xdf\x06\x02\x07\n\r\n\x05\x04\x08\x02\
    \x01\x01\x12\x04\xdf\x06\x08\x11\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\
    \xdf\x06\x14\x15\n\x0c\n\x02\x04\t\x12\x06\xe1\x06\0\xe3\x06\x01\n\x0b\n\
    \x03\x04\t\x01\x12\x04\xe1\x06\x08\x1d\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \xe2\x06\x023\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xe2\x06\x02\n\n\r\n\x05\
    \x04\t\x02\0\x06\x12\x04\xe2\x06\x0b\x1c\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xe2\x06\x1d.\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xe2\x0612\n\x20\n\
    \x02\x04\n\x12\x06\xe6\x06\0\xe8\x06\x01\x1a\x12\x20Gossip\x20node\x20li\
    st\n\n\x0b\n\x03\x04\n\x01\x12\x04\xe6\x06\x08\x10\n\x0c\n\x04\x04\n\x02\
    \0\x12\x04\xe7\x06\x02\x1a\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xe7\x06\x02\
    \n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xe7\x06\x0b\x0f\n\r\n\x05\x04\n\x02\
    \0\x01\x12\x04\xe7\x06\x10\x15\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xe7\x06\
    \x18\x19\n\x1b\n\x02\x04\x0b\x12\x06\xeb\x06\0\xed\x06\x01\x1a\r\x20Goss\
    ip\x20node\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xeb\x06\x08\x0c\n\x0c\n\x04\
    \x04\x0b\x02\0\x12\x04\xec\x06\x02\x16\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\
    \x06\xec\x06\x02\xeb\x06\x0e\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xec\x06\
    \x02\t\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xec\x06\n\x11\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\xec\x06\x14\x15\n#\n\x02\x04\x0c\x12\x06\xf0\x06\
    \0\xf3\x06\x01\x1a\x15\x20Gossip\x20node\x20address\n\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\xf0\x06\x08\x0f\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xf1\
    \x06\x02\x11\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xf1\x06\x02\xf0\x06\
    \x11\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xf1\x06\x02\x07\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\xf1\x06\x08\x0c\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\xf1\x06\x0f\x10\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xf2\x06\x02\x11\
    \n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\xf2\x06\x02\xf1\x06\x11\n\r\n\
    \x05\x04\x0c\x02\x01\x05\x12\x04\xf2\x06\x02\x07\n\r\n\x05\x04\x0c\x02\
    \x01\x01\x12\x04\xf2\x06\x08\x0c\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \xf2\x06\x0f\x10\n\x0c\n\x02\x04\r\x12\x06\xf5\x06\0\xf6\x06\x01\n\x0b\n\
    \x03\x04\r\x01\x12\x04\xf5\x06\x08\x14\n\x0c\n\x02\x04\x0e\x12\x06\xf7\
    \x06\0\xf9\x06\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xf7\x06\x08\x15\n\x0c\
    \n\x04\x04\x0e\x02\0\x12\x04\xf8\x06\x02\x10\n\x0f\n\x05\x04\x0e\x02\0\
    \x04\x12\x06\xf8\x06\x02\xf7\x06\x17\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\
    \xf8\x06\x02\x07\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xf8\x06\x08\x0b\n\r\
    \n\x05\x04\x0e\x02\0\x03\x12\x04\xf8\x06\x0e\x0f\n\x0c\n\x02\x04\x0f\x12\
    \x06\xfa\x06\0\xfc\x06\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xfa\x06\x08\
    \x14\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xfb\x06\x02\x12\n\x0f\n\x05\x04\
    \x0f\x02\0\x04\x12\x06\xfb\x06\x02\xfa\x06\x16\n\r\n\x05\x04\x0f\x02\0\
    \x05\x12\x04\xfb\x06\x02\x07\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xfb\x06\
    \x08\r\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xfb\x06\x10\x11\n\x0c\n\x02\
    \x04\x10\x12\x06\xfd\x06\0\x80\x07\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \xfd\x06\x08\x13\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xfe\x06\x02\x20\n\x0f\
    \n\x05\x04\x10\x02\0\x04\x12\x06\xfe\x06\x02\xfd\x06\x15\n\r\n\x05\x04\
    \x10\x02\0\x05\x12\x04\xfe\x06\x02\x07\n\r\n\x05\x04\x10\x02\0\x01\x12\
    \x04\xfe\x06\x08\x1b\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xfe\x06\x1e\x1f\
    \n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xff\x06\x02\x1e\n\x0f\n\x05\x04\x10\
    \x02\x01\x04\x12\x06\xff\x06\x02\xfe\x06\x20\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\xff\x06\x02\x07\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xff\
    \x06\x08\x19\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xff\x06\x1c\x1d\n\x0c\
    \n\x02\x04\x11\x12\x06\x81\x07\0\x84\x07\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\x81\x07\x08\x12\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x82\x07\x02\x15\n\
    \x0f\n\x05\x04\x11\x02\0\x04\x12\x06\x82\x07\x02\x81\x07\x14\n\r\n\x05\
    \x04\x11\x02\0\x05\x12\x04\x82\x07\x02\x07\n\r\n\x05\x04\x11\x02\0\x01\
    \x12\x04\x82\x07\x08\x10\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x82\x07\x13\
    \x14\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x83\x07\x02\x13\n\x0f\n\x05\x04\
    \x11\x02\x01\x04\x12\x06\x83\x07\x02\x82\x07\x15\n\r\n\x05\x04\x11\x02\
    \x01\x05\x12\x04\x83\x07\x02\x07\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \x83\x07\x08\x0e\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x83\x07\x11\x12\n\
    \x0c\n\x02\x04\x12\x12\x06\x85\x07\0\x88\x07\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\x85\x07\x08\x18\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x86\x07\x02\
    \x1a\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\x86\x07\x02\x85\x07\x1a\n\r\n\
    \x05\x04\x12\x02\0\x05\x12\x04\x86\x07\x02\x07\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\x86\x07\x08\x15\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x86\x07\
    \x18\x19\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\x87\x07\x02\x15\n\x0f\n\x05\
    \x04\x12\x02\x01\x04\x12\x06\x87\x07\x02\x86\x07\x1a\n\r\n\x05\x04\x12\
    \x02\x01\x05\x12\x04\x87\x07\x02\x07\n\r\n\x05\x04\x12\x02\x01\x01\x12\
    \x04\x87\x07\x08\x10\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x87\x07\x13\
    \x14\n\x0c\n\x02\x04\x13\x12\x06\x89\x07\0\x8d\x07\x01\n\x0b\n\x03\x04\
    \x13\x01\x12\x04\x89\x07\x08\x18\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x8a\
    \x07\x02\x16\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\x8a\x07\x02\x89\x07\
    \x1a\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\x8a\x07\x02\t\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\x8a\x07\n\x11\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x8a\
    \x07\x14\x15\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x8b\x07\x02\x13\n\x0f\n\
    \x05\x04\x13\x02\x01\x04\x12\x06\x8b\x07\x02\x8a\x07\x16\n\r\n\x05\x04\
    \x13\x02\x01\x05\x12\x04\x8b\x07\x02\x07\n\r\n\x05\x04\x13\x02\x01\x01\
    \x12\x04\x8b\x07\x08\x0e\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x8b\x07\
    \x11\x12\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x8c\x07\x02\x12\n\x0f\n\x05\
    \x04\x13\x02\x02\x04\x12\x06\x8c\x07\x02\x8b\x07\x13\n\r\n\x05\x04\x13\
    \x02\x02\x05\x12\x04\x8c\x07\x02\x07\n\r\n\x05\x04\x13\x02\x02\x01\x12\
    \x04\x8c\x07\x08\r\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x8c\x07\x10\x11\
    \n\x0c\n\x02\x04\x14\x12\x06\x8e\x07\0\x92\x07\x01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\x8e\x07\x08\x1c\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x8f\x07\
    \x02\x1e\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\x8f\x07\x02\x8e\x07\x1e\n\
    \r\n\x05\x04\x14\x02\0\x06\x12\x04\x8f\x07\x02\r\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\x8f\x07\x0e\x19\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x8f\x07\
    \x1c\x1d\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\x90\x07\x02\x13\n\x0f\n\x05\
    \x04\x14\x02\x01\x04\x12\x06\x90\x07\x02\x8f\x07\x1e\n\r\n\x05\x04\x14\
    \x02\x01\x05\x12\x04\x90\x07\x02\x07\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\x90\x07\x08\x0e\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x90\x07\x11\
    \x12\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\x91\x07\x02\x12\n\x0f\n\x05\x04\
    \x14\x02\x02\x04\x12\x06\x91\x07\x02\x90\x07\x13\n\r\n\x05\x04\x14\x02\
    \x02\x05\x12\x04\x91\x07\x02\x07\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\
    \x91\x07\x08\r\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x91\x07\x10\x11\n\
    \x19\n\x02\x04\x15\x12\x06\x94\x07\0\x9d\x07\x01\x1a\x0bdeprecated\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\x94\x07\x08\x19\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\x95\x07\x02\x18\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\x95\x07\
    \x02\x94\x07\x1b\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x95\x07\x02\x07\n\r\
    \n\x05\x04\x15\x02\0\x01\x12\x04\x95\x07\x08\x13\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\x95\x07\x16\x17\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x96\x07\
    \x02\x19\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\x96\x07\x02\x95\x07\x18\
    \n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x96\x07\x02\x07\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\x96\x07\x08\x14\n\r\n\x05\x04\x15\x02\x01\x03\x12\
    \x04\x96\x07\x17\x18\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\x97\x07\x02\x14\
    \n\x0f\n\x05\x04\x15\x02\x02\x04\x12\x06\x97\x07\x02\x96\x07\x19\n\r\n\
    \x05\x04\x15\x02\x02\x05\x12\x04\x97\x07\x02\x07\n\r\n\x05\x04\x15\x02\
    \x02\x01\x12\x04\x97\x07\x08\x0f\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \x97\x07\x12\x13\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\x98\x07\x02\x15\n\
    \x0f\n\x05\x04\x15\x02\x03\x04\x12\x06\x98\x07\x02\x97\x07\x14\n\r\n\x05\
    \x04\x15\x02\x03\x05\x12\x04\x98\x07\x02\x07\n\r\n\x05\x04\x15\x02\x03\
    \x01\x12\x04\x98\x07\x08\x10\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\x98\
    \x07\x13\x14\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\x99\x07\x02&\n\x0f\n\
    \x05\x04\x15\x02\x04\x04\x12\x06\x99\x07\x02\x98\x07\x15\n\r\n\x05\x04\
    \x15\x02\x04\x06\x12\x04\x99\x07\x02\x14\n\r\n\x05\x04\x15\x02\x04\x01\
    \x12\x04\x99\x07\x15!\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\x99\x07$%\n\
    \x0c\n\x04\x04\x15\x02\x05\x12\x04\x9a\x07\x02'\n\x0f\n\x05\x04\x15\x02\
    \x05\x04\x12\x06\x9a\x07\x02\x99\x07&\n\r\n\x05\x04\x15\x02\x05\x06\x12\
    \x04\x9a\x07\x02\x14\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\x9a\x07\x15\"\
    \n\r\n\x05\x04\x15\x02\x05\x03\x12\x04\x9a\x07%&\n\x0c\n\x04\x04\x15\x02\
    \x06\x12\x04\x9b\x07\x02\x1a\n\x0f\n\x05\x04\x15\x02\x06\x04\x12\x06\x9b\
    \x07\x02\x9a\x07'\n\r\n\x05\x04\x15\x02\x06\x05\x12\x04\x9b\x07\x02\x07\
    \n\r\n\x05\x04\x15\x02\x06\x01\x12\x04\x9b\x07\x08\x15\n\r\n\x05\x04\x15\
    \x02\x06\x03\x12\x04\x9b\x07\x18\x19\n\x0c\n\x04\x04\x15\x02\x07\x12\x04\
    \x9c\x07\x02\x1b\n\x0f\n\x05\x04\x15\x02\x07\x04\x12\x06\x9c\x07\x02\x9b\
    \x07\x1a\n\r\n\x05\x04\x15\x02\x07\x05\x12\x04\x9c\x07\x02\x07\n\r\n\x05\
    \x04\x15\x02\x07\x01\x12\x04\x9c\x07\x08\x16\n\r\n\x05\x04\x15\x02\x07\
    \x03\x12\x04\x9c\x07\x19\x1a\n\x0c\n\x02\x04\x16\x12\x06\x9e\x07\0\xaf\
    \x07\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x9e\x07\x08\x1e\n\x0c\n\x04\x04\
    \x16\x02\0\x12\x04\x9f\x07\x02\x18\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\
    \x9f\x07\x02\x9e\x07\x20\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x9f\x07\x02\
    \x07\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x9f\x07\x08\x13\n\r\n\x05\x04\
    \x16\x02\0\x03\x12\x04\x9f\x07\x16\x17\n\x0c\n\x04\x04\x16\x02\x01\x12\
    \x04\xa0\x07\x02\x19\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\xa0\x07\x02\
    \x9f\x07\x18\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xa0\x07\x02\x07\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\xa0\x07\x08\x14\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\xa0\x07\x17\x18\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xa1\
    \x07\x02\x14\n\x0f\n\x05\x04\x16\x02\x02\x04\x12\x06\xa1\x07\x02\xa0\x07\
    \x19\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xa1\x07\x02\x07\n\r\n\x05\x04\
    \x16\x02\x02\x01\x12\x04\xa1\x07\x08\x0f\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\xa1\x07\x12\x13\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\xa2\x07\x02\
    \x15\n\x0f\n\x05\x04\x16\x02\x03\x04\x12\x06\xa2\x07\x02\xa1\x07\x14\n\r\
    \n\x05\x04\x16\x02\x03\x05\x12\x04\xa2\x07\x02\x07\n\r\n\x05\x04\x16\x02\
    \x03\x01\x12\x04\xa2\x07\x08\x10\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\
    \xa2\x07\x13\x14\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\xa3\x07\x02&\n\x0f\
    \n\x05\x04\x16\x02\x04\x04\x12\x06\xa3\x07\x02\xa2\x07\x15\n\r\n\x05\x04\
    \x16\x02\x04\x06\x12\x04\xa3\x07\x02\x14\n\r\n\x05\x04\x16\x02\x04\x01\
    \x12\x04\xa3\x07\x15!\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\xa3\x07$%\n\
    \x0c\n\x04\x04\x16\x02\x05\x12\x04\xa4\x07\x02'\n\x0f\n\x05\x04\x16\x02\
    \x05\x04\x12\x06\xa4\x07\x02\xa3\x07&\n\r\n\x05\x04\x16\x02\x05\x06\x12\
    \x04\xa4\x07\x02\x14\n\r\n\x05\x04\x16\x02\x05\x01\x12\x04\xa4\x07\x15\"\
    \n\r\n\x05\x04\x16\x02\x05\x03\x12\x04\xa4\x07%&\n\x0c\n\x04\x04\x16\x02\
    \x06\x12\x04\xa5\x07\x02\x1a\n\x0f\n\x05\x04\x16\x02\x06\x04\x12\x06\xa5\
    \x07\x02\xa4\x07'\n\r\n\x05\x04\x16\x02\x06\x05\x12\x04\xa5\x07\x02\x07\
    \n\r\n\x05\x04\x16\x02\x06\x01\x12\x04\xa5\x07\x08\x15\n\r\n\x05\x04\x16\
    \x02\x06\x03\x12\x04\xa5\x07\x18\x19\n\x0c\n\x04\x04\x16\x02\x07\x12\x04\
    \xa6\x07\x02\x1b\n\x0f\n\x05\x04\x16\x02\x07\x04\x12\x06\xa6\x07\x02\xa5\
    \x07\x1a\n\r\n\x05\x04\x16\x02\x07\x05\x12\x04\xa6\x07\x02\x07\n\r\n\x05\
    \x04\x16\x02\x07\x01\x12\x04\xa6\x07\x08\x16\n\r\n\x05\x04\x16\x02\x07\
    \x03\x12\x04\xa6\x07\x19\x1a\n\x0c\n\x04\x04\x16\x02\x08\x12\x04\xa8\x07\
    \x02\x18\n\x0f\n\x05\x04\x16\x02\x08\x04\x12\x06\xa8\x07\x02\xa6\x07\x1b\
    \n\r\n\x05\x04\x16\x02\x08\x05\x12\x04\xa8\x07\x02\x07\n\r\n\x05\x04\x16\
    \x02\x08\x01\x12\x04\xa8\x07\x08\x12\n\r\n\x05\x04\x16\x02\x08\x03\x12\
    \x04\xa8\x07\x15\x17\n\x0c\n\x04\x04\x16\x02\t\x12\x04\xa9\x07\x02\x19\n\
    \x0f\n\x05\x04\x16\x02\t\x04\x12\x06\xa9\x07\x02\xa8\x07\x18\n\r\n\x05\
    \x04\x16\x02\t\x05\x12\x04\xa9\x07\x02\x07\n\r\n\x05\x04\x16\x02\t\x01\
    \x12\x04\xa9\x07\x08\x13\n\r\n\x05\x04\x16\x02\t\x03\x12\x04\xa9\x07\x16\
    \x18\n\x0c\n\x04\x04\x16\x02\n\x12\x04\xaa\x07\x02\x1e\n\x0f\n\x05\x04\
    \x16\x02\n\x04\x12\x06\xaa\x07\x02\xa9\x07\x19\n\r\n\x05\x04\x16\x02\n\
    \x05\x12\x04\xaa\x07\x02\x07\n\r\n\x05\x04\x16\x02\n\x01\x12\x04\xaa\x07\
    \x08\x18\n\r\n\x05\x04\x16\x02\n\x03\x12\x04\xaa\x07\x1b\x1d\n\x0c\n\x04\
    \x04\x16\x02\x0b\x12\x04\xab\x07\x02\x1f\n\x0f\n\x05\x04\x16\x02\x0b\x04\
    \x12\x06\xab\x07\x02\xaa\x07\x1e\n\r\n\x05\x04\x16\x02\x0b\x05\x12\x04\
    \xab\x07\x02\x07\n\r\n\x05\x04\x16\x02\x0b\x01\x12\x04\xab\x07\x08\x19\n\
    \r\n\x05\x04\x16\x02\x0b\x03\x12\x04\xab\x07\x1c\x1e\n\x0c\n\x04\x04\x16\
    \x02\x0c\x12\x04\xad\x07\x02\x19\n\x0f\n\x05\x04\x16\x02\x0c\x04\x12\x06\
    \xad\x07\x02\xab\x07\x1f\n\r\n\x05\x04\x16\x02\x0c\x05\x12\x04\xad\x07\
    \x02\x07\n\r\n\x05\x04\x16\x02\x0c\x01\x12\x04\xad\x07\x08\x13\n\r\n\x05\
    \x04\x16\x02\x0c\x03\x12\x04\xad\x07\x16\x18\n\x0c\n\x04\x04\x16\x02\r\
    \x12\x04\xae\x07\x02\x1a\n\x0f\n\x05\x04\x16\x02\r\x04\x12\x06\xae\x07\
    \x02\xad\x07\x19\n\r\n\x05\x04\x16\x02\r\x05\x12\x04\xae\x07\x02\x07\n\r\
    \n\x05\x04\x16\x02\r\x01\x12\x04\xae\x07\x08\x14\n\r\n\x05\x04\x16\x02\r\
    \x03\x12\x04\xae\x07\x17\x19\n\x0c\n\x02\x04\x17\x12\x06\xb1\x07\0\xb4\
    \x07\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xb1\x07\x08\x18\n\x0c\n\x04\x04\
    \x17\x02\0\x12\x04\xb2\x07\x02\x13\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\
    \xb2\x07\x02\xb1\x07\x1a\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xb2\x07\x02\
    \x07\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xb2\x07\x08\x0e\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xb2\x07\x11\x12\n\x0c\n\x04\x04\x17\x02\x01\x12\
    \x04\xb3\x07\x02\x12\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xb3\x07\x02\
    \xb2\x07\x13\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xb3\x07\x02\x07\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xb3\x07\x08\r\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\xb3\x07\x10\x11\n\x0c\n\x02\x04\x18\x12\x06\xb6\x07\0\xba\
    \x07\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xb6\x07\x08\x1b\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\xb7\x07\x02\x17\n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\
    \xb7\x07\x02\xb6\x07\x1d\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xb7\x07\x02\
    \x07\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb7\x07\x08\x12\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\xb7\x07\x15\x16\n\x0c\n\x04\x04\x18\x02\x01\x12\
    \x04\xb8\x07\x02\x16\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\xb8\x07\x02\
    \xb7\x07\x17\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xb8\x07\x02\x07\n\r\n\
    \x05\x04\x18\x02\x01\x01\x12\x04\xb8\x07\x08\x11\n\r\n\x05\x04\x18\x02\
    \x01\x03\x12\x04\xb8\x07\x14\x15\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xb9\
    \x07\x02\x13\n\x0f\n\x05\x04\x18\x02\x02\x04\x12\x06\xb9\x07\x02\xb8\x07\
    \x16\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xb9\x07\x02\x07\n\r\n\x05\x04\
    \x18\x02\x02\x01\x12\x04\xb9\x07\x08\x0e\n\r\n\x05\x04\x18\x02\x02\x03\
    \x12\x04\xb9\x07\x11\x12\n\x0c\n\x02\x04\x19\x12\x06\xbc\x07\0\xc1\x07\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xbc\x07\x08\x20\n\x0c\n\x04\x04\x19\
    \x02\0\x12\x04\xbd\x07\x02\x17\n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\xbd\
    \x07\x02\xbc\x07\"\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xbd\x07\x02\x07\n\
    \r\n\x05\x04\x19\x02\0\x01\x12\x04\xbd\x07\x08\x12\n\r\n\x05\x04\x19\x02\
    \0\x03\x12\x04\xbd\x07\x15\x16\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xbe\
    \x07\x02\x16\n\x0f\n\x05\x04\x19\x02\x01\x04\x12\x06\xbe\x07\x02\xbd\x07\
    \x17\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xbe\x07\x02\x07\n\r\n\x05\x04\
    \x19\x02\x01\x01\x12\x04\xbe\x07\x08\x11\n\r\n\x05\x04\x19\x02\x01\x03\
    \x12\x04\xbe\x07\x14\x15\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xbf\x07\x02\
    \x15\n\x0f\n\x05\x04\x19\x02\x02\x04\x12\x06\xbf\x07\x02\xbe\x07\x16\n\r\
    \n\x05\x04\x19\x02\x02\x05\x12\x04\xbf\x07\x02\x08\n\r\n\x05\x04\x19\x02\
    \x02\x01\x12\x04\xbf\x07\t\x10\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xbf\
    \x07\x13\x14\n\x0c\n\x04\x04\x19\x02\x03\x12\x04\xc0\x07\x02\x13\n\x0f\n\
    \x05\x04\x19\x02\x03\x04\x12\x06\xc0\x07\x02\xbf\x07\x15\n\r\n\x05\x04\
    \x19\x02\x03\x05\x12\x04\xc0\x07\x02\x07\n\r\n\x05\x04\x19\x02\x03\x01\
    \x12\x04\xc0\x07\x08\x0e\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xc0\x07\
    \x11\x12\n\x0c\n\x02\x04\x1a\x12\x06\xc3\x07\0\xc7\x07\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\xc3\x07\x08$\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xc4\
    \x07\x02\x17\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\xc4\x07\x02\xc3\x07&\
    \n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xc4\x07\x02\x07\n\r\n\x05\x04\x1a\
    \x02\0\x01\x12\x04\xc4\x07\x08\x12\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\
    \xc4\x07\x15\x16\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xc5\x07\x02\x16\n\
    \x0f\n\x05\x04\x1a\x02\x01\x04\x12\x06\xc5\x07\x02\xc4\x07\x17\n\r\n\x05\
    \x04\x1a\x02\x01\x05\x12\x04\xc5\x07\x02\x07\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\xc5\x07\x08\x11\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xc5\
    \x07\x14\x15\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xc6\x07\x02\x13\n\x0f\n\
    \x05\x04\x1a\x02\x02\x04\x12\x06\xc6\x07\x02\xc5\x07\x16\n\r\n\x05\x04\
    \x1a\x02\x02\x05\x12\x04\xc6\x07\x02\x07\n\r\n\x05\x04\x1a\x02\x02\x01\
    \x12\x04\xc6\x07\x08\x0e\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xc6\x07\
    \x11\x12\n\x0c\n\x02\x04\x1b\x12\x06\xc9\x07\0\xce\x07\x01\n\x0b\n\x03\
    \x04\x1b\x01\x12\x04\xc9\x07\x08)\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xca\
    \x07\x02\x17\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xca\x07\x02\xc9\x07+\
    \n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xca\x07\x02\x07\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xca\x07\x08\x12\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\
    \xca\x07\x15\x16\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xcb\x07\x02\x16\n\
    \x0f\n\x05\x04\x1b\x02\x01\x04\x12\x06\xcb\x07\x02\xca\x07\x17\n\r\n\x05\
    \x04\x1b\x02\x01\x05\x12\x04\xcb\x07\x02\x07\n\r\n\x05\x04\x1b\x02\x01\
    \x01\x12\x04\xcb\x07\x08\x11\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xcb\
    \x07\x14\x15\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xcc\x07\x02\x15\n\x0f\n\
    \x05\x04\x1b\x02\x02\x04\x12\x06\xcc\x07\x02\xcb\x07\x16\n\r\n\x05\x04\
    \x1b\x02\x02\x05\x12\x04\xcc\x07\x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\
    \x12\x04\xcc\x07\t\x10\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xcc\x07\x13\
    \x14\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xcd\x07\x02\x13\n\x0f\n\x05\x04\
    \x1b\x02\x03\x04\x12\x06\xcd\x07\x02\xcc\x07\x15\n\r\n\x05\x04\x1b\x02\
    \x03\x05\x12\x04\xcd\x07\x02\x07\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\
    \xcd\x07\x08\x0e\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xcd\x07\x11\x12\n\
    \x0c\n\x02\x04\x1c\x12\x06\xd0\x07\0\xd4\x07\x01\n\x0b\n\x03\x04\x1c\x01\
    \x12\x04\xd0\x07\x08\x1c\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xd1\x07\x02\
    \x1e\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\xd1\x07\x02\xd0\x07\x1e\n\r\n\
    \x05\x04\x1c\x02\0\x06\x12\x04\xd1\x07\x02\r\n\r\n\x05\x04\x1c\x02\0\x01\
    \x12\x04\xd1\x07\x0e\x19\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xd1\x07\x1c\
    \x1d\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xd2\x07\x02\x14\n\x0f\n\x05\x04\
    \x1c\x02\x01\x04\x12\x06\xd2\x07\x02\xd1\x07\x1e\n\r\n\x05\x04\x1c\x02\
    \x01\x06\x12\x04\xd2\x07\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\
    \xd2\x07\t\x0f\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xd2\x07\x12\x13\n<\
    \n\x04\x04\x1c\x02\x02\x12\x04\xd3\x07\x02\x11\".transaction\x20id\x20=\
    \x20\x20sha256(transaction.rowdata)\n\n\x0f\n\x05\x04\x1c\x02\x02\x04\
    \x12\x06\xd3\x07\x02\xd2\x07\x14\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\
    \xd3\x07\x02\x07\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xd3\x07\x08\x0c\n\
    \r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xd3\x07\x0f\x10\n\x0c\n\x02\x04\x1d\
    \x12\x06\xd6\x07\0\xd9\x07\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xd6\x07\
    \x08\x1f\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xd7\x07\x02\x15\n\x0f\n\x05\
    \x04\x1d\x02\0\x04\x12\x06\xd7\x07\x02\xd6\x07!\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xd7\x07\x02\x08\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xd7\x07\
    \t\x10\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xd7\x07\x13\x14\n\x0c\n\x04\
    \x04\x1d\x02\x01\x12\x04\xd8\x07\x02\x18\n\x0f\n\x05\x04\x1d\x02\x01\x04\
    \x12\x06\xd8\x07\x02\xd7\x07\x15\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\
    \xd8\x07\x02\x08\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xd8\x07\t\x13\n\r\
    \n\x05\x04\x1d\x02\x01\x03\x12\x04\xd8\x07\x16\x17\n\x0c\n\x02\x04\x1e\
    \x12\x06\xdb\x07\0\xe0\x07\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xdb\x07\
    \x08\x1c\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xdc\x07\x02\x1e\n\x0f\n\x05\
    \x04\x1e\x02\0\x04\x12\x06\xdc\x07\x02\xdb\x07\x1e\n\r\n\x05\x04\x1e\x02\
    \0\x06\x12\x04\xdc\x07\x02\r\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xdc\x07\
    \x0e\x19\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xdc\x07\x1c\x1d\n<\n\x04\
    \x04\x1e\x02\x01\x12\x04\xdd\x07\x02\x11\".transaction\x20id\x20=\x20\
    \x20sha256(transaction.rowdata)\n\n\x0f\n\x05\x04\x1e\x02\x01\x04\x12\
    \x06\xdd\x07\x02\xdc\x07\x1e\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xdd\
    \x07\x02\x07\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xdd\x07\x08\x0c\n\r\n\
    \x05\x04\x1e\x02\x01\x03\x12\x04\xdd\x07\x0f\x10\n\x0c\n\x04\x04\x1e\x02\
    \x02\x12\x04\xde\x07\x02%\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\xde\x07\
    \x02\n\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xde\x07\x0b\x10\n\r\n\x05\
    \x04\x1e\x02\x02\x01\x12\x04\xde\x07\x11\x20\n\r\n\x05\x04\x1e\x02\x02\
    \x03\x12\x04\xde\x07#$\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xdf\x07\x02\
    \x14\n\x0f\n\x05\x04\x1e\x02\x03\x04\x12\x06\xdf\x07\x02\xde\x07%\n\r\n\
    \x05\x04\x1e\x02\x03\x06\x12\x04\xdf\x07\x02\x08\n\r\n\x05\x04\x1e\x02\
    \x03\x01\x12\x04\xdf\x07\t\x0f\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xdf\
    \x07\x12\x13\n\x0c\n\x02\x04\x1f\x12\x06\xe2\x07\0\xe6\x07\x01\n\x0b\n\
    \x03\x04\x1f\x01\x12\x04\xe2\x07\x08\x16\n\x0c\n\x04\x04\x1f\x02\0\x12\
    \x04\xe3\x07\x021\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\xe3\x07\x02\n\n\r\
    \n\x05\x04\x1f\x02\0\x06\x12\x04\xe3\x07\x0b\x1f\n\r\n\x05\x04\x1f\x02\0\
    \x01\x12\x04\xe3\x07\x20,\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xe3\x07/0\
    \n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xe4\x07\x02\x1f\n\x0f\n\x05\x04\x1f\
    \x02\x01\x04\x12\x06\xe4\x07\x02\xe3\x071\n\r\n\x05\x04\x1f\x02\x01\x06\
    \x12\x04\xe4\x07\x02\r\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xe4\x07\x0e\
    \x1a\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xe4\x07\x1d\x1e\n\x0c\n\x04\
    \x04\x1f\x02\x02\x12\x04\xe5\x07\x02\x14\n\x0f\n\x05\x04\x1f\x02\x02\x04\
    \x12\x06\xe5\x07\x02\xe4\x07\x1f\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\
    \xe5\x07\x02\x07\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xe5\x07\x08\x0f\n\
    \r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xe5\x07\x12\x13\n\x0c\n\x02\x04\x20\
    \x12\x06\xe8\x07\0\xea\x07\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xe8\x07\
    \x08\x1a\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xe9\x07\x02$\n\r\n\x05\x04\
    \x20\x02\0\x04\x12\x04\xe9\x07\x02\n\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\
    \xe9\x07\x0b\x19\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xe9\x07\x1a\x1f\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\xe9\x07\"#\n\x0c\n\x02\x04!\x12\x06\xec\
    \x07\0\xee\x07\x01\n\x0b\n\x03\x04!\x01\x12\x04\xec\x07\x08\x20\n\x0c\n\
    \x04\x04!\x02\0\x12\x04\xed\x07\x020\n\r\n\x05\x04!\x02\0\x04\x12\x04\
    \xed\x07\x02\n\n\r\n\x05\x04!\x02\0\x06\x12\x04\xed\x07\x0b\x1f\n\r\n\
    \x05\x04!\x02\0\x01\x12\x04\xed\x07\x20+\n\r\n\x05\x04!\x02\0\x03\x12\
    \x04\xed\x07./\n\x0c\n\x02\x04\"\x12\x06\xf0\x07\0\x83\x08\x01\n\x0b\n\
    \x03\x04\"\x01\x12\x04\xf0\x07\x08\x1d\n\x0e\n\x04\x04\"\x03\0\x12\x06\
    \xf1\x07\x02\xfc\x07\x03\n\r\n\x05\x04\"\x03\0\x01\x12\x04\xf1\x07\n\x10\
    \n\x10\n\x06\x04\"\x03\0\x04\0\x12\x06\xf2\x07\x04\xf9\x07\x05\n\x0f\n\
    \x07\x04\"\x03\0\x04\0\x01\x12\x04\xf2\x07\t\x16\n\x10\n\x08\x04\"\x03\0\
    \x04\0\x02\0\x12\x04\xf3\x07\x06\x1c\n\x11\n\t\x04\"\x03\0\x04\0\x02\0\
    \x01\x12\x04\xf3\x07\x06\x17\n\x11\n\t\x04\"\x03\0\x04\0\x02\0\x02\x12\
    \x04\xf3\x07\x1a\x1b\n\x1c\n\x08\x04\"\x03\0\x04\0\x02\x01\x12\x04\xf4\
    \x07\x06\x20\"\n\x20error\x20in\n\n\x11\n\t\x04\"\x03\0\x04\0\x02\x01\
    \x01\x12\x04\xf4\x07\x06\x1b\n\x11\n\t\x04\"\x03\0\x04\0\x02\x01\x02\x12\
    \x04\xf4\x07\x1e\x1f\n\x10\n\x08\x04\"\x03\0\x04\0\x02\x02\x12\x04\xf5\
    \x07\x06!\n\x11\n\t\x04\"\x03\0\x04\0\x02\x02\x01\x12\x04\xf5\x07\x06\
    \x1c\n\x11\n\t\x04\"\x03\0\x04\0\x02\x02\x02\x12\x04\xf5\x07\x1f\x20\n\
    \x10\n\x08\x04\"\x03\0\x04\0\x02\x03\x12\x04\xf6\x07\x06\x20\n\x11\n\t\
    \x04\"\x03\0\x04\0\x02\x03\x01\x12\x04\xf6\x07\x06\x1b\n\x11\n\t\x04\"\
    \x03\0\x04\0\x02\x03\x02\x12\x04\xf6\x07\x1e\x1f\n/\n\x08\x04\"\x03\0\
    \x04\0\x02\x04\x12\x04\xf7\x07\x06\x1b\"\x1dThe\x20key\x20is\x20not\x20i\
    n\x20permission\n\n\x11\n\t\x04\"\x03\0\x04\0\x02\x04\x01\x12\x04\xf7\
    \x07\x06\x16\n\x11\n\t\x04\"\x03\0\x04\0\x02\x04\x02\x12\x04\xf7\x07\x19\
    \x1a\n\x10\n\x08\x04\"\x03\0\x04\0\x02\x05\x12\x04\xf8\x07\x06\x17\n\x11\
    \n\t\x04\"\x03\0\x04\0\x02\x05\x01\x12\x04\xf8\x07\x06\x11\n\x11\n\t\x04\
    \"\x03\0\x04\0\x02\x05\x02\x12\x04\xf8\x07\x14\x16\n\x0e\n\x06\x04\"\x03\
    \0\x02\0\x12\x04\xfa\x07\x04\x1b\n\x11\n\x07\x04\"\x03\0\x02\0\x04\x12\
    \x06\xfa\x07\x04\xf9\x07\x05\n\x0f\n\x07\x04\"\x03\0\x02\0\x06\x12\x04\
    \xfa\x07\x04\x11\n\x0f\n\x07\x04\"\x03\0\x02\0\x01\x12\x04\xfa\x07\x12\
    \x16\n\x0f\n\x07\x04\"\x03\0\x02\0\x03\x12\x04\xfa\x07\x19\x1a\n\x0e\n\
    \x06\x04\"\x03\0\x02\x01\x12\x04\xfb\x07\x04\x17\n\x11\n\x07\x04\"\x03\0\
    \x02\x01\x04\x12\x06\xfb\x07\x04\xfa\x07\x1b\n\x0f\n\x07\x04\"\x03\0\x02\
    \x01\x05\x12\x04\xfb\x07\x04\n\n\x0f\n\x07\x04\"\x03\0\x02\x01\x01\x12\
    \x04\xfb\x07\x0b\x12\n\x0f\n\x07\x04\"\x03\0\x02\x01\x03\x12\x04\xfb\x07\
    \x15\x16\n\x0c\n\x04\x04\"\x02\0\x12\x04\xfe\x07\x02\x1c\n\x0f\n\x05\x04\
    \"\x02\0\x04\x12\x06\xfe\x07\x02\xfc\x07\x03\n\r\n\x05\x04\"\x02\0\x06\
    \x12\x04\xfe\x07\x02\x0c\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xfe\x07\r\x17\
    \n\r\n\x05\x04\"\x02\0\x03\x12\x04\xfe\x07\x1a\x1b\n\x0c\n\x04\x04\"\x02\
    \x01\x12\x04\xff\x07\x02#\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xff\x07\
    \x02\n\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xff\x07\x0b\x10\n\r\n\x05\x04\
    \"\x02\x01\x01\x12\x04\xff\x07\x11\x1e\n\r\n\x05\x04\"\x02\x01\x03\x12\
    \x04\xff\x07!\"\n\x0c\n\x04\x04\"\x02\x02\x12\x04\x80\x08\x02\x1b\n\x0f\
    \n\x05\x04\"\x02\x02\x04\x12\x06\x80\x08\x02\xff\x07#\n\r\n\x05\x04\"\
    \x02\x02\x05\x12\x04\x80\x08\x02\x07\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\
    \x80\x08\x08\x16\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x80\x08\x19\x1a\n\
    \x0c\n\x04\x04\"\x02\x03\x12\x04\x81\x08\x02\x14\n\x0f\n\x05\x04\"\x02\
    \x03\x04\x12\x06\x81\x08\x02\x80\x08\x1b\n\r\n\x05\x04\"\x02\x03\x06\x12\
    \x04\x81\x08\x02\x08\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\x81\x08\t\x0f\n\
    \r\n\x05\x04\"\x02\x03\x03\x12\x04\x81\x08\x12\x13\n\x0c\n\x04\x04\"\x02\
    \x04\x12\x04\x82\x08\x02'\n\x0f\n\x05\x04\"\x02\x04\x04\x12\x06\x82\x08\
    \x02\x81\x08\x14\n\r\n\x05\x04\"\x02\x04\x06\x12\x04\x82\x08\x02\x16\n\r\
    \n\x05\x04\"\x02\x04\x01\x12\x04\x82\x08\x17\"\n\r\n\x05\x04\"\x02\x04\
    \x03\x12\x04\x82\x08%&\n\x0c\n\x02\x04#\x12\x06\x85\x08\0\x94\x08\x01\n\
    \x0b\n\x03\x04#\x01\x12\x04\x85\x08\x08\x1f\n\x0e\n\x04\x04#\x03\0\x12\
    \x06\x86\x08\x02\x8f\x08\x03\n\r\n\x05\x04#\x03\0\x01\x12\x04\x86\x08\n\
    \x10\n\x10\n\x06\x04#\x03\0\x04\0\x12\x06\x87\x08\x04\x8c\x08\x05\n\x0f\
    \n\x07\x04#\x03\0\x04\0\x01\x12\x04\x87\x08\t\x16\n\x10\n\x08\x04#\x03\0\
    \x04\0\x02\0\x12\x04\x88\x08\x06\x12\n\x11\n\t\x04#\x03\0\x04\0\x02\0\
    \x01\x12\x04\x88\x08\x06\r\n\x11\n\t\x04#\x03\0\x04\0\x02\0\x02\x12\x04\
    \x88\x08\x10\x11\n\x10\n\x08\x04#\x03\0\x04\0\x02\x01\x12\x04\x89\x08\
    \x06!\n\x11\n\t\x04#\x03\0\x04\0\x02\x01\x01\x12\x04\x89\x08\x06\x1c\n\
    \x11\n\t\x04#\x03\0\x04\0\x02\x01\x02\x12\x04\x89\x08\x1f\x20\n\x10\n\
    \x08\x04#\x03\0\x04\0\x02\x02\x12\x04\x8a\x08\x06\x20\n\x11\n\t\x04#\x03\
    \0\x04\0\x02\x02\x01\x12\x04\x8a\x08\x06\x1b\n\x11\n\t\x04#\x03\0\x04\0\
    \x02\x02\x02\x12\x04\x8a\x08\x1e\x1f\n\x10\n\x08\x04#\x03\0\x04\0\x02\
    \x03\x12\x04\x8b\x08\x06\x17\n\x11\n\t\x04#\x03\0\x04\0\x02\x03\x01\x12\
    \x04\x8b\x08\x06\x11\n\x11\n\t\x04#\x03\0\x04\0\x02\x03\x02\x12\x04\x8b\
    \x08\x14\x16\n\x0e\n\x06\x04#\x03\0\x02\0\x12\x04\x8d\x08\x04\x1b\n\x11\
    \n\x07\x04#\x03\0\x02\0\x04\x12\x06\x8d\x08\x04\x8c\x08\x05\n\x0f\n\x07\
    \x04#\x03\0\x02\0\x06\x12\x04\x8d\x08\x04\x11\n\x0f\n\x07\x04#\x03\0\x02\
    \0\x01\x12\x04\x8d\x08\x12\x16\n\x0f\n\x07\x04#\x03\0\x02\0\x03\x12\x04\
    \x8d\x08\x19\x1a\n\x0e\n\x06\x04#\x03\0\x02\x01\x12\x04\x8e\x08\x04\x17\
    \n\x11\n\x07\x04#\x03\0\x02\x01\x04\x12\x06\x8e\x08\x04\x8d\x08\x1b\n\
    \x0f\n\x07\x04#\x03\0\x02\x01\x05\x12\x04\x8e\x08\x04\n\n\x0f\n\x07\x04#\
    \x03\0\x02\x01\x01\x12\x04\x8e\x08\x0b\x12\n\x0f\n\x07\x04#\x03\0\x02\
    \x01\x03\x12\x04\x8e\x08\x15\x16\n\x0c\n\x04\x04#\x02\0\x12\x04\x91\x08\
    \x02#\n\r\n\x05\x04#\x02\0\x04\x12\x04\x91\x08\x02\n\n\r\n\x05\x04#\x02\
    \0\x05\x12\x04\x91\x08\x0b\x10\n\r\n\x05\x04#\x02\0\x01\x12\x04\x91\x08\
    \x11\x1e\n\r\n\x05\x04#\x02\0\x03\x12\x04\x91\x08!\"\n\x0c\n\x04\x04#\
    \x02\x01\x12\x04\x92\x08\x02\x14\n\x0f\n\x05\x04#\x02\x01\x04\x12\x06\
    \x92\x08\x02\x91\x08#\n\r\n\x05\x04#\x02\x01\x06\x12\x04\x92\x08\x02\x08\
    \n\r\n\x05\x04#\x02\x01\x01\x12\x04\x92\x08\t\x0f\n\r\n\x05\x04#\x02\x01\
    \x03\x12\x04\x92\x08\x12\x13\n\x0c\n\x04\x04#\x02\x02\x12\x04\x93\x08\
    \x02'\n\x0f\n\x05\x04#\x02\x02\x04\x12\x06\x93\x08\x02\x92\x08\x14\n\r\n\
    \x05\x04#\x02\x02\x06\x12\x04\x93\x08\x02\x16\n\r\n\x05\x04#\x02\x02\x01\
    \x12\x04\x93\x08\x17\"\n\r\n\x05\x04#\x02\x02\x03\x12\x04\x93\x08%&b\x06\
    proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
