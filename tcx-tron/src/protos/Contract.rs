// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `core/Contract.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct AccountCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub account_address: ::std::vec::Vec<u8>,
    pub field_type: super::Tron::AccountType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountCreateContract {
    fn default() -> &'a AccountCreateContract {
        <AccountCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl AccountCreateContract {
    pub fn new() -> AccountCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes account_address = 2;


    pub fn get_account_address(&self) -> &[u8] {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_address, ::std::vec::Vec::new())
    }

    // .protocol.AccountType type = 3;


    pub fn get_field_type(&self) -> super::Tron::AccountType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = super::Tron::AccountType::Normal;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: super::Tron::AccountType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for AccountCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_address)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.account_address);
        }
        if self.field_type != super::Tron::AccountType::Normal {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.account_address.is_empty() {
            os.write_bytes(2, &self.account_address)?;
        }
        if self.field_type != super::Tron::AccountType::Normal {
            os.write_enum(3, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountCreateContract {
        AccountCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &AccountCreateContract| { &m.owner_address },
                    |m: &mut AccountCreateContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account_address",
                    |m: &AccountCreateContract| { &m.account_address },
                    |m: &mut AccountCreateContract| { &mut m.account_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::Tron::AccountType>>(
                    "type",
                    |m: &AccountCreateContract| { &m.field_type },
                    |m: &mut AccountCreateContract| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountCreateContract>(
                    "AccountCreateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountCreateContract {
        static mut instance: ::protobuf::lazy::Lazy<AccountCreateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountCreateContract,
        };
        unsafe {
            instance.get(AccountCreateContract::new)
        }
    }
}

impl ::protobuf::Clear for AccountCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.account_address.clear();
        self.field_type = super::Tron::AccountType::Normal;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountUpdateContract {
    // message fields
    pub account_name: ::std::vec::Vec<u8>,
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountUpdateContract {
    fn default() -> &'a AccountUpdateContract {
        <AccountUpdateContract as ::protobuf::Message>::default_instance()
    }
}

impl AccountUpdateContract {
    pub fn new() -> AccountUpdateContract {
        ::std::default::Default::default()
    }

    // bytes account_name = 1;


    pub fn get_account_name(&self) -> &[u8] {
        &self.account_name
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_name
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_name, ::std::vec::Vec::new())
    }

    // bytes owner_address = 2;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AccountUpdateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_name);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account_name.is_empty() {
            os.write_bytes(1, &self.account_name)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountUpdateContract {
        AccountUpdateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account_name",
                    |m: &AccountUpdateContract| { &m.account_name },
                    |m: &mut AccountUpdateContract| { &mut m.account_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &AccountUpdateContract| { &m.owner_address },
                    |m: &mut AccountUpdateContract| { &mut m.owner_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountUpdateContract>(
                    "AccountUpdateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountUpdateContract {
        static mut instance: ::protobuf::lazy::Lazy<AccountUpdateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountUpdateContract,
        };
        unsafe {
            instance.get(AccountUpdateContract::new)
        }
    }
}

impl ::protobuf::Clear for AccountUpdateContract {
    fn clear(&mut self) {
        self.account_name.clear();
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountUpdateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountUpdateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetAccountIdContract {
    // message fields
    pub account_id: ::std::vec::Vec<u8>,
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAccountIdContract {
    fn default() -> &'a SetAccountIdContract {
        <SetAccountIdContract as ::protobuf::Message>::default_instance()
    }
}

impl SetAccountIdContract {
    pub fn new() -> SetAccountIdContract {
        ::std::default::Default::default()
    }

    // bytes account_id = 1;


    pub fn get_account_id(&self) -> &[u8] {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_id, ::std::vec::Vec::new())
    }

    // bytes owner_address = 2;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SetAccountIdContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_id);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_bytes(1, &self.account_id)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAccountIdContract {
        SetAccountIdContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account_id",
                    |m: &SetAccountIdContract| { &m.account_id },
                    |m: &mut SetAccountIdContract| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &SetAccountIdContract| { &m.owner_address },
                    |m: &mut SetAccountIdContract| { &mut m.owner_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetAccountIdContract>(
                    "SetAccountIdContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetAccountIdContract {
        static mut instance: ::protobuf::lazy::Lazy<SetAccountIdContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetAccountIdContract,
        };
        unsafe {
            instance.get(SetAccountIdContract::new)
        }
    }
}

impl ::protobuf::Clear for SetAccountIdContract {
    fn clear(&mut self) {
        self.account_id.clear();
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAccountIdContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAccountIdContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub to_address: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferContract {
    fn default() -> &'a TransferContract {
        <TransferContract as ::protobuf::Message>::default_instance()
    }
}

impl TransferContract {
    pub fn new() -> TransferContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes to_address = 2;


    pub fn get_to_address(&self) -> &[u8] {
        &self.to_address
    }
    pub fn clear_to_address(&mut self) {
        self.to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_address
    }

    // Take field
    pub fn take_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_address, ::std::vec::Vec::new())
    }

    // int64 amount = 3;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for TransferContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_address);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(2, &self.to_address)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferContract {
        TransferContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &TransferContract| { &m.owner_address },
                    |m: &mut TransferContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to_address",
                    |m: &TransferContract| { &m.to_address },
                    |m: &mut TransferContract| { &mut m.to_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &TransferContract| { &m.amount },
                    |m: &mut TransferContract| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransferContract>(
                    "TransferContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransferContract {
        static mut instance: ::protobuf::lazy::Lazy<TransferContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransferContract,
        };
        unsafe {
            instance.get(TransferContract::new)
        }
    }
}

impl ::protobuf::Clear for TransferContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.to_address.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferAssetContract {
    // message fields
    pub asset_name: ::std::vec::Vec<u8>,
    pub owner_address: ::std::vec::Vec<u8>,
    pub to_address: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferAssetContract {
    fn default() -> &'a TransferAssetContract {
        <TransferAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl TransferAssetContract {
    pub fn new() -> TransferAssetContract {
        ::std::default::Default::default()
    }

    // bytes asset_name = 1;


    pub fn get_asset_name(&self) -> &[u8] {
        &self.asset_name
    }
    pub fn clear_asset_name(&mut self) {
        self.asset_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_name
    }

    // Take field
    pub fn take_asset_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_name, ::std::vec::Vec::new())
    }

    // bytes owner_address = 2;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes to_address = 3;


    pub fn get_to_address(&self) -> &[u8] {
        &self.to_address
    }
    pub fn clear_to_address(&mut self) {
        self.to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_address
    }

    // Take field
    pub fn take_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_address, ::std::vec::Vec::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for TransferAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.asset_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.asset_name);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.to_address);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.asset_name.is_empty() {
            os.write_bytes(1, &self.asset_name)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(3, &self.to_address)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferAssetContract {
        TransferAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "asset_name",
                    |m: &TransferAssetContract| { &m.asset_name },
                    |m: &mut TransferAssetContract| { &mut m.asset_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &TransferAssetContract| { &m.owner_address },
                    |m: &mut TransferAssetContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to_address",
                    |m: &TransferAssetContract| { &m.to_address },
                    |m: &mut TransferAssetContract| { &mut m.to_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &TransferAssetContract| { &m.amount },
                    |m: &mut TransferAssetContract| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransferAssetContract>(
                    "TransferAssetContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransferAssetContract {
        static mut instance: ::protobuf::lazy::Lazy<TransferAssetContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransferAssetContract,
        };
        unsafe {
            instance.get(TransferAssetContract::new)
        }
    }
}

impl ::protobuf::Clear for TransferAssetContract {
    fn clear(&mut self) {
        self.asset_name.clear();
        self.owner_address.clear();
        self.to_address.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteAssetContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub vote_address: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub support: bool,
    pub count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteAssetContract {
    fn default() -> &'a VoteAssetContract {
        <VoteAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl VoteAssetContract {
    pub fn new() -> VoteAssetContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // repeated bytes vote_address = 2;


    pub fn get_vote_address(&self) -> &[::std::vec::Vec<u8>] {
        &self.vote_address
    }
    pub fn clear_vote_address(&mut self) {
        self.vote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_address(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.vote_address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vote_address(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.vote_address
    }

    // Take field
    pub fn take_vote_address(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.vote_address, ::protobuf::RepeatedField::new())
    }

    // bool support = 3;


    pub fn get_support(&self) -> bool {
        self.support
    }
    pub fn clear_support(&mut self) {
        self.support = false;
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: bool) {
        self.support = v;
    }

    // int32 count = 5;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }
}

impl ::protobuf::Message for VoteAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.vote_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.support = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        for value in &self.vote_address {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.support != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        for v in &self.vote_address {
            os.write_bytes(2, &v)?;
        };
        if self.support != false {
            os.write_bool(3, self.support)?;
        }
        if self.count != 0 {
            os.write_int32(5, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteAssetContract {
        VoteAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &VoteAssetContract| { &m.owner_address },
                    |m: &mut VoteAssetContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vote_address",
                    |m: &VoteAssetContract| { &m.vote_address },
                    |m: &mut VoteAssetContract| { &mut m.vote_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "support",
                    |m: &VoteAssetContract| { &m.support },
                    |m: &mut VoteAssetContract| { &mut m.support },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &VoteAssetContract| { &m.count },
                    |m: &mut VoteAssetContract| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoteAssetContract>(
                    "VoteAssetContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VoteAssetContract {
        static mut instance: ::protobuf::lazy::Lazy<VoteAssetContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VoteAssetContract,
        };
        unsafe {
            instance.get(VoteAssetContract::new)
        }
    }
}

impl ::protobuf::Clear for VoteAssetContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.vote_address.clear();
        self.support = false;
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteWitnessContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub votes: ::protobuf::RepeatedField<VoteWitnessContract_Vote>,
    pub support: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteWitnessContract {
    fn default() -> &'a VoteWitnessContract {
        <VoteWitnessContract as ::protobuf::Message>::default_instance()
    }
}

impl VoteWitnessContract {
    pub fn new() -> VoteWitnessContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.VoteWitnessContract.Vote votes = 2;


    pub fn get_votes(&self) -> &[VoteWitnessContract_Vote] {
        &self.votes
    }
    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<VoteWitnessContract_Vote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<VoteWitnessContract_Vote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<VoteWitnessContract_Vote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    // bool support = 3;


    pub fn get_support(&self) -> bool {
        self.support
    }
    pub fn clear_support(&mut self) {
        self.support = false;
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: bool) {
        self.support = v;
    }
}

impl ::protobuf::Message for VoteWitnessContract {
    fn is_initialized(&self) -> bool {
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.support = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.support != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        for v in &self.votes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.support != false {
            os.write_bool(3, self.support)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteWitnessContract {
        VoteWitnessContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &VoteWitnessContract| { &m.owner_address },
                    |m: &mut VoteWitnessContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoteWitnessContract_Vote>>(
                    "votes",
                    |m: &VoteWitnessContract| { &m.votes },
                    |m: &mut VoteWitnessContract| { &mut m.votes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "support",
                    |m: &VoteWitnessContract| { &m.support },
                    |m: &mut VoteWitnessContract| { &mut m.support },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoteWitnessContract>(
                    "VoteWitnessContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VoteWitnessContract {
        static mut instance: ::protobuf::lazy::Lazy<VoteWitnessContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VoteWitnessContract,
        };
        unsafe {
            instance.get(VoteWitnessContract::new)
        }
    }
}

impl ::protobuf::Clear for VoteWitnessContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.votes.clear();
        self.support = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteWitnessContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteWitnessContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VoteWitnessContract_Vote {
    // message fields
    pub vote_address: ::std::vec::Vec<u8>,
    pub vote_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteWitnessContract_Vote {
    fn default() -> &'a VoteWitnessContract_Vote {
        <VoteWitnessContract_Vote as ::protobuf::Message>::default_instance()
    }
}

impl VoteWitnessContract_Vote {
    pub fn new() -> VoteWitnessContract_Vote {
        ::std::default::Default::default()
    }

    // bytes vote_address = 1;


    pub fn get_vote_address(&self) -> &[u8] {
        &self.vote_address
    }
    pub fn clear_vote_address(&mut self) {
        self.vote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.vote_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vote_address
    }

    // Take field
    pub fn take_vote_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vote_address, ::std::vec::Vec::new())
    }

    // int64 vote_count = 2;


    pub fn get_vote_count(&self) -> i64 {
        self.vote_count
    }
    pub fn clear_vote_count(&mut self) {
        self.vote_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: i64) {
        self.vote_count = v;
    }
}

impl ::protobuf::Message for VoteWitnessContract_Vote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vote_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vote_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vote_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vote_address);
        }
        if self.vote_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vote_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.vote_address.is_empty() {
            os.write_bytes(1, &self.vote_address)?;
        }
        if self.vote_count != 0 {
            os.write_int64(2, self.vote_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteWitnessContract_Vote {
        VoteWitnessContract_Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vote_address",
                    |m: &VoteWitnessContract_Vote| { &m.vote_address },
                    |m: &mut VoteWitnessContract_Vote| { &mut m.vote_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vote_count",
                    |m: &VoteWitnessContract_Vote| { &m.vote_count },
                    |m: &mut VoteWitnessContract_Vote| { &mut m.vote_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoteWitnessContract_Vote>(
                    "VoteWitnessContract_Vote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VoteWitnessContract_Vote {
        static mut instance: ::protobuf::lazy::Lazy<VoteWitnessContract_Vote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VoteWitnessContract_Vote,
        };
        unsafe {
            instance.get(VoteWitnessContract_Vote::new)
        }
    }
}

impl ::protobuf::Clear for VoteWitnessContract_Vote {
    fn clear(&mut self) {
        self.vote_address.clear();
        self.vote_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteWitnessContract_Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteWitnessContract_Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSettingContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub consume_user_resource_percent: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSettingContract {
    fn default() -> &'a UpdateSettingContract {
        <UpdateSettingContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSettingContract {
    pub fn new() -> UpdateSettingContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // int64 consume_user_resource_percent = 3;


    pub fn get_consume_user_resource_percent(&self) -> i64 {
        self.consume_user_resource_percent
    }
    pub fn clear_consume_user_resource_percent(&mut self) {
        self.consume_user_resource_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_consume_user_resource_percent(&mut self, v: i64) {
        self.consume_user_resource_percent = v;
    }
}

impl ::protobuf::Message for UpdateSettingContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.consume_user_resource_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if self.consume_user_resource_percent != 0 {
            my_size += ::protobuf::rt::value_size(3, self.consume_user_resource_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if self.consume_user_resource_percent != 0 {
            os.write_int64(3, self.consume_user_resource_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSettingContract {
        UpdateSettingContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &UpdateSettingContract| { &m.owner_address },
                    |m: &mut UpdateSettingContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract_address",
                    |m: &UpdateSettingContract| { &m.contract_address },
                    |m: &mut UpdateSettingContract| { &mut m.contract_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "consume_user_resource_percent",
                    |m: &UpdateSettingContract| { &m.consume_user_resource_percent },
                    |m: &mut UpdateSettingContract| { &mut m.consume_user_resource_percent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateSettingContract>(
                    "UpdateSettingContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateSettingContract {
        static mut instance: ::protobuf::lazy::Lazy<UpdateSettingContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateSettingContract,
        };
        unsafe {
            instance.get(UpdateSettingContract::new)
        }
    }
}

impl ::protobuf::Clear for UpdateSettingContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.consume_user_resource_percent = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSettingContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSettingContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateEnergyLimitContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub origin_energy_limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateEnergyLimitContract {
    fn default() -> &'a UpdateEnergyLimitContract {
        <UpdateEnergyLimitContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEnergyLimitContract {
    pub fn new() -> UpdateEnergyLimitContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // int64 origin_energy_limit = 3;


    pub fn get_origin_energy_limit(&self) -> i64 {
        self.origin_energy_limit
    }
    pub fn clear_origin_energy_limit(&mut self) {
        self.origin_energy_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_energy_limit(&mut self, v: i64) {
        self.origin_energy_limit = v;
    }
}

impl ::protobuf::Message for UpdateEnergyLimitContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.origin_energy_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if self.origin_energy_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.origin_energy_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if self.origin_energy_limit != 0 {
            os.write_int64(3, self.origin_energy_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateEnergyLimitContract {
        UpdateEnergyLimitContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &UpdateEnergyLimitContract| { &m.owner_address },
                    |m: &mut UpdateEnergyLimitContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract_address",
                    |m: &UpdateEnergyLimitContract| { &m.contract_address },
                    |m: &mut UpdateEnergyLimitContract| { &mut m.contract_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "origin_energy_limit",
                    |m: &UpdateEnergyLimitContract| { &m.origin_energy_limit },
                    |m: &mut UpdateEnergyLimitContract| { &mut m.origin_energy_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateEnergyLimitContract>(
                    "UpdateEnergyLimitContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateEnergyLimitContract {
        static mut instance: ::protobuf::lazy::Lazy<UpdateEnergyLimitContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateEnergyLimitContract,
        };
        unsafe {
            instance.get(UpdateEnergyLimitContract::new)
        }
    }
}

impl ::protobuf::Clear for UpdateEnergyLimitContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.origin_energy_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateEnergyLimitContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEnergyLimitContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearABIContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearABIContract {
    fn default() -> &'a ClearABIContract {
        <ClearABIContract as ::protobuf::Message>::default_instance()
    }
}

impl ClearABIContract {
    pub fn new() -> ClearABIContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ClearABIContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearABIContract {
        ClearABIContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ClearABIContract| { &m.owner_address },
                    |m: &mut ClearABIContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract_address",
                    |m: &ClearABIContract| { &m.contract_address },
                    |m: &mut ClearABIContract| { &mut m.contract_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClearABIContract>(
                    "ClearABIContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClearABIContract {
        static mut instance: ::protobuf::lazy::Lazy<ClearABIContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClearABIContract,
        };
        unsafe {
            instance.get(ClearABIContract::new)
        }
    }
}

impl ::protobuf::Clear for ClearABIContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearABIContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearABIContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WitnessCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub url: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WitnessCreateContract {
    fn default() -> &'a WitnessCreateContract {
        <WitnessCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl WitnessCreateContract {
    pub fn new() -> WitnessCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes url = 2;


    pub fn get_url(&self) -> &[u8] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.url, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WitnessCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(2, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WitnessCreateContract {
        WitnessCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &WitnessCreateContract| { &m.owner_address },
                    |m: &mut WitnessCreateContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "url",
                    |m: &WitnessCreateContract| { &m.url },
                    |m: &mut WitnessCreateContract| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WitnessCreateContract>(
                    "WitnessCreateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WitnessCreateContract {
        static mut instance: ::protobuf::lazy::Lazy<WitnessCreateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WitnessCreateContract,
        };
        unsafe {
            instance.get(WitnessCreateContract::new)
        }
    }
}

impl ::protobuf::Clear for WitnessCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WitnessCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WitnessCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WitnessUpdateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub update_url: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WitnessUpdateContract {
    fn default() -> &'a WitnessUpdateContract {
        <WitnessUpdateContract as ::protobuf::Message>::default_instance()
    }
}

impl WitnessUpdateContract {
    pub fn new() -> WitnessUpdateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes update_url = 12;


    pub fn get_update_url(&self) -> &[u8] {
        &self.update_url
    }
    pub fn clear_update_url(&mut self) {
        self.update_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.update_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.update_url
    }

    // Take field
    pub fn take_update_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.update_url, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WitnessUpdateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.update_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.update_url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.update_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.update_url.is_empty() {
            os.write_bytes(12, &self.update_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WitnessUpdateContract {
        WitnessUpdateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &WitnessUpdateContract| { &m.owner_address },
                    |m: &mut WitnessUpdateContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "update_url",
                    |m: &WitnessUpdateContract| { &m.update_url },
                    |m: &mut WitnessUpdateContract| { &mut m.update_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WitnessUpdateContract>(
                    "WitnessUpdateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WitnessUpdateContract {
        static mut instance: ::protobuf::lazy::Lazy<WitnessUpdateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WitnessUpdateContract,
        };
        unsafe {
            instance.get(WitnessUpdateContract::new)
        }
    }
}

impl ::protobuf::Clear for WitnessUpdateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.update_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WitnessUpdateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WitnessUpdateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssetIssueContract {
    // message fields
    pub id: ::std::string::String,
    pub owner_address: ::std::vec::Vec<u8>,
    pub name: ::std::vec::Vec<u8>,
    pub abbr: ::std::vec::Vec<u8>,
    pub total_supply: i64,
    pub frozen_supply: ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply>,
    pub trx_num: i32,
    pub precision: i32,
    pub num: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub order: i64,
    pub vote_score: i32,
    pub description: ::std::vec::Vec<u8>,
    pub url: ::std::vec::Vec<u8>,
    pub free_asset_net_limit: i64,
    pub public_free_asset_net_limit: i64,
    pub public_free_asset_net_usage: i64,
    pub public_latest_free_net_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIssueContract {
    fn default() -> &'a AssetIssueContract {
        <AssetIssueContract as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueContract {
    pub fn new() -> AssetIssueContract {
        ::std::default::Default::default()
    }

    // string id = 41;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes name = 2;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }

    // bytes abbr = 3;


    pub fn get_abbr(&self) -> &[u8] {
        &self.abbr
    }
    pub fn clear_abbr(&mut self) {
        self.abbr.clear();
    }

    // Param is passed by value, moved
    pub fn set_abbr(&mut self, v: ::std::vec::Vec<u8>) {
        self.abbr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abbr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.abbr
    }

    // Take field
    pub fn take_abbr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.abbr, ::std::vec::Vec::new())
    }

    // int64 total_supply = 4;


    pub fn get_total_supply(&self) -> i64 {
        self.total_supply
    }
    pub fn clear_total_supply(&mut self) {
        self.total_supply = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_supply(&mut self, v: i64) {
        self.total_supply = v;
    }

    // repeated .protocol.AssetIssueContract.FrozenSupply frozen_supply = 5;


    pub fn get_frozen_supply(&self) -> &[AssetIssueContract_FrozenSupply] {
        &self.frozen_supply
    }
    pub fn clear_frozen_supply(&mut self) {
        self.frozen_supply.clear();
    }

    // Param is passed by value, moved
    pub fn set_frozen_supply(&mut self, v: ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply>) {
        self.frozen_supply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frozen_supply(&mut self) -> &mut ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply> {
        &mut self.frozen_supply
    }

    // Take field
    pub fn take_frozen_supply(&mut self) -> ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply> {
        ::std::mem::replace(&mut self.frozen_supply, ::protobuf::RepeatedField::new())
    }

    // int32 trx_num = 6;


    pub fn get_trx_num(&self) -> i32 {
        self.trx_num
    }
    pub fn clear_trx_num(&mut self) {
        self.trx_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_trx_num(&mut self, v: i32) {
        self.trx_num = v;
    }

    // int32 precision = 7;


    pub fn get_precision(&self) -> i32 {
        self.precision
    }
    pub fn clear_precision(&mut self) {
        self.precision = 0;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: i32) {
        self.precision = v;
    }

    // int32 num = 8;


    pub fn get_num(&self) -> i32 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: i32) {
        self.num = v;
    }

    // int64 start_time = 9;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // int64 end_time = 10;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // int64 order = 11;


    pub fn get_order(&self) -> i64 {
        self.order
    }
    pub fn clear_order(&mut self) {
        self.order = 0;
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: i64) {
        self.order = v;
    }

    // int32 vote_score = 16;


    pub fn get_vote_score(&self) -> i32 {
        self.vote_score
    }
    pub fn clear_vote_score(&mut self) {
        self.vote_score = 0;
    }

    // Param is passed by value, moved
    pub fn set_vote_score(&mut self, v: i32) {
        self.vote_score = v;
    }

    // bytes description = 20;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }

    // bytes url = 21;


    pub fn get_url(&self) -> &[u8] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.url, ::std::vec::Vec::new())
    }

    // int64 free_asset_net_limit = 22;


    pub fn get_free_asset_net_limit(&self) -> i64 {
        self.free_asset_net_limit
    }
    pub fn clear_free_asset_net_limit(&mut self) {
        self.free_asset_net_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_free_asset_net_limit(&mut self, v: i64) {
        self.free_asset_net_limit = v;
    }

    // int64 public_free_asset_net_limit = 23;


    pub fn get_public_free_asset_net_limit(&self) -> i64 {
        self.public_free_asset_net_limit
    }
    pub fn clear_public_free_asset_net_limit(&mut self) {
        self.public_free_asset_net_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_public_free_asset_net_limit(&mut self, v: i64) {
        self.public_free_asset_net_limit = v;
    }

    // int64 public_free_asset_net_usage = 24;


    pub fn get_public_free_asset_net_usage(&self) -> i64 {
        self.public_free_asset_net_usage
    }
    pub fn clear_public_free_asset_net_usage(&mut self) {
        self.public_free_asset_net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_public_free_asset_net_usage(&mut self, v: i64) {
        self.public_free_asset_net_usage = v;
    }

    // int64 public_latest_free_net_time = 25;


    pub fn get_public_latest_free_net_time(&self) -> i64 {
        self.public_latest_free_net_time
    }
    pub fn clear_public_latest_free_net_time(&mut self) {
        self.public_latest_free_net_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_public_latest_free_net_time(&mut self, v: i64) {
        self.public_latest_free_net_time = v;
    }
}

impl ::protobuf::Message for AssetIssueContract {
    fn is_initialized(&self) -> bool {
        for v in &self.frozen_supply {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                41 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.abbr)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_supply = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frozen_supply)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trx_num = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.precision = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_time = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_time = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.order = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote_score = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.url)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.free_asset_net_limit = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.public_free_asset_net_limit = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.public_free_asset_net_usage = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.public_latest_free_net_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.id);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.name);
        }
        if !self.abbr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.abbr);
        }
        if self.total_supply != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total_supply, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.frozen_supply {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.trx_num != 0 {
            my_size += ::protobuf::rt::value_size(6, self.trx_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.precision != 0 {
            my_size += ::protobuf::rt::value_size(7, self.precision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num != 0 {
            my_size += ::protobuf::rt::value_size(8, self.num, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(10, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.order != 0 {
            my_size += ::protobuf::rt::value_size(11, self.order, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vote_score != 0 {
            my_size += ::protobuf::rt::value_size(16, self.vote_score, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(21, &self.url);
        }
        if self.free_asset_net_limit != 0 {
            my_size += ::protobuf::rt::value_size(22, self.free_asset_net_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.public_free_asset_net_limit != 0 {
            my_size += ::protobuf::rt::value_size(23, self.public_free_asset_net_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.public_free_asset_net_usage != 0 {
            my_size += ::protobuf::rt::value_size(24, self.public_free_asset_net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.public_latest_free_net_time != 0 {
            my_size += ::protobuf::rt::value_size(25, self.public_latest_free_net_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(41, &self.id)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.name.is_empty() {
            os.write_bytes(2, &self.name)?;
        }
        if !self.abbr.is_empty() {
            os.write_bytes(3, &self.abbr)?;
        }
        if self.total_supply != 0 {
            os.write_int64(4, self.total_supply)?;
        }
        for v in &self.frozen_supply {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.trx_num != 0 {
            os.write_int32(6, self.trx_num)?;
        }
        if self.precision != 0 {
            os.write_int32(7, self.precision)?;
        }
        if self.num != 0 {
            os.write_int32(8, self.num)?;
        }
        if self.start_time != 0 {
            os.write_int64(9, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(10, self.end_time)?;
        }
        if self.order != 0 {
            os.write_int64(11, self.order)?;
        }
        if self.vote_score != 0 {
            os.write_int32(16, self.vote_score)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(20, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(21, &self.url)?;
        }
        if self.free_asset_net_limit != 0 {
            os.write_int64(22, self.free_asset_net_limit)?;
        }
        if self.public_free_asset_net_limit != 0 {
            os.write_int64(23, self.public_free_asset_net_limit)?;
        }
        if self.public_free_asset_net_usage != 0 {
            os.write_int64(24, self.public_free_asset_net_usage)?;
        }
        if self.public_latest_free_net_time != 0 {
            os.write_int64(25, self.public_latest_free_net_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIssueContract {
        AssetIssueContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &AssetIssueContract| { &m.id },
                    |m: &mut AssetIssueContract| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &AssetIssueContract| { &m.owner_address },
                    |m: &mut AssetIssueContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "name",
                    |m: &AssetIssueContract| { &m.name },
                    |m: &mut AssetIssueContract| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "abbr",
                    |m: &AssetIssueContract| { &m.abbr },
                    |m: &mut AssetIssueContract| { &mut m.abbr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_supply",
                    |m: &AssetIssueContract| { &m.total_supply },
                    |m: &mut AssetIssueContract| { &mut m.total_supply },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetIssueContract_FrozenSupply>>(
                    "frozen_supply",
                    |m: &AssetIssueContract| { &m.frozen_supply },
                    |m: &mut AssetIssueContract| { &mut m.frozen_supply },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "trx_num",
                    |m: &AssetIssueContract| { &m.trx_num },
                    |m: &mut AssetIssueContract| { &mut m.trx_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "precision",
                    |m: &AssetIssueContract| { &m.precision },
                    |m: &mut AssetIssueContract| { &mut m.precision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num",
                    |m: &AssetIssueContract| { &m.num },
                    |m: &mut AssetIssueContract| { &mut m.num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "start_time",
                    |m: &AssetIssueContract| { &m.start_time },
                    |m: &mut AssetIssueContract| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "end_time",
                    |m: &AssetIssueContract| { &m.end_time },
                    |m: &mut AssetIssueContract| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "order",
                    |m: &AssetIssueContract| { &m.order },
                    |m: &mut AssetIssueContract| { &mut m.order },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "vote_score",
                    |m: &AssetIssueContract| { &m.vote_score },
                    |m: &mut AssetIssueContract| { &mut m.vote_score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "description",
                    |m: &AssetIssueContract| { &m.description },
                    |m: &mut AssetIssueContract| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "url",
                    |m: &AssetIssueContract| { &m.url },
                    |m: &mut AssetIssueContract| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "free_asset_net_limit",
                    |m: &AssetIssueContract| { &m.free_asset_net_limit },
                    |m: &mut AssetIssueContract| { &mut m.free_asset_net_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "public_free_asset_net_limit",
                    |m: &AssetIssueContract| { &m.public_free_asset_net_limit },
                    |m: &mut AssetIssueContract| { &mut m.public_free_asset_net_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "public_free_asset_net_usage",
                    |m: &AssetIssueContract| { &m.public_free_asset_net_usage },
                    |m: &mut AssetIssueContract| { &mut m.public_free_asset_net_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "public_latest_free_net_time",
                    |m: &AssetIssueContract| { &m.public_latest_free_net_time },
                    |m: &mut AssetIssueContract| { &mut m.public_latest_free_net_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssetIssueContract>(
                    "AssetIssueContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssetIssueContract {
        static mut instance: ::protobuf::lazy::Lazy<AssetIssueContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssetIssueContract,
        };
        unsafe {
            instance.get(AssetIssueContract::new)
        }
    }
}

impl ::protobuf::Clear for AssetIssueContract {
    fn clear(&mut self) {
        self.id.clear();
        self.owner_address.clear();
        self.name.clear();
        self.abbr.clear();
        self.total_supply = 0;
        self.frozen_supply.clear();
        self.trx_num = 0;
        self.precision = 0;
        self.num = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.order = 0;
        self.vote_score = 0;
        self.description.clear();
        self.url.clear();
        self.free_asset_net_limit = 0;
        self.public_free_asset_net_limit = 0;
        self.public_free_asset_net_usage = 0;
        self.public_latest_free_net_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIssueContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssetIssueContract_FrozenSupply {
    // message fields
    pub frozen_amount: i64,
    pub frozen_days: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIssueContract_FrozenSupply {
    fn default() -> &'a AssetIssueContract_FrozenSupply {
        <AssetIssueContract_FrozenSupply as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueContract_FrozenSupply {
    pub fn new() -> AssetIssueContract_FrozenSupply {
        ::std::default::Default::default()
    }

    // int64 frozen_amount = 1;


    pub fn get_frozen_amount(&self) -> i64 {
        self.frozen_amount
    }
    pub fn clear_frozen_amount(&mut self) {
        self.frozen_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_amount(&mut self, v: i64) {
        self.frozen_amount = v;
    }

    // int64 frozen_days = 2;


    pub fn get_frozen_days(&self) -> i64 {
        self.frozen_days
    }
    pub fn clear_frozen_days(&mut self) {
        self.frozen_days = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_days(&mut self, v: i64) {
        self.frozen_days = v;
    }
}

impl ::protobuf::Message for AssetIssueContract_FrozenSupply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_amount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_days = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frozen_amount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.frozen_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frozen_days != 0 {
            my_size += ::protobuf::rt::value_size(2, self.frozen_days, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.frozen_amount != 0 {
            os.write_int64(1, self.frozen_amount)?;
        }
        if self.frozen_days != 0 {
            os.write_int64(2, self.frozen_days)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIssueContract_FrozenSupply {
        AssetIssueContract_FrozenSupply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_amount",
                    |m: &AssetIssueContract_FrozenSupply| { &m.frozen_amount },
                    |m: &mut AssetIssueContract_FrozenSupply| { &mut m.frozen_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_days",
                    |m: &AssetIssueContract_FrozenSupply| { &m.frozen_days },
                    |m: &mut AssetIssueContract_FrozenSupply| { &mut m.frozen_days },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssetIssueContract_FrozenSupply>(
                    "AssetIssueContract_FrozenSupply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssetIssueContract_FrozenSupply {
        static mut instance: ::protobuf::lazy::Lazy<AssetIssueContract_FrozenSupply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssetIssueContract_FrozenSupply,
        };
        unsafe {
            instance.get(AssetIssueContract_FrozenSupply::new)
        }
    }
}

impl ::protobuf::Clear for AssetIssueContract_FrozenSupply {
    fn clear(&mut self) {
        self.frozen_amount = 0;
        self.frozen_days = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIssueContract_FrozenSupply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueContract_FrozenSupply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParticipateAssetIssueContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub to_address: ::std::vec::Vec<u8>,
    pub asset_name: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParticipateAssetIssueContract {
    fn default() -> &'a ParticipateAssetIssueContract {
        <ParticipateAssetIssueContract as ::protobuf::Message>::default_instance()
    }
}

impl ParticipateAssetIssueContract {
    pub fn new() -> ParticipateAssetIssueContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes to_address = 2;


    pub fn get_to_address(&self) -> &[u8] {
        &self.to_address
    }
    pub fn clear_to_address(&mut self) {
        self.to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_address
    }

    // Take field
    pub fn take_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_address, ::std::vec::Vec::new())
    }

    // bytes asset_name = 3;


    pub fn get_asset_name(&self) -> &[u8] {
        &self.asset_name
    }
    pub fn clear_asset_name(&mut self) {
        self.asset_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_name
    }

    // Take field
    pub fn take_asset_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_name, ::std::vec::Vec::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for ParticipateAssetIssueContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_address);
        }
        if !self.asset_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.asset_name);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(2, &self.to_address)?;
        }
        if !self.asset_name.is_empty() {
            os.write_bytes(3, &self.asset_name)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParticipateAssetIssueContract {
        ParticipateAssetIssueContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ParticipateAssetIssueContract| { &m.owner_address },
                    |m: &mut ParticipateAssetIssueContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to_address",
                    |m: &ParticipateAssetIssueContract| { &m.to_address },
                    |m: &mut ParticipateAssetIssueContract| { &mut m.to_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "asset_name",
                    |m: &ParticipateAssetIssueContract| { &m.asset_name },
                    |m: &mut ParticipateAssetIssueContract| { &mut m.asset_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &ParticipateAssetIssueContract| { &m.amount },
                    |m: &mut ParticipateAssetIssueContract| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParticipateAssetIssueContract>(
                    "ParticipateAssetIssueContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParticipateAssetIssueContract {
        static mut instance: ::protobuf::lazy::Lazy<ParticipateAssetIssueContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParticipateAssetIssueContract,
        };
        unsafe {
            instance.get(ParticipateAssetIssueContract::new)
        }
    }
}

impl ::protobuf::Clear for ParticipateAssetIssueContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.to_address.clear();
        self.asset_name.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParticipateAssetIssueContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipateAssetIssueContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FreezeBalanceContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub frozen_balance: i64,
    pub frozen_duration: i64,
    pub resource: ResourceCode,
    pub receiver_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FreezeBalanceContract {
    fn default() -> &'a FreezeBalanceContract {
        <FreezeBalanceContract as ::protobuf::Message>::default_instance()
    }
}

impl FreezeBalanceContract {
    pub fn new() -> FreezeBalanceContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 frozen_balance = 2;


    pub fn get_frozen_balance(&self) -> i64 {
        self.frozen_balance
    }
    pub fn clear_frozen_balance(&mut self) {
        self.frozen_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance(&mut self, v: i64) {
        self.frozen_balance = v;
    }

    // int64 frozen_duration = 3;


    pub fn get_frozen_duration(&self) -> i64 {
        self.frozen_duration
    }
    pub fn clear_frozen_duration(&mut self) {
        self.frozen_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_duration(&mut self, v: i64) {
        self.frozen_duration = v;
    }

    // .protocol.ResourceCode resource = 10;


    pub fn get_resource(&self) -> ResourceCode {
        self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource = ResourceCode::BANDWIDTH;
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ResourceCode) {
        self.resource = v;
    }

    // bytes receiver_address = 15;


    pub fn get_receiver_address(&self) -> &[u8] {
        &self.receiver_address
    }
    pub fn clear_receiver_address(&mut self) {
        self.receiver_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiver_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiver_address
    }

    // Take field
    pub fn take_receiver_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiver_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FreezeBalanceContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_duration = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.resource, 10, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiver_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.frozen_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.frozen_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frozen_duration != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frozen_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resource != ResourceCode::BANDWIDTH {
            my_size += ::protobuf::rt::enum_size(10, self.resource);
        }
        if !self.receiver_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.receiver_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.frozen_balance != 0 {
            os.write_int64(2, self.frozen_balance)?;
        }
        if self.frozen_duration != 0 {
            os.write_int64(3, self.frozen_duration)?;
        }
        if self.resource != ResourceCode::BANDWIDTH {
            os.write_enum(10, self.resource.value())?;
        }
        if !self.receiver_address.is_empty() {
            os.write_bytes(15, &self.receiver_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FreezeBalanceContract {
        FreezeBalanceContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &FreezeBalanceContract| { &m.owner_address },
                    |m: &mut FreezeBalanceContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_balance",
                    |m: &FreezeBalanceContract| { &m.frozen_balance },
                    |m: &mut FreezeBalanceContract| { &mut m.frozen_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_duration",
                    |m: &FreezeBalanceContract| { &m.frozen_duration },
                    |m: &mut FreezeBalanceContract| { &mut m.frozen_duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceCode>>(
                    "resource",
                    |m: &FreezeBalanceContract| { &m.resource },
                    |m: &mut FreezeBalanceContract| { &mut m.resource },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receiver_address",
                    |m: &FreezeBalanceContract| { &m.receiver_address },
                    |m: &mut FreezeBalanceContract| { &mut m.receiver_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FreezeBalanceContract>(
                    "FreezeBalanceContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FreezeBalanceContract {
        static mut instance: ::protobuf::lazy::Lazy<FreezeBalanceContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FreezeBalanceContract,
        };
        unsafe {
            instance.get(FreezeBalanceContract::new)
        }
    }
}

impl ::protobuf::Clear for FreezeBalanceContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.frozen_balance = 0;
        self.frozen_duration = 0;
        self.resource = ResourceCode::BANDWIDTH;
        self.receiver_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FreezeBalanceContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FreezeBalanceContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnfreezeBalanceContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub resource: ResourceCode,
    pub receiver_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnfreezeBalanceContract {
    fn default() -> &'a UnfreezeBalanceContract {
        <UnfreezeBalanceContract as ::protobuf::Message>::default_instance()
    }
}

impl UnfreezeBalanceContract {
    pub fn new() -> UnfreezeBalanceContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // .protocol.ResourceCode resource = 10;


    pub fn get_resource(&self) -> ResourceCode {
        self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource = ResourceCode::BANDWIDTH;
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ResourceCode) {
        self.resource = v;
    }

    // bytes receiver_address = 15;


    pub fn get_receiver_address(&self) -> &[u8] {
        &self.receiver_address
    }
    pub fn clear_receiver_address(&mut self) {
        self.receiver_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiver_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiver_address
    }

    // Take field
    pub fn take_receiver_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiver_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnfreezeBalanceContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.resource, 10, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiver_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.resource != ResourceCode::BANDWIDTH {
            my_size += ::protobuf::rt::enum_size(10, self.resource);
        }
        if !self.receiver_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.receiver_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.resource != ResourceCode::BANDWIDTH {
            os.write_enum(10, self.resource.value())?;
        }
        if !self.receiver_address.is_empty() {
            os.write_bytes(15, &self.receiver_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnfreezeBalanceContract {
        UnfreezeBalanceContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &UnfreezeBalanceContract| { &m.owner_address },
                    |m: &mut UnfreezeBalanceContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceCode>>(
                    "resource",
                    |m: &UnfreezeBalanceContract| { &m.resource },
                    |m: &mut UnfreezeBalanceContract| { &mut m.resource },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receiver_address",
                    |m: &UnfreezeBalanceContract| { &m.receiver_address },
                    |m: &mut UnfreezeBalanceContract| { &mut m.receiver_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnfreezeBalanceContract>(
                    "UnfreezeBalanceContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnfreezeBalanceContract {
        static mut instance: ::protobuf::lazy::Lazy<UnfreezeBalanceContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnfreezeBalanceContract,
        };
        unsafe {
            instance.get(UnfreezeBalanceContract::new)
        }
    }
}

impl ::protobuf::Clear for UnfreezeBalanceContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.resource = ResourceCode::BANDWIDTH;
        self.receiver_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnfreezeBalanceContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnfreezeBalanceContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnfreezeAssetContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnfreezeAssetContract {
    fn default() -> &'a UnfreezeAssetContract {
        <UnfreezeAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl UnfreezeAssetContract {
    pub fn new() -> UnfreezeAssetContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnfreezeAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnfreezeAssetContract {
        UnfreezeAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &UnfreezeAssetContract| { &m.owner_address },
                    |m: &mut UnfreezeAssetContract| { &mut m.owner_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnfreezeAssetContract>(
                    "UnfreezeAssetContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnfreezeAssetContract {
        static mut instance: ::protobuf::lazy::Lazy<UnfreezeAssetContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnfreezeAssetContract,
        };
        unsafe {
            instance.get(UnfreezeAssetContract::new)
        }
    }
}

impl ::protobuf::Clear for UnfreezeAssetContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnfreezeAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnfreezeAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WithdrawBalanceContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WithdrawBalanceContract {
    fn default() -> &'a WithdrawBalanceContract {
        <WithdrawBalanceContract as ::protobuf::Message>::default_instance()
    }
}

impl WithdrawBalanceContract {
    pub fn new() -> WithdrawBalanceContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WithdrawBalanceContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WithdrawBalanceContract {
        WithdrawBalanceContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &WithdrawBalanceContract| { &m.owner_address },
                    |m: &mut WithdrawBalanceContract| { &mut m.owner_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WithdrawBalanceContract>(
                    "WithdrawBalanceContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WithdrawBalanceContract {
        static mut instance: ::protobuf::lazy::Lazy<WithdrawBalanceContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WithdrawBalanceContract,
        };
        unsafe {
            instance.get(WithdrawBalanceContract::new)
        }
    }
}

impl ::protobuf::Clear for WithdrawBalanceContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WithdrawBalanceContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WithdrawBalanceContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateAssetContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub description: ::std::vec::Vec<u8>,
    pub url: ::std::vec::Vec<u8>,
    pub new_limit: i64,
    pub new_public_limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAssetContract {
    fn default() -> &'a UpdateAssetContract {
        <UpdateAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAssetContract {
    pub fn new() -> UpdateAssetContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes description = 2;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }

    // bytes url = 3;


    pub fn get_url(&self) -> &[u8] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.url, ::std::vec::Vec::new())
    }

    // int64 new_limit = 4;


    pub fn get_new_limit(&self) -> i64 {
        self.new_limit
    }
    pub fn clear_new_limit(&mut self) {
        self.new_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_limit(&mut self, v: i64) {
        self.new_limit = v;
    }

    // int64 new_public_limit = 5;


    pub fn get_new_public_limit(&self) -> i64 {
        self.new_public_limit
    }
    pub fn clear_new_public_limit(&mut self) {
        self.new_public_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_public_limit(&mut self, v: i64) {
        self.new_public_limit = v;
    }
}

impl ::protobuf::Message for UpdateAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.new_limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.new_public_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.url);
        }
        if self.new_limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.new_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.new_public_limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.new_public_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(2, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(3, &self.url)?;
        }
        if self.new_limit != 0 {
            os.write_int64(4, self.new_limit)?;
        }
        if self.new_public_limit != 0 {
            os.write_int64(5, self.new_public_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAssetContract {
        UpdateAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &UpdateAssetContract| { &m.owner_address },
                    |m: &mut UpdateAssetContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "description",
                    |m: &UpdateAssetContract| { &m.description },
                    |m: &mut UpdateAssetContract| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "url",
                    |m: &UpdateAssetContract| { &m.url },
                    |m: &mut UpdateAssetContract| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "new_limit",
                    |m: &UpdateAssetContract| { &m.new_limit },
                    |m: &mut UpdateAssetContract| { &mut m.new_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "new_public_limit",
                    |m: &UpdateAssetContract| { &m.new_public_limit },
                    |m: &mut UpdateAssetContract| { &mut m.new_public_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateAssetContract>(
                    "UpdateAssetContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateAssetContract {
        static mut instance: ::protobuf::lazy::Lazy<UpdateAssetContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateAssetContract,
        };
        unsafe {
            instance.get(UpdateAssetContract::new)
        }
    }
}

impl ::protobuf::Clear for UpdateAssetContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.description.clear();
        self.url.clear();
        self.new_limit = 0;
        self.new_public_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposalCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub parameters: ::std::collections::HashMap<i64, i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalCreateContract {
    fn default() -> &'a ProposalCreateContract {
        <ProposalCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl ProposalCreateContract {
    pub fn new() -> ProposalCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.ProposalCreateContract.ParametersEntry parameters = 2;


    pub fn get_parameters(&self) -> &::std::collections::HashMap<i64, i64> {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::collections::HashMap<i64, i64>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::std::collections::HashMap<i64, i64> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::collections::HashMap<i64, i64> {
        ::std::mem::replace(&mut self.parameters, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ProposalCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(2, &self.parameters);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(2, &self.parameters, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalCreateContract {
        ProposalCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ProposalCreateContract| { &m.owner_address },
                    |m: &mut ProposalCreateContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(
                    "parameters",
                    |m: &ProposalCreateContract| { &m.parameters },
                    |m: &mut ProposalCreateContract| { &mut m.parameters },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalCreateContract>(
                    "ProposalCreateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalCreateContract {
        static mut instance: ::protobuf::lazy::Lazy<ProposalCreateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalCreateContract,
        };
        unsafe {
            instance.get(ProposalCreateContract::new)
        }
    }
}

impl ::protobuf::Clear for ProposalCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposalApproveContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub proposal_id: i64,
    pub is_add_approval: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalApproveContract {
    fn default() -> &'a ProposalApproveContract {
        <ProposalApproveContract as ::protobuf::Message>::default_instance()
    }
}

impl ProposalApproveContract {
    pub fn new() -> ProposalApproveContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 proposal_id = 2;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }

    // bool is_add_approval = 3;


    pub fn get_is_add_approval(&self) -> bool {
        self.is_add_approval
    }
    pub fn clear_is_add_approval(&mut self) {
        self.is_add_approval = false;
    }

    // Param is passed by value, moved
    pub fn set_is_add_approval(&mut self, v: bool) {
        self.is_add_approval = v;
    }
}

impl ::protobuf::Message for ProposalApproveContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposal_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_add_approval = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.proposal_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_add_approval != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.proposal_id != 0 {
            os.write_int64(2, self.proposal_id)?;
        }
        if self.is_add_approval != false {
            os.write_bool(3, self.is_add_approval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalApproveContract {
        ProposalApproveContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ProposalApproveContract| { &m.owner_address },
                    |m: &mut ProposalApproveContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "proposal_id",
                    |m: &ProposalApproveContract| { &m.proposal_id },
                    |m: &mut ProposalApproveContract| { &mut m.proposal_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_add_approval",
                    |m: &ProposalApproveContract| { &m.is_add_approval },
                    |m: &mut ProposalApproveContract| { &mut m.is_add_approval },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalApproveContract>(
                    "ProposalApproveContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalApproveContract {
        static mut instance: ::protobuf::lazy::Lazy<ProposalApproveContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalApproveContract,
        };
        unsafe {
            instance.get(ProposalApproveContract::new)
        }
    }
}

impl ::protobuf::Clear for ProposalApproveContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.proposal_id = 0;
        self.is_add_approval = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalApproveContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalApproveContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposalDeleteContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub proposal_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalDeleteContract {
    fn default() -> &'a ProposalDeleteContract {
        <ProposalDeleteContract as ::protobuf::Message>::default_instance()
    }
}

impl ProposalDeleteContract {
    pub fn new() -> ProposalDeleteContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 proposal_id = 2;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }
}

impl ::protobuf::Message for ProposalDeleteContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposal_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.proposal_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.proposal_id != 0 {
            os.write_int64(2, self.proposal_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalDeleteContract {
        ProposalDeleteContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ProposalDeleteContract| { &m.owner_address },
                    |m: &mut ProposalDeleteContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "proposal_id",
                    |m: &ProposalDeleteContract| { &m.proposal_id },
                    |m: &mut ProposalDeleteContract| { &mut m.proposal_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalDeleteContract>(
                    "ProposalDeleteContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalDeleteContract {
        static mut instance: ::protobuf::lazy::Lazy<ProposalDeleteContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalDeleteContract,
        };
        unsafe {
            instance.get(ProposalDeleteContract::new)
        }
    }
}

impl ::protobuf::Clear for ProposalDeleteContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.proposal_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalDeleteContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalDeleteContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSmartContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub new_contract: ::protobuf::SingularPtrField<super::Tron::SmartContract>,
    pub call_token_value: i64,
    pub token_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSmartContract {
    fn default() -> &'a CreateSmartContract {
        <CreateSmartContract as ::protobuf::Message>::default_instance()
    }
}

impl CreateSmartContract {
    pub fn new() -> CreateSmartContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // .protocol.SmartContract new_contract = 2;


    pub fn get_new_contract(&self) -> &super::Tron::SmartContract {
        self.new_contract.as_ref().unwrap_or_else(|| super::Tron::SmartContract::default_instance())
    }
    pub fn clear_new_contract(&mut self) {
        self.new_contract.clear();
    }

    pub fn has_new_contract(&self) -> bool {
        self.new_contract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_contract(&mut self, v: super::Tron::SmartContract) {
        self.new_contract = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_contract(&mut self) -> &mut super::Tron::SmartContract {
        if self.new_contract.is_none() {
            self.new_contract.set_default();
        }
        self.new_contract.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_contract(&mut self) -> super::Tron::SmartContract {
        self.new_contract.take().unwrap_or_else(|| super::Tron::SmartContract::new())
    }

    // int64 call_token_value = 3;


    pub fn get_call_token_value(&self) -> i64 {
        self.call_token_value
    }
    pub fn clear_call_token_value(&mut self) {
        self.call_token_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_token_value(&mut self, v: i64) {
        self.call_token_value = v;
    }

    // int64 token_id = 4;


    pub fn get_token_id(&self) -> i64 {
        self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: i64) {
        self.token_id = v;
    }
}

impl ::protobuf::Message for CreateSmartContract {
    fn is_initialized(&self) -> bool {
        for v in &self.new_contract {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_contract)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_token_value = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.token_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if let Some(ref v) = self.new_contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.call_token_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.call_token_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.token_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.token_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if let Some(ref v) = self.new_contract.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.call_token_value != 0 {
            os.write_int64(3, self.call_token_value)?;
        }
        if self.token_id != 0 {
            os.write_int64(4, self.token_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSmartContract {
        CreateSmartContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &CreateSmartContract| { &m.owner_address },
                    |m: &mut CreateSmartContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::SmartContract>>(
                    "new_contract",
                    |m: &CreateSmartContract| { &m.new_contract },
                    |m: &mut CreateSmartContract| { &mut m.new_contract },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "call_token_value",
                    |m: &CreateSmartContract| { &m.call_token_value },
                    |m: &mut CreateSmartContract| { &mut m.call_token_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "token_id",
                    |m: &CreateSmartContract| { &m.token_id },
                    |m: &mut CreateSmartContract| { &mut m.token_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSmartContract>(
                    "CreateSmartContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSmartContract {
        static mut instance: ::protobuf::lazy::Lazy<CreateSmartContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSmartContract,
        };
        unsafe {
            instance.get(CreateSmartContract::new)
        }
    }
}

impl ::protobuf::Clear for CreateSmartContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.new_contract.clear();
        self.call_token_value = 0;
        self.token_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSmartContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSmartContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TriggerSmartContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub call_value: i64,
    pub data: ::std::vec::Vec<u8>,
    pub call_token_value: i64,
    pub token_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TriggerSmartContract {
    fn default() -> &'a TriggerSmartContract {
        <TriggerSmartContract as ::protobuf::Message>::default_instance()
    }
}

impl TriggerSmartContract {
    pub fn new() -> TriggerSmartContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // int64 call_value = 3;


    pub fn get_call_value(&self) -> i64 {
        self.call_value
    }
    pub fn clear_call_value(&mut self) {
        self.call_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_value(&mut self, v: i64) {
        self.call_value = v;
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 call_token_value = 5;


    pub fn get_call_token_value(&self) -> i64 {
        self.call_token_value
    }
    pub fn clear_call_token_value(&mut self) {
        self.call_token_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_token_value(&mut self, v: i64) {
        self.call_token_value = v;
    }

    // int64 token_id = 6;


    pub fn get_token_id(&self) -> i64 {
        self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: i64) {
        self.token_id = v;
    }
}

impl ::protobuf::Message for TriggerSmartContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_token_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.token_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if self.call_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.call_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if self.call_token_value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.call_token_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.token_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.token_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if self.call_value != 0 {
            os.write_int64(3, self.call_value)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if self.call_token_value != 0 {
            os.write_int64(5, self.call_token_value)?;
        }
        if self.token_id != 0 {
            os.write_int64(6, self.token_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TriggerSmartContract {
        TriggerSmartContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &TriggerSmartContract| { &m.owner_address },
                    |m: &mut TriggerSmartContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract_address",
                    |m: &TriggerSmartContract| { &m.contract_address },
                    |m: &mut TriggerSmartContract| { &mut m.contract_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "call_value",
                    |m: &TriggerSmartContract| { &m.call_value },
                    |m: &mut TriggerSmartContract| { &mut m.call_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &TriggerSmartContract| { &m.data },
                    |m: &mut TriggerSmartContract| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "call_token_value",
                    |m: &TriggerSmartContract| { &m.call_token_value },
                    |m: &mut TriggerSmartContract| { &mut m.call_token_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "token_id",
                    |m: &TriggerSmartContract| { &m.token_id },
                    |m: &mut TriggerSmartContract| { &mut m.token_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TriggerSmartContract>(
                    "TriggerSmartContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TriggerSmartContract {
        static mut instance: ::protobuf::lazy::Lazy<TriggerSmartContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TriggerSmartContract,
        };
        unsafe {
            instance.get(TriggerSmartContract::new)
        }
    }
}

impl ::protobuf::Clear for TriggerSmartContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.call_value = 0;
        self.data.clear();
        self.call_token_value = 0;
        self.token_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TriggerSmartContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TriggerSmartContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuyStorageContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub quant: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyStorageContract {
    fn default() -> &'a BuyStorageContract {
        <BuyStorageContract as ::protobuf::Message>::default_instance()
    }
}

impl BuyStorageContract {
    pub fn new() -> BuyStorageContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 quant = 2;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }
}

impl ::protobuf::Message for BuyStorageContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(2, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.quant != 0 {
            os.write_int64(2, self.quant)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyStorageContract {
        BuyStorageContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &BuyStorageContract| { &m.owner_address },
                    |m: &mut BuyStorageContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "quant",
                    |m: &BuyStorageContract| { &m.quant },
                    |m: &mut BuyStorageContract| { &mut m.quant },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BuyStorageContract>(
                    "BuyStorageContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BuyStorageContract {
        static mut instance: ::protobuf::lazy::Lazy<BuyStorageContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuyStorageContract,
        };
        unsafe {
            instance.get(BuyStorageContract::new)
        }
    }
}

impl ::protobuf::Clear for BuyStorageContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.quant = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyStorageContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyStorageContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuyStorageBytesContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyStorageBytesContract {
    fn default() -> &'a BuyStorageBytesContract {
        <BuyStorageBytesContract as ::protobuf::Message>::default_instance()
    }
}

impl BuyStorageBytesContract {
    pub fn new() -> BuyStorageBytesContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 bytes = 2;


    pub fn get_bytes(&self) -> i64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i64) {
        self.bytes = v;
    }
}

impl ::protobuf::Message for BuyStorageBytesContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.bytes != 0 {
            os.write_int64(2, self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyStorageBytesContract {
        BuyStorageBytesContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &BuyStorageBytesContract| { &m.owner_address },
                    |m: &mut BuyStorageBytesContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytes",
                    |m: &BuyStorageBytesContract| { &m.bytes },
                    |m: &mut BuyStorageBytesContract| { &mut m.bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BuyStorageBytesContract>(
                    "BuyStorageBytesContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BuyStorageBytesContract {
        static mut instance: ::protobuf::lazy::Lazy<BuyStorageBytesContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuyStorageBytesContract,
        };
        unsafe {
            instance.get(BuyStorageBytesContract::new)
        }
    }
}

impl ::protobuf::Clear for BuyStorageBytesContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyStorageBytesContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyStorageBytesContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SellStorageContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub storage_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SellStorageContract {
    fn default() -> &'a SellStorageContract {
        <SellStorageContract as ::protobuf::Message>::default_instance()
    }
}

impl SellStorageContract {
    pub fn new() -> SellStorageContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 storage_bytes = 2;


    pub fn get_storage_bytes(&self) -> i64 {
        self.storage_bytes
    }
    pub fn clear_storage_bytes(&mut self) {
        self.storage_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_bytes(&mut self, v: i64) {
        self.storage_bytes = v;
    }
}

impl ::protobuf::Message for SellStorageContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.storage_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.storage_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.storage_bytes != 0 {
            os.write_int64(2, self.storage_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SellStorageContract {
        SellStorageContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &SellStorageContract| { &m.owner_address },
                    |m: &mut SellStorageContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage_bytes",
                    |m: &SellStorageContract| { &m.storage_bytes },
                    |m: &mut SellStorageContract| { &mut m.storage_bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SellStorageContract>(
                    "SellStorageContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SellStorageContract {
        static mut instance: ::protobuf::lazy::Lazy<SellStorageContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SellStorageContract,
        };
        unsafe {
            instance.get(SellStorageContract::new)
        }
    }
}

impl ::protobuf::Clear for SellStorageContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.storage_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SellStorageContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SellStorageContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExchangeCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub first_token_id: ::std::vec::Vec<u8>,
    pub first_token_balance: i64,
    pub second_token_id: ::std::vec::Vec<u8>,
    pub second_token_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeCreateContract {
    fn default() -> &'a ExchangeCreateContract {
        <ExchangeCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeCreateContract {
    pub fn new() -> ExchangeCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes first_token_id = 2;


    pub fn get_first_token_id(&self) -> &[u8] {
        &self.first_token_id
    }
    pub fn clear_first_token_id(&mut self) {
        self.first_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_first_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.first_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.first_token_id
    }

    // Take field
    pub fn take_first_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.first_token_id, ::std::vec::Vec::new())
    }

    // int64 first_token_balance = 3;


    pub fn get_first_token_balance(&self) -> i64 {
        self.first_token_balance
    }
    pub fn clear_first_token_balance(&mut self) {
        self.first_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_token_balance(&mut self, v: i64) {
        self.first_token_balance = v;
    }

    // bytes second_token_id = 4;


    pub fn get_second_token_id(&self) -> &[u8] {
        &self.second_token_id
    }
    pub fn clear_second_token_id(&mut self) {
        self.second_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_second_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.second_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_second_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.second_token_id
    }

    // Take field
    pub fn take_second_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.second_token_id, ::std::vec::Vec::new())
    }

    // int64 second_token_balance = 5;


    pub fn get_second_token_balance(&self) -> i64 {
        self.second_token_balance
    }
    pub fn clear_second_token_balance(&mut self) {
        self.second_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_second_token_balance(&mut self, v: i64) {
        self.second_token_balance = v;
    }
}

impl ::protobuf::Message for ExchangeCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.first_token_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.first_token_balance = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.second_token_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.second_token_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.first_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.first_token_id);
        }
        if self.first_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.first_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.second_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.second_token_id);
        }
        if self.second_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.second_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.first_token_id.is_empty() {
            os.write_bytes(2, &self.first_token_id)?;
        }
        if self.first_token_balance != 0 {
            os.write_int64(3, self.first_token_balance)?;
        }
        if !self.second_token_id.is_empty() {
            os.write_bytes(4, &self.second_token_id)?;
        }
        if self.second_token_balance != 0 {
            os.write_int64(5, self.second_token_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeCreateContract {
        ExchangeCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ExchangeCreateContract| { &m.owner_address },
                    |m: &mut ExchangeCreateContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "first_token_id",
                    |m: &ExchangeCreateContract| { &m.first_token_id },
                    |m: &mut ExchangeCreateContract| { &mut m.first_token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "first_token_balance",
                    |m: &ExchangeCreateContract| { &m.first_token_balance },
                    |m: &mut ExchangeCreateContract| { &mut m.first_token_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "second_token_id",
                    |m: &ExchangeCreateContract| { &m.second_token_id },
                    |m: &mut ExchangeCreateContract| { &mut m.second_token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "second_token_balance",
                    |m: &ExchangeCreateContract| { &m.second_token_balance },
                    |m: &mut ExchangeCreateContract| { &mut m.second_token_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExchangeCreateContract>(
                    "ExchangeCreateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExchangeCreateContract {
        static mut instance: ::protobuf::lazy::Lazy<ExchangeCreateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExchangeCreateContract,
        };
        unsafe {
            instance.get(ExchangeCreateContract::new)
        }
    }
}

impl ::protobuf::Clear for ExchangeCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.first_token_id.clear();
        self.first_token_balance = 0;
        self.second_token_id.clear();
        self.second_token_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExchangeInjectContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub exchange_id: i64,
    pub token_id: ::std::vec::Vec<u8>,
    pub quant: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeInjectContract {
    fn default() -> &'a ExchangeInjectContract {
        <ExchangeInjectContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeInjectContract {
    pub fn new() -> ExchangeInjectContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 exchange_id = 2;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes token_id = 3;


    pub fn get_token_id(&self) -> &[u8] {
        &self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token_id
    }

    // Take field
    pub fn take_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token_id, ::std::vec::Vec::new())
    }

    // int64 quant = 4;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }
}

impl ::protobuf::Message for ExchangeInjectContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token_id);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(4, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(2, self.exchange_id)?;
        }
        if !self.token_id.is_empty() {
            os.write_bytes(3, &self.token_id)?;
        }
        if self.quant != 0 {
            os.write_int64(4, self.quant)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeInjectContract {
        ExchangeInjectContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ExchangeInjectContract| { &m.owner_address },
                    |m: &mut ExchangeInjectContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_id",
                    |m: &ExchangeInjectContract| { &m.exchange_id },
                    |m: &mut ExchangeInjectContract| { &mut m.exchange_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "token_id",
                    |m: &ExchangeInjectContract| { &m.token_id },
                    |m: &mut ExchangeInjectContract| { &mut m.token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "quant",
                    |m: &ExchangeInjectContract| { &m.quant },
                    |m: &mut ExchangeInjectContract| { &mut m.quant },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExchangeInjectContract>(
                    "ExchangeInjectContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExchangeInjectContract {
        static mut instance: ::protobuf::lazy::Lazy<ExchangeInjectContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExchangeInjectContract,
        };
        unsafe {
            instance.get(ExchangeInjectContract::new)
        }
    }
}

impl ::protobuf::Clear for ExchangeInjectContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.exchange_id = 0;
        self.token_id.clear();
        self.quant = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeInjectContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeInjectContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExchangeWithdrawContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub exchange_id: i64,
    pub token_id: ::std::vec::Vec<u8>,
    pub quant: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeWithdrawContract {
    fn default() -> &'a ExchangeWithdrawContract {
        <ExchangeWithdrawContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeWithdrawContract {
    pub fn new() -> ExchangeWithdrawContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 exchange_id = 2;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes token_id = 3;


    pub fn get_token_id(&self) -> &[u8] {
        &self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token_id
    }

    // Take field
    pub fn take_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token_id, ::std::vec::Vec::new())
    }

    // int64 quant = 4;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }
}

impl ::protobuf::Message for ExchangeWithdrawContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token_id);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(4, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(2, self.exchange_id)?;
        }
        if !self.token_id.is_empty() {
            os.write_bytes(3, &self.token_id)?;
        }
        if self.quant != 0 {
            os.write_int64(4, self.quant)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeWithdrawContract {
        ExchangeWithdrawContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ExchangeWithdrawContract| { &m.owner_address },
                    |m: &mut ExchangeWithdrawContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_id",
                    |m: &ExchangeWithdrawContract| { &m.exchange_id },
                    |m: &mut ExchangeWithdrawContract| { &mut m.exchange_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "token_id",
                    |m: &ExchangeWithdrawContract| { &m.token_id },
                    |m: &mut ExchangeWithdrawContract| { &mut m.token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "quant",
                    |m: &ExchangeWithdrawContract| { &m.quant },
                    |m: &mut ExchangeWithdrawContract| { &mut m.quant },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExchangeWithdrawContract>(
                    "ExchangeWithdrawContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExchangeWithdrawContract {
        static mut instance: ::protobuf::lazy::Lazy<ExchangeWithdrawContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExchangeWithdrawContract,
        };
        unsafe {
            instance.get(ExchangeWithdrawContract::new)
        }
    }
}

impl ::protobuf::Clear for ExchangeWithdrawContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.exchange_id = 0;
        self.token_id.clear();
        self.quant = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeWithdrawContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeWithdrawContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExchangeTransactionContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub exchange_id: i64,
    pub token_id: ::std::vec::Vec<u8>,
    pub quant: i64,
    pub expected: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeTransactionContract {
    fn default() -> &'a ExchangeTransactionContract {
        <ExchangeTransactionContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeTransactionContract {
    pub fn new() -> ExchangeTransactionContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 exchange_id = 2;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes token_id = 3;


    pub fn get_token_id(&self) -> &[u8] {
        &self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token_id
    }

    // Take field
    pub fn take_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token_id, ::std::vec::Vec::new())
    }

    // int64 quant = 4;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }

    // int64 expected = 5;


    pub fn get_expected(&self) -> i64 {
        self.expected
    }
    pub fn clear_expected(&mut self) {
        self.expected = 0;
    }

    // Param is passed by value, moved
    pub fn set_expected(&mut self, v: i64) {
        self.expected = v;
    }
}

impl ::protobuf::Message for ExchangeTransactionContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token_id);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(4, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expected != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expected, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(2, self.exchange_id)?;
        }
        if !self.token_id.is_empty() {
            os.write_bytes(3, &self.token_id)?;
        }
        if self.quant != 0 {
            os.write_int64(4, self.quant)?;
        }
        if self.expected != 0 {
            os.write_int64(5, self.expected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeTransactionContract {
        ExchangeTransactionContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &ExchangeTransactionContract| { &m.owner_address },
                    |m: &mut ExchangeTransactionContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "exchange_id",
                    |m: &ExchangeTransactionContract| { &m.exchange_id },
                    |m: &mut ExchangeTransactionContract| { &mut m.exchange_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "token_id",
                    |m: &ExchangeTransactionContract| { &m.token_id },
                    |m: &mut ExchangeTransactionContract| { &mut m.token_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "quant",
                    |m: &ExchangeTransactionContract| { &m.quant },
                    |m: &mut ExchangeTransactionContract| { &mut m.quant },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expected",
                    |m: &ExchangeTransactionContract| { &m.expected },
                    |m: &mut ExchangeTransactionContract| { &mut m.expected },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExchangeTransactionContract>(
                    "ExchangeTransactionContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExchangeTransactionContract {
        static mut instance: ::protobuf::lazy::Lazy<ExchangeTransactionContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExchangeTransactionContract,
        };
        unsafe {
            instance.get(ExchangeTransactionContract::new)
        }
    }
}

impl ::protobuf::Clear for ExchangeTransactionContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.exchange_id = 0;
        self.token_id.clear();
        self.quant = 0;
        self.expected = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeTransactionContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeTransactionContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountPermissionUpdateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub owner: ::protobuf::SingularPtrField<super::Tron::Permission>,
    pub witness: ::protobuf::SingularPtrField<super::Tron::Permission>,
    pub actives: ::protobuf::RepeatedField<super::Tron::Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountPermissionUpdateContract {
    fn default() -> &'a AccountPermissionUpdateContract {
        <AccountPermissionUpdateContract as ::protobuf::Message>::default_instance()
    }
}

impl AccountPermissionUpdateContract {
    pub fn new() -> AccountPermissionUpdateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // .protocol.Permission owner = 2;


    pub fn get_owner(&self) -> &super::Tron::Permission {
        self.owner.as_ref().unwrap_or_else(|| super::Tron::Permission::default_instance())
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: super::Tron::Permission) {
        self.owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut super::Tron::Permission {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> super::Tron::Permission {
        self.owner.take().unwrap_or_else(|| super::Tron::Permission::new())
    }

    // .protocol.Permission witness = 3;


    pub fn get_witness(&self) -> &super::Tron::Permission {
        self.witness.as_ref().unwrap_or_else(|| super::Tron::Permission::default_instance())
    }
    pub fn clear_witness(&mut self) {
        self.witness.clear();
    }

    pub fn has_witness(&self) -> bool {
        self.witness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_witness(&mut self, v: super::Tron::Permission) {
        self.witness = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness(&mut self) -> &mut super::Tron::Permission {
        if self.witness.is_none() {
            self.witness.set_default();
        }
        self.witness.as_mut().unwrap()
    }

    // Take field
    pub fn take_witness(&mut self) -> super::Tron::Permission {
        self.witness.take().unwrap_or_else(|| super::Tron::Permission::new())
    }

    // repeated .protocol.Permission actives = 4;


    pub fn get_actives(&self) -> &[super::Tron::Permission] {
        &self.actives
    }
    pub fn clear_actives(&mut self) {
        self.actives.clear();
    }

    // Param is passed by value, moved
    pub fn set_actives(&mut self, v: ::protobuf::RepeatedField<super::Tron::Permission>) {
        self.actives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actives(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Permission> {
        &mut self.actives
    }

    // Take field
    pub fn take_actives(&mut self) -> ::protobuf::RepeatedField<super::Tron::Permission> {
        ::std::mem::replace(&mut self.actives, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AccountPermissionUpdateContract {
    fn is_initialized(&self) -> bool {
        for v in &self.owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.witness {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.witness)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actives)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if let Some(ref v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.witness.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.actives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.witness.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.actives {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountPermissionUpdateContract {
        AccountPermissionUpdateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner_address",
                    |m: &AccountPermissionUpdateContract| { &m.owner_address },
                    |m: &mut AccountPermissionUpdateContract| { &mut m.owner_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                    "owner",
                    |m: &AccountPermissionUpdateContract| { &m.owner },
                    |m: &mut AccountPermissionUpdateContract| { &mut m.owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                    "witness",
                    |m: &AccountPermissionUpdateContract| { &m.witness },
                    |m: &mut AccountPermissionUpdateContract| { &mut m.witness },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                    "actives",
                    |m: &AccountPermissionUpdateContract| { &m.actives },
                    |m: &mut AccountPermissionUpdateContract| { &mut m.actives },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountPermissionUpdateContract>(
                    "AccountPermissionUpdateContract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountPermissionUpdateContract {
        static mut instance: ::protobuf::lazy::Lazy<AccountPermissionUpdateContract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountPermissionUpdateContract,
        };
        unsafe {
            instance.get(AccountPermissionUpdateContract::new)
        }
    }
}

impl ::protobuf::Clear for AccountPermissionUpdateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.owner.clear();
        self.witness.clear();
        self.actives.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountPermissionUpdateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountPermissionUpdateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResourceCode {
    BANDWIDTH = 0,
    ENERGY = 1,
}

impl ::protobuf::ProtobufEnum for ResourceCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceCode> {
        match value {
            0 => ::std::option::Option::Some(ResourceCode::BANDWIDTH),
            1 => ::std::option::Option::Some(ResourceCode::ENERGY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResourceCode] = &[
            ResourceCode::BANDWIDTH,
            ResourceCode::ENERGY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResourceCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResourceCode {
}

impl ::std::default::Default for ResourceCode {
    fn default() -> Self {
        ResourceCode::BANDWIDTH
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13core/Contract.proto\x12\x08protocol\x1a\x0fcore/Tron.proto\"\x90\
    \x01\n\x15AccountCreateContract\x12#\n\rowner_address\x18\x01\x20\x01(\
    \x0cR\x0cownerAddress\x12'\n\x0faccount_address\x18\x02\x20\x01(\x0cR\
    \x0eaccountAddress\x12)\n\x04type\x18\x03\x20\x01(\x0e2\x15.protocol.Acc\
    ountTypeR\x04type\"_\n\x15AccountUpdateContract\x12!\n\x0caccount_name\
    \x18\x01\x20\x01(\x0cR\x0baccountName\x12#\n\rowner_address\x18\x02\x20\
    \x01(\x0cR\x0cownerAddress\"Z\n\x14SetAccountIdContract\x12\x1d\n\naccou\
    nt_id\x18\x01\x20\x01(\x0cR\taccountId\x12#\n\rowner_address\x18\x02\x20\
    \x01(\x0cR\x0cownerAddress\"n\n\x10TransferContract\x12#\n\rowner_addres\
    s\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\n\nto_address\x18\x02\
    \x20\x01(\x0cR\ttoAddress\x12\x16\n\x06amount\x18\x03\x20\x01(\x03R\x06a\
    mount\"\x92\x01\n\x15TransferAssetContract\x12\x1d\n\nasset_name\x18\x01\
    \x20\x01(\x0cR\tassetName\x12#\n\rowner_address\x18\x02\x20\x01(\x0cR\
    \x0cownerAddress\x12\x1d\n\nto_address\x18\x03\x20\x01(\x0cR\ttoAddress\
    \x12\x16\n\x06amount\x18\x04\x20\x01(\x03R\x06amount\"\x8b\x01\n\x11Vote\
    AssetContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddres\
    s\x12!\n\x0cvote_address\x18\x02\x20\x03(\x0cR\x0bvoteAddress\x12\x18\n\
    \x07support\x18\x03\x20\x01(\x08R\x07support\x12\x14\n\x05count\x18\x05\
    \x20\x01(\x05R\x05count\"\xd8\x01\n\x13VoteWitnessContract\x12#\n\rowner\
    _address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x128\n\x05votes\x18\x02\
    \x20\x03(\x0b2\".protocol.VoteWitnessContract.VoteR\x05votes\x12\x18\n\
    \x07support\x18\x03\x20\x01(\x08R\x07support\x1aH\n\x04Vote\x12!\n\x0cvo\
    te_address\x18\x01\x20\x01(\x0cR\x0bvoteAddress\x12\x1d\n\nvote_count\
    \x18\x02\x20\x01(\x03R\tvoteCount\"\xaa\x01\n\x15UpdateSettingContract\
    \x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12)\n\x10c\
    ontract_address\x18\x02\x20\x01(\x0cR\x0fcontractAddress\x12A\n\x1dconsu\
    me_user_resource_percent\x18\x03\x20\x01(\x03R\x1aconsumeUserResourcePer\
    cent\"\x9b\x01\n\x19UpdateEnergyLimitContract\x12#\n\rowner_address\x18\
    \x01\x20\x01(\x0cR\x0cownerAddress\x12)\n\x10contract_address\x18\x02\
    \x20\x01(\x0cR\x0fcontractAddress\x12.\n\x13origin_energy_limit\x18\x03\
    \x20\x01(\x03R\x11originEnergyLimit\"b\n\x10ClearABIContract\x12#\n\rown\
    er_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12)\n\x10contract_addr\
    ess\x18\x02\x20\x01(\x0cR\x0fcontractAddress\"N\n\x15WitnessCreateContra\
    ct\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x10\n\
    \x03url\x18\x02\x20\x01(\x0cR\x03url\"[\n\x15WitnessUpdateContract\x12#\
    \n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\n\nupdat\
    e_url\x18\x0c\x20\x01(\x0cR\tupdateUrl\"\x91\x06\n\x12AssetIssueContract\
    \x12\x0e\n\x02id\x18)\x20\x01(\tR\x02id\x12#\n\rowner_address\x18\x01\
    \x20\x01(\x0cR\x0cownerAddress\x12\x12\n\x04name\x18\x02\x20\x01(\x0cR\
    \x04name\x12\x12\n\x04abbr\x18\x03\x20\x01(\x0cR\x04abbr\x12!\n\x0ctotal\
    _supply\x18\x04\x20\x01(\x03R\x0btotalSupply\x12N\n\rfrozen_supply\x18\
    \x05\x20\x03(\x0b2).protocol.AssetIssueContract.FrozenSupplyR\x0cfrozenS\
    upply\x12\x17\n\x07trx_num\x18\x06\x20\x01(\x05R\x06trxNum\x12\x1c\n\tpr\
    ecision\x18\x07\x20\x01(\x05R\tprecision\x12\x10\n\x03num\x18\x08\x20\
    \x01(\x05R\x03num\x12\x1d\n\nstart_time\x18\t\x20\x01(\x03R\tstartTime\
    \x12\x19\n\x08end_time\x18\n\x20\x01(\x03R\x07endTime\x12\x14\n\x05order\
    \x18\x0b\x20\x01(\x03R\x05order\x12\x1d\n\nvote_score\x18\x10\x20\x01(\
    \x05R\tvoteScore\x12\x20\n\x0bdescription\x18\x14\x20\x01(\x0cR\x0bdescr\
    iption\x12\x10\n\x03url\x18\x15\x20\x01(\x0cR\x03url\x12/\n\x14free_asse\
    t_net_limit\x18\x16\x20\x01(\x03R\x11freeAssetNetLimit\x12<\n\x1bpublic_\
    free_asset_net_limit\x18\x17\x20\x01(\x03R\x17publicFreeAssetNetLimit\
    \x12<\n\x1bpublic_free_asset_net_usage\x18\x18\x20\x01(\x03R\x17publicFr\
    eeAssetNetUsage\x12<\n\x1bpublic_latest_free_net_time\x18\x19\x20\x01(\
    \x03R\x17publicLatestFreeNetTime\x1aT\n\x0cFrozenSupply\x12#\n\rfrozen_a\
    mount\x18\x01\x20\x01(\x03R\x0cfrozenAmount\x12\x1f\n\x0bfrozen_days\x18\
    \x02\x20\x01(\x03R\nfrozenDays\"\x9a\x01\n\x1dParticipateAssetIssueContr\
    act\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\
    \n\nto_address\x18\x02\x20\x01(\x0cR\ttoAddress\x12\x1d\n\nasset_name\
    \x18\x03\x20\x01(\x0cR\tassetName\x12\x16\n\x06amount\x18\x04\x20\x01(\
    \x03R\x06amount\"\xeb\x01\n\x15FreezeBalanceContract\x12#\n\rowner_addre\
    ss\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12%\n\x0efrozen_balance\x18\
    \x02\x20\x01(\x03R\rfrozenBalance\x12'\n\x0ffrozen_duration\x18\x03\x20\
    \x01(\x03R\x0efrozenDuration\x122\n\x08resource\x18\n\x20\x01(\x0e2\x16.\
    protocol.ResourceCodeR\x08resource\x12)\n\x10receiver_address\x18\x0f\
    \x20\x01(\x0cR\x0freceiverAddress\"\x9d\x01\n\x17UnfreezeBalanceContract\
    \x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x122\n\x08r\
    esource\x18\n\x20\x01(\x0e2\x16.protocol.ResourceCodeR\x08resource\x12)\
    \n\x10receiver_address\x18\x0f\x20\x01(\x0cR\x0freceiverAddress\"<\n\x15\
    UnfreezeAssetContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cown\
    erAddress\">\n\x17WithdrawBalanceContract\x12#\n\rowner_address\x18\x01\
    \x20\x01(\x0cR\x0cownerAddress\"\xb5\x01\n\x13UpdateAssetContract\x12#\n\
    \rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x20\n\x0bdescr\
    iption\x18\x02\x20\x01(\x0cR\x0bdescription\x12\x10\n\x03url\x18\x03\x20\
    \x01(\x0cR\x03url\x12\x1b\n\tnew_limit\x18\x04\x20\x01(\x03R\x08newLimit\
    \x12(\n\x10new_public_limit\x18\x05\x20\x01(\x03R\x0enewPublicLimit\"\
    \xce\x01\n\x16ProposalCreateContract\x12#\n\rowner_address\x18\x01\x20\
    \x01(\x0cR\x0cownerAddress\x12P\n\nparameters\x18\x02\x20\x03(\x0b20.pro\
    tocol.ProposalCreateContract.ParametersEntryR\nparameters\x1a=\n\x0fPara\
    metersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"\x87\x01\n\x17ProposalApp\
    roveContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\
    \x12\x1f\n\x0bproposal_id\x18\x02\x20\x01(\x03R\nproposalId\x12&\n\x0fis\
    _add_approval\x18\x03\x20\x01(\x08R\risAddApproval\"^\n\x16ProposalDelet\
    eContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\
    \x12\x1f\n\x0bproposal_id\x18\x02\x20\x01(\x03R\nproposalId\"\xbb\x01\n\
    \x13CreateSmartContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0co\
    wnerAddress\x12:\n\x0cnew_contract\x18\x02\x20\x01(\x0b2\x17.protocol.Sm\
    artContractR\x0bnewContract\x12(\n\x10call_token_value\x18\x03\x20\x01(\
    \x03R\x0ecallTokenValue\x12\x19\n\x08token_id\x18\x04\x20\x01(\x03R\x07t\
    okenId\"\xde\x01\n\x14TriggerSmartContract\x12#\n\rowner_address\x18\x01\
    \x20\x01(\x0cR\x0cownerAddress\x12)\n\x10contract_address\x18\x02\x20\
    \x01(\x0cR\x0fcontractAddress\x12\x1d\n\ncall_value\x18\x03\x20\x01(\x03\
    R\tcallValue\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\x12(\n\x10c\
    all_token_value\x18\x05\x20\x01(\x03R\x0ecallTokenValue\x12\x19\n\x08tok\
    en_id\x18\x06\x20\x01(\x03R\x07tokenId\"O\n\x12BuyStorageContract\x12#\n\
    \rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x14\n\x05quant\
    \x18\x02\x20\x01(\x03R\x05quant\"T\n\x17BuyStorageBytesContract\x12#\n\r\
    owner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x14\n\x05bytes\
    \x18\x02\x20\x01(\x03R\x05bytes\"_\n\x13SellStorageContract\x12#\n\rowne\
    r_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12#\n\rstorage_bytes\
    \x18\x02\x20\x01(\x03R\x0cstorageBytes\"\xed\x01\n\x16ExchangeCreateCont\
    ract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12$\n\
    \x0efirst_token_id\x18\x02\x20\x01(\x0cR\x0cfirstTokenId\x12.\n\x13first\
    _token_balance\x18\x03\x20\x01(\x03R\x11firstTokenBalance\x12&\n\x0fseco\
    nd_token_id\x18\x04\x20\x01(\x0cR\rsecondTokenId\x120\n\x14second_token_\
    balance\x18\x05\x20\x01(\x03R\x12secondTokenBalance\"\x8f\x01\n\x16Excha\
    ngeInjectContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAd\
    dress\x12\x1f\n\x0bexchange_id\x18\x02\x20\x01(\x03R\nexchangeId\x12\x19\
    \n\x08token_id\x18\x03\x20\x01(\x0cR\x07tokenId\x12\x14\n\x05quant\x18\
    \x04\x20\x01(\x03R\x05quant\"\x91\x01\n\x18ExchangeWithdrawContract\x12#\
    \n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1f\n\x0bexc\
    hange_id\x18\x02\x20\x01(\x03R\nexchangeId\x12\x19\n\x08token_id\x18\x03\
    \x20\x01(\x0cR\x07tokenId\x12\x14\n\x05quant\x18\x04\x20\x01(\x03R\x05qu\
    ant\"\xb0\x01\n\x1bExchangeTransactionContract\x12#\n\rowner_address\x18\
    \x01\x20\x01(\x0cR\x0cownerAddress\x12\x1f\n\x0bexchange_id\x18\x02\x20\
    \x01(\x03R\nexchangeId\x12\x19\n\x08token_id\x18\x03\x20\x01(\x0cR\x07to\
    kenId\x12\x14\n\x05quant\x18\x04\x20\x01(\x03R\x05quant\x12\x1a\n\x08exp\
    ected\x18\x05\x20\x01(\x03R\x08expected\"\xd2\x01\n\x1fAccountPermission\
    UpdateContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddre\
    ss\x12*\n\x05owner\x18\x02\x20\x01(\x0b2\x14.protocol.PermissionR\x05own\
    er\x12.\n\x07witness\x18\x03\x20\x01(\x0b2\x14.protocol.PermissionR\x07w\
    itness\x12.\n\x07actives\x18\x04\x20\x03(\x0b2\x14.protocol.PermissionR\
    \x07actives*)\n\x0cResourceCode\x12\r\n\tBANDWIDTH\x10\0\x12\n\n\x06ENER\
    GY\x10\x01BF\n\x0forg.tron.protosB\x08ContractZ)github.com/tronprotocol/\
    grpc-gateway/coreJ\x8dX\n\x07\x12\x05\x0f\0\xff\x01\x01\n\xf4\x04\n\x01\
    \x0c\x12\x03\x0f\0\x122\xe9\x04\n\x20java-tron\x20is\x20free\x20software\
    :\x20you\x20can\x20redistribute\x20it\x20and/or\x20modify\n\x20it\x20und\
    er\x20the\x20terms\x20of\x20the\x20GNU\x20General\x20Public\x20License\
    \x20as\x20published\x20by\n\x20the\x20Free\x20Software\x20Foundation,\
    \x20either\x20version\x203\x20of\x20the\x20License,\x20or\n\x20(at\x20yo\
    ur\x20option)\x20any\x20later\x20version.\n\n\x20java-tron\x20is\x20dist\
    ributed\x20in\x20the\x20hope\x20that\x20it\x20will\x20be\x20useful,\n\
    \x20but\x20WITHOUT\x20ANY\x20WARRANTY;\x20without\x20even\x20the\x20impl\
    ied\x20warranty\x20of\n\x20MERCHANTABILITY\x20or\x20FITNESS\x20FOR\x20A\
    \x20PARTICULAR\x20PURPOSE.\x20\x20See\x20the\n\x20GNU\x20General\x20Publ\
    ic\x20License\x20for\x20more\x20details.\n\n\x20You\x20should\x20have\
    \x20received\x20a\x20copy\x20of\x20the\x20GNU\x20General\x20Public\x20Li\
    cense\n\x20along\x20with\x20this\x20program.\x20\x20If\x20not,\x20see\
    \x20<http://www.gnu.org/licenses/>.\n\n\x08\n\x01\x02\x12\x03\x11\x08\
    \x10\n\x08\n\x01\x08\x12\x03\x13\0(\nH\n\x02\x08\x01\x12\x03\x13\0(\"=Sp\
    ecify\x20the\x20name\x20of\x20the\x20package\x20that\x20generated\x20the\
    \x20Java\x20file\n\n\x08\n\x01\x08\x12\x03\x14\0)\n=\n\x02\x08\x08\x12\
    \x03\x14\0)\"2Specify\x20the\x20class\x20name\x20of\x20the\x20generated\
    \x20Java\x20file\n\n\x08\n\x01\x08\x12\x03\x15\0@\n\t\n\x02\x08\x0b\x12\
    \x03\x15\0@\n\t\n\x02\x03\0\x12\x03\x17\x07\x18\n\n\n\x02\x04\0\x12\x04\
    \x19\0\x1d\x01\n\n\n\x03\x04\0\x01\x12\x03\x19\x08\x1d\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03\x1a\x02\x1a\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x1a\x02\x19\
    \x1f\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x1a\x02\x07\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\x1a\x08\x15\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1a\
    \x18\x19\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x1b\x02\x1c\n\r\n\x05\x04\0\
    \x02\x01\x04\x12\x04\x1b\x02\x1a\x1a\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\x1b\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x1b\x08\x17\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03\x1b\x1a\x1b\n\x0b\n\x04\x04\0\x02\x02\
    \x12\x03\x1c\x02\x17\n\r\n\x05\x04\0\x02\x02\x04\x12\x04\x1c\x02\x1b\x1c\
    \n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x1c\x02\r\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x1c\x0e\x12\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1c\
    \x15\x16\nB\n\x02\x04\x01\x12\x04\x20\0#\x01\x1a6\x20Update\x20account\
    \x20name.\x20Account\x20name\x20is\x20not\x20unique\x20now.\n\n\n\n\x03\
    \x04\x01\x01\x12\x03\x20\x08\x1d\n\x0b\n\x04\x04\x01\x02\0\x12\x03!\x02\
    \x19\n\r\n\x05\x04\x01\x02\0\x04\x12\x04!\x02\x20\x1f\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03!\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03!\
    \x08\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03!\x17\x18\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03\"\x02\x1a\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\"\
    \x02!\x19\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\"\x02\x07\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03\"\x08\x15\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03\"\x18\x19\na\n\x02\x04\x02\x12\x04&\0)\x01\x1aU\x20Set\x20accou\
    nt\x20id\x20if\x20the\x20account\x20has\x20no\x20id.\x20Account\x20id\
    \x20is\x20unique\x20and\x20case\x20insensitive.\n\n\n\n\x03\x04\x02\x01\
    \x12\x03&\x08\x1c\n\x0b\n\x04\x04\x02\x02\0\x12\x03'\x02\x17\n\r\n\x05\
    \x04\x02\x02\0\x04\x12\x04'\x02&\x1e\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x03'\x02\x07\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03'\x08\x12\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x03'\x15\x16\n\x0b\n\x04\x04\x02\x02\x01\x12\x03(\
    \x02\x1a\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04(\x02'\x17\n\x0c\n\x05\x04\
    \x02\x02\x01\x05\x12\x03(\x02\x07\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x03(\x08\x15\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03(\x18\x19\n\n\n\x02\
    \x04\x03\x12\x04+\0/\x01\n\n\n\x03\x04\x03\x01\x12\x03+\x08\x18\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03,\x02\x1a\n\r\n\x05\x04\x03\x02\0\x04\x12\x04,\
    \x02+\x1a\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03,\x02\x07\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03,\x08\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03,\
    \x18\x19\n\x0b\n\x04\x04\x03\x02\x01\x12\x03-\x02\x17\n\r\n\x05\x04\x03\
    \x02\x01\x04\x12\x04-\x02,\x1a\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03-\
    \x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03-\x08\x12\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x03-\x15\x16\n\x0b\n\x04\x04\x03\x02\x02\x12\
    \x03.\x02\x13\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04.\x02-\x17\n\x0c\n\
    \x05\x04\x03\x02\x02\x05\x12\x03.\x02\x07\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x03.\x08\x0e\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03.\x11\x12\n\
    \n\n\x02\x04\x04\x12\x041\06\x01\n\n\n\x03\x04\x04\x01\x12\x031\x08\x1d\
    \n\x9f\x01\n\x04\x04\x04\x02\0\x12\x032\x02\x17\"\x91\x01\x20this\x20fie\
    ld\x20is\x20token\x20name\x20before\x20the\x20proposal\x20ALLOW_SAME_TOK\
    EN_NAME\x20is\x20active,\x20otherwise\x20it\x20is\x20token\x20id\x20and\
    \x20token\x20is\x20should\x20be\x20in\x20string\x20format.\n\n\r\n\x05\
    \x04\x04\x02\0\x04\x12\x042\x021\x1f\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x032\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x032\x08\x12\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x032\x15\x16\n\x0b\n\x04\x04\x04\x02\x01\x12\x033\
    \x02\x1a\n\r\n\x05\x04\x04\x02\x01\x04\x12\x043\x022\x17\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x033\x02\x07\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x033\x08\x15\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x033\x18\x19\n\x0b\n\
    \x04\x04\x04\x02\x02\x12\x034\x02\x17\n\r\n\x05\x04\x04\x02\x02\x04\x12\
    \x044\x023\x1a\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x034\x02\x07\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x034\x08\x12\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x034\x15\x16\n\x0b\n\x04\x04\x04\x02\x03\x12\x035\x02\x13\n\r\n\
    \x05\x04\x04\x02\x03\x04\x12\x045\x024\x17\n\x0c\n\x05\x04\x04\x02\x03\
    \x05\x12\x035\x02\x07\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x035\x08\x0e\n\
    \x0c\n\x05\x04\x04\x02\x03\x03\x12\x035\x11\x12\n\n\n\x02\x04\x05\x12\
    \x049\0>\x01\n\n\n\x03\x04\x05\x01\x12\x039\x08\x19\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03:\x02\x1a\n\r\n\x05\x04\x05\x02\0\x04\x12\x04:\x029\x1b\n\
    \x0c\n\x05\x04\x05\x02\0\x05\x12\x03:\x02\x07\n\x0c\n\x05\x04\x05\x02\0\
    \x01\x12\x03:\x08\x15\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03:\x18\x19\n\
    \x0b\n\x04\x04\x05\x02\x01\x12\x03;\x02\"\n\x0c\n\x05\x04\x05\x02\x01\
    \x04\x12\x03;\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03;\x0b\x10\n\
    \x0c\n\x05\x04\x05\x02\x01\x01\x12\x03;\x11\x1d\n\x0c\n\x05\x04\x05\x02\
    \x01\x03\x12\x03;\x20!\n\x0b\n\x04\x04\x05\x02\x02\x12\x03<\x02\x13\n\r\
    \n\x05\x04\x05\x02\x02\x04\x12\x04<\x02;\"\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x03<\x02\x06\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03<\x07\x0e\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03<\x11\x12\n\x0b\n\x04\x04\x05\x02\
    \x03\x12\x03=\x02\x12\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04=\x02<\x13\n\
    \x0c\n\x05\x04\x05\x02\x03\x05\x12\x03=\x02\x07\n\x0c\n\x05\x04\x05\x02\
    \x03\x01\x12\x03=\x08\r\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03=\x10\x11\
    \n\n\n\x02\x04\x06\x12\x04@\0H\x01\n\n\n\x03\x04\x06\x01\x12\x03@\x08\
    \x1b\n\x0c\n\x04\x04\x06\x03\0\x12\x04A\x02D\x03\n\x0c\n\x05\x04\x06\x03\
    \0\x01\x12\x03A\n\x0e\n\r\n\x06\x04\x06\x03\0\x02\0\x12\x03B\x04\x1b\n\
    \x0f\n\x07\x04\x06\x03\0\x02\0\x04\x12\x04B\x04A\x10\n\x0e\n\x07\x04\x06\
    \x03\0\x02\0\x05\x12\x03B\x04\t\n\x0e\n\x07\x04\x06\x03\0\x02\0\x01\x12\
    \x03B\n\x16\n\x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\x03B\x19\x1a\n\r\n\
    \x06\x04\x06\x03\0\x02\x01\x12\x03C\x04\x19\n\x0f\n\x07\x04\x06\x03\0\
    \x02\x01\x04\x12\x04C\x04B\x1b\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x05\x12\
    \x03C\x04\t\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x01\x12\x03C\n\x14\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x01\x03\x12\x03C\x17\x18\n\x0b\n\x04\x04\x06\x02\
    \0\x12\x03E\x02\x1a\n\r\n\x05\x04\x06\x02\0\x04\x12\x04E\x02D\x03\n\x0c\
    \n\x05\x04\x06\x02\0\x05\x12\x03E\x02\x07\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03E\x08\x15\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03E\x18\x19\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x03F\x02\x1a\n\x0c\n\x05\x04\x06\x02\x01\x04\
    \x12\x03F\x02\n\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03F\x0b\x0f\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03F\x10\x15\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03F\x18\x19\n\x0b\n\x04\x04\x06\x02\x02\x12\x03G\x02\x13\n\r\n\
    \x05\x04\x06\x02\x02\x04\x12\x04G\x02F\x1a\n\x0c\n\x05\x04\x06\x02\x02\
    \x05\x12\x03G\x02\x06\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03G\x07\x0e\n\
    \x0c\n\x05\x04\x06\x02\x02\x03\x12\x03G\x11\x12\n\n\n\x02\x04\x07\x12\
    \x04J\0N\x01\n\n\n\x03\x04\x07\x01\x12\x03J\x08\x1d\n\x0b\n\x04\x04\x07\
    \x02\0\x12\x03K\x02\x1a\n\r\n\x05\x04\x07\x02\0\x04\x12\x04K\x02J\x1f\n\
    \x0c\n\x05\x04\x07\x02\0\x05\x12\x03K\x02\x07\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03K\x08\x15\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03K\x18\x19\n\
    \x0b\n\x04\x04\x07\x02\x01\x12\x03L\x02\x1d\n\r\n\x05\x04\x07\x02\x01\
    \x04\x12\x04L\x02K\x1a\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03L\x02\x07\
    \n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03L\x08\x18\n\x0c\n\x05\x04\x07\
    \x02\x01\x03\x12\x03L\x1b\x1c\n\x0b\n\x04\x04\x07\x02\x02\x12\x03M\x02*\
    \n\r\n\x05\x04\x07\x02\x02\x04\x12\x04M\x02L\x1d\n\x0c\n\x05\x04\x07\x02\
    \x02\x05\x12\x03M\x02\x07\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03M\x08%\
    \n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03M()\n\n\n\x02\x04\x08\x12\x04P\0\
    T\x01\n\n\n\x03\x04\x08\x01\x12\x03P\x08!\n\x0b\n\x04\x04\x08\x02\0\x12\
    \x03Q\x02\x1a\n\r\n\x05\x04\x08\x02\0\x04\x12\x04Q\x02P#\n\x0c\n\x05\x04\
    \x08\x02\0\x05\x12\x03Q\x02\x07\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03Q\
    \x08\x15\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03Q\x18\x19\n\x0b\n\x04\x04\
    \x08\x02\x01\x12\x03R\x02\x1d\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04R\x02\
    Q\x1a\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03R\x02\x07\n\x0c\n\x05\x04\
    \x08\x02\x01\x01\x12\x03R\x08\x18\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\
    \x03R\x1b\x1c\n\x0b\n\x04\x04\x08\x02\x02\x12\x03S\x02\x20\n\r\n\x05\x04\
    \x08\x02\x02\x04\x12\x04S\x02R\x1d\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\
    \x03S\x02\x07\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03S\x08\x1b\n\x0c\n\
    \x05\x04\x08\x02\x02\x03\x12\x03S\x1e\x1f\n\n\n\x02\x04\t\x12\x04V\0Y\
    \x01\n\n\n\x03\x04\t\x01\x12\x03V\x08\x18\n\x0b\n\x04\x04\t\x02\0\x12\
    \x03W\x02\x1a\n\r\n\x05\x04\t\x02\0\x04\x12\x04W\x02V\x1a\n\x0c\n\x05\
    \x04\t\x02\0\x05\x12\x03W\x02\x07\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03W\
    \x08\x15\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03W\x18\x19\n\x0b\n\x04\x04\t\
    \x02\x01\x12\x03X\x02\x1d\n\r\n\x05\x04\t\x02\x01\x04\x12\x04X\x02W\x1a\
    \n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03X\x02\x07\n\x0c\n\x05\x04\t\x02\
    \x01\x01\x12\x03X\x08\x18\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03X\x1b\x1c\
    \n\n\n\x02\x04\n\x12\x04[\0^\x01\n\n\n\x03\x04\n\x01\x12\x03[\x08\x1d\n\
    \x0b\n\x04\x04\n\x02\0\x12\x03\\\x02\x1a\n\r\n\x05\x04\n\x02\0\x04\x12\
    \x04\\\x02[\x1f\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03\\\x02\x07\n\x0c\n\
    \x05\x04\n\x02\0\x01\x12\x03\\\x08\x15\n\x0c\n\x05\x04\n\x02\0\x03\x12\
    \x03\\\x18\x19\n\x0b\n\x04\x04\n\x02\x01\x12\x03]\x02\x10\n\r\n\x05\x04\
    \n\x02\x01\x04\x12\x04]\x02\\\x1a\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03]\
    \x02\x07\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03]\x08\x0b\n\x0c\n\x05\x04\
    \n\x02\x01\x03\x12\x03]\x0e\x0f\n\n\n\x02\x04\x0b\x12\x04`\0c\x01\n\n\n\
    \x03\x04\x0b\x01\x12\x03`\x08\x1d\n\x0b\n\x04\x04\x0b\x02\0\x12\x03a\x02\
    \x1a\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04a\x02`\x1f\n\x0c\n\x05\x04\x0b\
    \x02\0\x05\x12\x03a\x02\x07\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03a\x08\
    \x15\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03a\x18\x19\n\x0b\n\x04\x04\x0b\
    \x02\x01\x12\x03b\x02\x18\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04b\x02a\
    \x1a\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03b\x02\x07\n\x0c\n\x05\x04\
    \x0b\x02\x01\x01\x12\x03b\x08\x12\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\
    \x03b\x15\x17\n\n\n\x02\x04\x0c\x12\x04e\0~\x01\n\n\n\x03\x04\x0c\x01\
    \x12\x03e\x08\x1a\n\x0b\n\x04\x04\x0c\x02\0\x12\x03f\x02\x11\n\r\n\x05\
    \x04\x0c\x02\0\x04\x12\x04f\x02e\x1c\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\
    \x03f\x02\x08\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03f\t\x0b\n\x0c\n\x05\
    \x04\x0c\x02\0\x03\x12\x03f\x0e\x10\n\x0c\n\x04\x04\x0c\x03\0\x12\x04h\
    \x02k\x03\n\x0c\n\x05\x04\x0c\x03\0\x01\x12\x03h\n\x16\n\r\n\x06\x04\x0c\
    \x03\0\x02\0\x12\x03i\x04\x1c\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x04\x12\
    \x04i\x04h\x18\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x03i\x04\t\n\x0e\
    \n\x07\x04\x0c\x03\0\x02\0\x01\x12\x03i\n\x17\n\x0e\n\x07\x04\x0c\x03\0\
    \x02\0\x03\x12\x03i\x1a\x1b\n\r\n\x06\x04\x0c\x03\0\x02\x01\x12\x03j\x04\
    \x1a\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x04\x12\x04j\x04i\x1c\n\x0e\n\x07\
    \x04\x0c\x03\0\x02\x01\x05\x12\x03j\x04\t\n\x0e\n\x07\x04\x0c\x03\0\x02\
    \x01\x01\x12\x03j\n\x15\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x03\x12\x03j\
    \x18\x19\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03l\x02\x1a\n\r\n\x05\x04\x0c\
    \x02\x01\x04\x12\x04l\x02k\x03\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03l\
    \x02\x07\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03l\x08\x15\n\x0c\n\x05\
    \x04\x0c\x02\x01\x03\x12\x03l\x18\x19\n\x0b\n\x04\x04\x0c\x02\x02\x12\
    \x03m\x02\x11\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04m\x02l\x1a\n\x0c\n\
    \x05\x04\x0c\x02\x02\x05\x12\x03m\x02\x07\n\x0c\n\x05\x04\x0c\x02\x02\
    \x01\x12\x03m\x08\x0c\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03m\x0f\x10\n\
    \x0b\n\x04\x04\x0c\x02\x03\x12\x03n\x02\x11\n\r\n\x05\x04\x0c\x02\x03\
    \x04\x12\x04n\x02m\x11\n\x0c\n\x05\x04\x0c\x02\x03\x05\x12\x03n\x02\x07\
    \n\x0c\n\x05\x04\x0c\x02\x03\x01\x12\x03n\x08\x0c\n\x0c\n\x05\x04\x0c\
    \x02\x03\x03\x12\x03n\x0f\x10\n\x0b\n\x04\x04\x0c\x02\x04\x12\x03o\x02\
    \x19\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04o\x02n\x11\n\x0c\n\x05\x04\x0c\
    \x02\x04\x05\x12\x03o\x02\x07\n\x0c\n\x05\x04\x0c\x02\x04\x01\x12\x03o\
    \x08\x14\n\x0c\n\x05\x04\x0c\x02\x04\x03\x12\x03o\x17\x18\n\x0b\n\x04\
    \x04\x0c\x02\x05\x12\x03p\x02*\n\x0c\n\x05\x04\x0c\x02\x05\x04\x12\x03p\
    \x02\n\n\x0c\n\x05\x04\x0c\x02\x05\x06\x12\x03p\x0b\x17\n\x0c\n\x05\x04\
    \x0c\x02\x05\x01\x12\x03p\x18%\n\x0c\n\x05\x04\x0c\x02\x05\x03\x12\x03p(\
    )\n\x0b\n\x04\x04\x0c\x02\x06\x12\x03q\x02\x14\n\r\n\x05\x04\x0c\x02\x06\
    \x04\x12\x04q\x02p*\n\x0c\n\x05\x04\x0c\x02\x06\x05\x12\x03q\x02\x07\n\
    \x0c\n\x05\x04\x0c\x02\x06\x01\x12\x03q\x08\x0f\n\x0c\n\x05\x04\x0c\x02\
    \x06\x03\x12\x03q\x12\x13\n\x0b\n\x04\x04\x0c\x02\x07\x12\x03r\x02\x16\n\
    \r\n\x05\x04\x0c\x02\x07\x04\x12\x04r\x02q\x14\n\x0c\n\x05\x04\x0c\x02\
    \x07\x05\x12\x03r\x02\x07\n\x0c\n\x05\x04\x0c\x02\x07\x01\x12\x03r\x08\
    \x11\n\x0c\n\x05\x04\x0c\x02\x07\x03\x12\x03r\x14\x15\n\x0b\n\x04\x04\
    \x0c\x02\x08\x12\x03s\x02\x10\n\r\n\x05\x04\x0c\x02\x08\x04\x12\x04s\x02\
    r\x16\n\x0c\n\x05\x04\x0c\x02\x08\x05\x12\x03s\x02\x07\n\x0c\n\x05\x04\
    \x0c\x02\x08\x01\x12\x03s\x08\x0b\n\x0c\n\x05\x04\x0c\x02\x08\x03\x12\
    \x03s\x0e\x0f\n\x0b\n\x04\x04\x0c\x02\t\x12\x03t\x02\x17\n\r\n\x05\x04\
    \x0c\x02\t\x04\x12\x04t\x02s\x10\n\x0c\n\x05\x04\x0c\x02\t\x05\x12\x03t\
    \x02\x07\n\x0c\n\x05\x04\x0c\x02\t\x01\x12\x03t\x08\x12\n\x0c\n\x05\x04\
    \x0c\x02\t\x03\x12\x03t\x15\x16\n\x0b\n\x04\x04\x0c\x02\n\x12\x03u\x02\
    \x16\n\r\n\x05\x04\x0c\x02\n\x04\x12\x04u\x02t\x17\n\x0c\n\x05\x04\x0c\
    \x02\n\x05\x12\x03u\x02\x07\n\x0c\n\x05\x04\x0c\x02\n\x01\x12\x03u\x08\
    \x10\n\x0c\n\x05\x04\x0c\x02\n\x03\x12\x03u\x13\x15\n\x16\n\x04\x04\x0c\
    \x02\x0b\x12\x03v\x02\x13\"\t\x20useless\n\n\r\n\x05\x04\x0c\x02\x0b\x04\
    \x12\x04v\x02u\x16\n\x0c\n\x05\x04\x0c\x02\x0b\x05\x12\x03v\x02\x07\n\
    \x0c\n\x05\x04\x0c\x02\x0b\x01\x12\x03v\x08\r\n\x0c\n\x05\x04\x0c\x02\
    \x0b\x03\x12\x03v\x10\x12\n\x0b\n\x04\x04\x0c\x02\x0c\x12\x03w\x02\x18\n\
    \r\n\x05\x04\x0c\x02\x0c\x04\x12\x04w\x02v\x13\n\x0c\n\x05\x04\x0c\x02\
    \x0c\x05\x12\x03w\x02\x07\n\x0c\n\x05\x04\x0c\x02\x0c\x01\x12\x03w\x08\
    \x12\n\x0c\n\x05\x04\x0c\x02\x0c\x03\x12\x03w\x15\x17\n\x0b\n\x04\x04\
    \x0c\x02\r\x12\x03x\x02\x19\n\r\n\x05\x04\x0c\x02\r\x04\x12\x04x\x02w\
    \x18\n\x0c\n\x05\x04\x0c\x02\r\x05\x12\x03x\x02\x07\n\x0c\n\x05\x04\x0c\
    \x02\r\x01\x12\x03x\x08\x13\n\x0c\n\x05\x04\x0c\x02\r\x03\x12\x03x\x16\
    \x18\n\x0b\n\x04\x04\x0c\x02\x0e\x12\x03y\x02\x11\n\r\n\x05\x04\x0c\x02\
    \x0e\x04\x12\x04y\x02x\x19\n\x0c\n\x05\x04\x0c\x02\x0e\x05\x12\x03y\x02\
    \x07\n\x0c\n\x05\x04\x0c\x02\x0e\x01\x12\x03y\x08\x0b\n\x0c\n\x05\x04\
    \x0c\x02\x0e\x03\x12\x03y\x0e\x10\n\x0b\n\x04\x04\x0c\x02\x0f\x12\x03z\
    \x02\"\n\r\n\x05\x04\x0c\x02\x0f\x04\x12\x04z\x02y\x11\n\x0c\n\x05\x04\
    \x0c\x02\x0f\x05\x12\x03z\x02\x07\n\x0c\n\x05\x04\x0c\x02\x0f\x01\x12\
    \x03z\x08\x1c\n\x0c\n\x05\x04\x0c\x02\x0f\x03\x12\x03z\x1f!\n\x0b\n\x04\
    \x04\x0c\x02\x10\x12\x03{\x02)\n\r\n\x05\x04\x0c\x02\x10\x04\x12\x04{\
    \x02z\"\n\x0c\n\x05\x04\x0c\x02\x10\x05\x12\x03{\x02\x07\n\x0c\n\x05\x04\
    \x0c\x02\x10\x01\x12\x03{\x08#\n\x0c\n\x05\x04\x0c\x02\x10\x03\x12\x03{&\
    (\n\x0b\n\x04\x04\x0c\x02\x11\x12\x03|\x02)\n\r\n\x05\x04\x0c\x02\x11\
    \x04\x12\x04|\x02{)\n\x0c\n\x05\x04\x0c\x02\x11\x05\x12\x03|\x02\x07\n\
    \x0c\n\x05\x04\x0c\x02\x11\x01\x12\x03|\x08#\n\x0c\n\x05\x04\x0c\x02\x11\
    \x03\x12\x03|&(\n\x0b\n\x04\x04\x0c\x02\x12\x12\x03}\x02)\n\r\n\x05\x04\
    \x0c\x02\x12\x04\x12\x04}\x02|)\n\x0c\n\x05\x04\x0c\x02\x12\x05\x12\x03}\
    \x02\x07\n\x0c\n\x05\x04\x0c\x02\x12\x01\x12\x03}\x08#\n\x0c\n\x05\x04\
    \x0c\x02\x12\x03\x12\x03}&(\n\x0c\n\x02\x04\r\x12\x06\x80\x01\0\x85\x01\
    \x01\n\x0b\n\x03\x04\r\x01\x12\x04\x80\x01\x08%\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\x81\x01\x02\x1a\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\x81\x01\x02\
    \x80\x01'\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x81\x01\x02\x07\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\x81\x01\x08\x15\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\x81\x01\x18\x19\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x82\x01\x02\x17\n\
    \x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x82\x01\x02\x81\x01\x1a\n\r\n\x05\
    \x04\r\x02\x01\x05\x12\x04\x82\x01\x02\x07\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\x82\x01\x08\x12\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x82\x01\x15\
    \x16\n\xa0\x01\n\x04\x04\r\x02\x02\x12\x04\x83\x01\x02\x17\"\x91\x01\x20\
    this\x20field\x20is\x20token\x20name\x20before\x20the\x20proposal\x20ALL\
    OW_SAME_TOKEN_NAME\x20is\x20active,\x20otherwise\x20it\x20is\x20token\
    \x20id\x20and\x20token\x20is\x20should\x20be\x20in\x20string\x20format.\
    \n\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\x83\x01\x02\x82\x01\x17\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\x83\x01\x02\x07\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\x83\x01\x08\x12\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x83\x01\
    \x15\x16\n#\n\x04\x04\r\x02\x03\x12\x04\x84\x01\x02\x13\"\x15\x20the\x20\
    amount\x20of\x20drops\n\n\x0f\n\x05\x04\r\x02\x03\x04\x12\x06\x84\x01\
    \x02\x83\x01\x17\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\x84\x01\x02\x07\n\r\
    \n\x05\x04\r\x02\x03\x01\x12\x04\x84\x01\x08\x0e\n\r\n\x05\x04\r\x02\x03\
    \x03\x12\x04\x84\x01\x11\x12\n\x0c\n\x02\x05\0\x12\x06\x88\x01\0\x8b\x01\
    \x01\n\x0b\n\x03\x05\0\x01\x12\x04\x88\x01\x05\x11\n\x0c\n\x04\x05\0\x02\
    \0\x12\x04\x89\x01\x02\x13\n\r\n\x05\x05\0\x02\0\x01\x12\x04\x89\x01\x02\
    \x0b\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x89\x01\x0e\x12\n\x0c\n\x04\x05\0\
    \x02\x01\x12\x04\x8a\x01\x02\x10\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x8a\
    \x01\x02\x08\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x8a\x01\x0b\x0f\n\x0c\n\
    \x02\x04\x0e\x12\x06\x8d\x01\0\x94\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\x8d\x01\x08\x1d\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x8e\x01\x02\x1a\n\
    \x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\x8e\x01\x02\x8d\x01\x1f\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\x8e\x01\x02\x07\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\x8e\x01\x08\x15\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x8e\x01\x18\
    \x19\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x8f\x01\x02\x1b\n\x0f\n\x05\x04\
    \x0e\x02\x01\x04\x12\x06\x8f\x01\x02\x8e\x01\x1a\n\r\n\x05\x04\x0e\x02\
    \x01\x05\x12\x04\x8f\x01\x02\x07\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \x8f\x01\x08\x16\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x8f\x01\x19\x1a\n\
    \x0c\n\x04\x04\x0e\x02\x02\x12\x04\x90\x01\x02\x1c\n\x0f\n\x05\x04\x0e\
    \x02\x02\x04\x12\x06\x90\x01\x02\x8f\x01\x1b\n\r\n\x05\x04\x0e\x02\x02\
    \x05\x12\x04\x90\x01\x02\x07\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x90\
    \x01\x08\x17\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x90\x01\x1a\x1b\n\x0c\
    \n\x04\x04\x0e\x02\x03\x12\x04\x92\x01\x02\x1d\n\x0f\n\x05\x04\x0e\x02\
    \x03\x04\x12\x06\x92\x01\x02\x90\x01\x1c\n\r\n\x05\x04\x0e\x02\x03\x06\
    \x12\x04\x92\x01\x02\x0e\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x92\x01\
    \x0f\x17\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x92\x01\x1a\x1c\n\x0c\n\
    \x04\x04\x0e\x02\x04\x12\x04\x93\x01\x02\x1e\n\x0f\n\x05\x04\x0e\x02\x04\
    \x04\x12\x06\x93\x01\x02\x92\x01\x1d\n\r\n\x05\x04\x0e\x02\x04\x05\x12\
    \x04\x93\x01\x02\x07\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\x93\x01\x08\
    \x18\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x93\x01\x1b\x1d\n\x0c\n\x02\
    \x04\x0f\x12\x06\x96\x01\0\x9b\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \x96\x01\x08\x1f\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x97\x01\x02\x1a\n\x0f\
    \n\x05\x04\x0f\x02\0\x04\x12\x06\x97\x01\x02\x96\x01!\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\x97\x01\x02\x07\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \x97\x01\x08\x15\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x97\x01\x18\x19\n\
    \x0c\n\x04\x04\x0f\x02\x01\x12\x04\x99\x01\x02\x1d\n\x0f\n\x05\x04\x0f\
    \x02\x01\x04\x12\x06\x99\x01\x02\x97\x01\x1a\n\r\n\x05\x04\x0f\x02\x01\
    \x06\x12\x04\x99\x01\x02\x0e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x99\
    \x01\x0f\x17\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x99\x01\x1a\x1c\n\x0c\
    \n\x04\x04\x0f\x02\x02\x12\x04\x9a\x01\x02\x1e\n\x0f\n\x05\x04\x0f\x02\
    \x02\x04\x12\x06\x9a\x01\x02\x99\x01\x1d\n\r\n\x05\x04\x0f\x02\x02\x05\
    \x12\x04\x9a\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x9a\x01\
    \x08\x18\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x9a\x01\x1b\x1d\n\x0c\n\
    \x02\x04\x10\x12\x06\x9d\x01\0\x9f\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\x9d\x01\x08\x1d\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x9e\x01\x02\x1a\n\
    \x0f\n\x05\x04\x10\x02\0\x04\x12\x06\x9e\x01\x02\x9d\x01\x1f\n\r\n\x05\
    \x04\x10\x02\0\x05\x12\x04\x9e\x01\x02\x07\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\x9e\x01\x08\x15\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x9e\x01\x18\
    \x19\n\x0c\n\x02\x04\x11\x12\x06\xa1\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\
    \x11\x01\x12\x04\xa1\x01\x08\x1f\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xa2\
    \x01\x02\x1a\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xa2\x01\x02\xa1\x01!\
    \n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xa2\x01\x02\x07\n\r\n\x05\x04\x11\
    \x02\0\x01\x12\x04\xa2\x01\x08\x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\
    \xa2\x01\x18\x19\n\x0c\n\x02\x04\x12\x12\x06\xa5\x01\0\xab\x01\x01\n\x0b\
    \n\x03\x04\x12\x01\x12\x04\xa5\x01\x08\x1b\n\x0c\n\x04\x04\x12\x02\0\x12\
    \x04\xa6\x01\x02\x1a\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\xa6\x01\x02\
    \xa5\x01\x1d\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xa6\x01\x02\x07\n\r\n\
    \x05\x04\x12\x02\0\x01\x12\x04\xa6\x01\x08\x15\n\r\n\x05\x04\x12\x02\0\
    \x03\x12\x04\xa6\x01\x18\x19\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xa7\x01\
    \x02\x18\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\x06\xa7\x01\x02\xa6\x01\x1a\
    \n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xa7\x01\x02\x07\n\r\n\x05\x04\x12\
    \x02\x01\x01\x12\x04\xa7\x01\x08\x13\n\r\n\x05\x04\x12\x02\x01\x03\x12\
    \x04\xa7\x01\x16\x17\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xa8\x01\x02\x10\
    \n\x0f\n\x05\x04\x12\x02\x02\x04\x12\x06\xa8\x01\x02\xa7\x01\x18\n\r\n\
    \x05\x04\x12\x02\x02\x05\x12\x04\xa8\x01\x02\x07\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xa8\x01\x08\x0b\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\
    \xa8\x01\x0e\x0f\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xa9\x01\x02\x16\n\
    \x0f\n\x05\x04\x12\x02\x03\x04\x12\x06\xa9\x01\x02\xa8\x01\x10\n\r\n\x05\
    \x04\x12\x02\x03\x05\x12\x04\xa9\x01\x02\x07\n\r\n\x05\x04\x12\x02\x03\
    \x01\x12\x04\xa9\x01\x08\x11\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xa9\
    \x01\x14\x15\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xaa\x01\x02\x1d\n\x0f\n\
    \x05\x04\x12\x02\x04\x04\x12\x06\xaa\x01\x02\xa9\x01\x16\n\r\n\x05\x04\
    \x12\x02\x04\x05\x12\x04\xaa\x01\x02\x07\n\r\n\x05\x04\x12\x02\x04\x01\
    \x12\x04\xaa\x01\x08\x18\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xaa\x01\
    \x1b\x1c\n\x0c\n\x02\x04\x13\x12\x06\xad\x01\0\xb0\x01\x01\n\x0b\n\x03\
    \x04\x13\x01\x12\x04\xad\x01\x08\x1e\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \xae\x01\x02\x1a\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xae\x01\x02\xad\
    \x01\x20\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xae\x01\x02\x07\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\xae\x01\x08\x15\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xae\x01\x18\x19\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xaf\x01\x02\
    #\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\xaf\x01\x02\xae\x01\x1a\n\r\n\
    \x05\x04\x13\x02\x01\x06\x12\x04\xaf\x01\x02\x13\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\xaf\x01\x14\x1e\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \xaf\x01!\"\n\x0c\n\x02\x04\x14\x12\x06\xb2\x01\0\xb6\x01\x01\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xb2\x01\x08\x1f\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\xb3\x01\x02\x1a\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xb3\x01\x02\
    \xb2\x01!\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xb3\x01\x02\x07\n\r\n\x05\
    \x04\x14\x02\0\x01\x12\x04\xb3\x01\x08\x15\n\r\n\x05\x04\x14\x02\0\x03\
    \x12\x04\xb3\x01\x18\x19\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xb4\x01\x02\
    \x18\n\x0f\n\x05\x04\x14\x02\x01\x04\x12\x06\xb4\x01\x02\xb3\x01\x1a\n\r\
    \n\x05\x04\x14\x02\x01\x05\x12\x04\xb4\x01\x02\x07\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xb4\x01\x08\x13\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xb4\x01\x16\x17\n&\n\x04\x04\x14\x02\x02\x12\x04\xb5\x01\x02\x1b\"\x18\
    \x20add\x20or\x20remove\x20approval\n\n\x0f\n\x05\x04\x14\x02\x02\x04\
    \x12\x06\xb5\x01\x02\xb4\x01\x18\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\
    \xb5\x01\x02\x06\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xb5\x01\x07\x16\n\
    \r\n\x05\x04\x14\x02\x02\x03\x12\x04\xb5\x01\x19\x1a\n\x0c\n\x02\x04\x15\
    \x12\x06\xb8\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xb8\x01\
    \x08\x1e\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xb9\x01\x02\x1a\n\x0f\n\x05\
    \x04\x15\x02\0\x04\x12\x06\xb9\x01\x02\xb8\x01\x20\n\r\n\x05\x04\x15\x02\
    \0\x05\x12\x04\xb9\x01\x02\x07\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xb9\
    \x01\x08\x15\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb9\x01\x18\x19\n\x0c\n\
    \x04\x04\x15\x02\x01\x12\x04\xba\x01\x02\x18\n\x0f\n\x05\x04\x15\x02\x01\
    \x04\x12\x06\xba\x01\x02\xb9\x01\x1a\n\r\n\x05\x04\x15\x02\x01\x05\x12\
    \x04\xba\x01\x02\x07\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xba\x01\x08\
    \x13\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xba\x01\x16\x17\n\x0c\n\x02\
    \x04\x16\x12\x06\xbd\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \xbd\x01\x08\x1b\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xbe\x01\x02\x1a\n\x0f\
    \n\x05\x04\x16\x02\0\x04\x12\x06\xbe\x01\x02\xbd\x01\x1d\n\r\n\x05\x04\
    \x16\x02\0\x05\x12\x04\xbe\x01\x02\x07\n\r\n\x05\x04\x16\x02\0\x01\x12\
    \x04\xbe\x01\x08\x15\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbe\x01\x18\x19\
    \n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xbf\x01\x02!\n\x0f\n\x05\x04\x16\
    \x02\x01\x04\x12\x06\xbf\x01\x02\xbe\x01\x1a\n\r\n\x05\x04\x16\x02\x01\
    \x06\x12\x04\xbf\x01\x02\x0f\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xbf\
    \x01\x10\x1c\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xbf\x01\x1f\x20\n\x0c\
    \n\x04\x04\x16\x02\x02\x12\x04\xc0\x01\x02\x1d\n\x0f\n\x05\x04\x16\x02\
    \x02\x04\x12\x06\xc0\x01\x02\xbf\x01!\n\r\n\x05\x04\x16\x02\x02\x05\x12\
    \x04\xc0\x01\x02\x07\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xc0\x01\x08\
    \x18\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xc0\x01\x1b\x1c\n\x0c\n\x04\
    \x04\x16\x02\x03\x12\x04\xc1\x01\x02\x15\n\x0f\n\x05\x04\x16\x02\x03\x04\
    \x12\x06\xc1\x01\x02\xc0\x01\x1d\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\
    \xc1\x01\x02\x07\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xc1\x01\x08\x10\n\
    \r\n\x05\x04\x16\x02\x03\x03\x12\x04\xc1\x01\x13\x14\n\x0c\n\x02\x04\x17\
    \x12\x06\xc4\x01\0\xcb\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xc4\x01\
    \x08\x1c\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xc5\x01\x02\x1a\n\x0f\n\x05\
    \x04\x17\x02\0\x04\x12\x06\xc5\x01\x02\xc4\x01\x1e\n\r\n\x05\x04\x17\x02\
    \0\x05\x12\x04\xc5\x01\x02\x07\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc5\
    \x01\x08\x15\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xc5\x01\x18\x19\n\x0c\n\
    \x04\x04\x17\x02\x01\x12\x04\xc6\x01\x02\x1d\n\x0f\n\x05\x04\x17\x02\x01\
    \x04\x12\x06\xc6\x01\x02\xc5\x01\x1a\n\r\n\x05\x04\x17\x02\x01\x05\x12\
    \x04\xc6\x01\x02\x07\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xc6\x01\x08\
    \x18\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xc6\x01\x1b\x1c\n\x0c\n\x04\
    \x04\x17\x02\x02\x12\x04\xc7\x01\x02\x17\n\x0f\n\x05\x04\x17\x02\x02\x04\
    \x12\x06\xc7\x01\x02\xc6\x01\x1d\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\
    \xc7\x01\x02\x07\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xc7\x01\x08\x12\n\
    \r\n\x05\x04\x17\x02\x02\x03\x12\x04\xc7\x01\x15\x16\n\x0c\n\x04\x04\x17\
    \x02\x03\x12\x04\xc8\x01\x02\x11\n\x0f\n\x05\x04\x17\x02\x03\x04\x12\x06\
    \xc8\x01\x02\xc7\x01\x17\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xc8\x01\
    \x02\x07\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xc8\x01\x08\x0c\n\r\n\x05\
    \x04\x17\x02\x03\x03\x12\x04\xc8\x01\x0f\x10\n\x0c\n\x04\x04\x17\x02\x04\
    \x12\x04\xc9\x01\x02\x1d\n\x0f\n\x05\x04\x17\x02\x04\x04\x12\x06\xc9\x01\
    \x02\xc8\x01\x11\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xc9\x01\x02\x07\n\
    \r\n\x05\x04\x17\x02\x04\x01\x12\x04\xc9\x01\x08\x18\n\r\n\x05\x04\x17\
    \x02\x04\x03\x12\x04\xc9\x01\x1b\x1c\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\
    \xca\x01\x02\x15\n\x0f\n\x05\x04\x17\x02\x05\x04\x12\x06\xca\x01\x02\xc9\
    \x01\x1d\n\r\n\x05\x04\x17\x02\x05\x05\x12\x04\xca\x01\x02\x07\n\r\n\x05\
    \x04\x17\x02\x05\x01\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x17\x02\x05\
    \x03\x12\x04\xca\x01\x13\x14\n\x0c\n\x02\x04\x18\x12\x06\xcd\x01\0\xd0\
    \x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xcd\x01\x08\x1a\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\xce\x01\x02\x1a\n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\
    \xce\x01\x02\xcd\x01\x1c\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xce\x01\x02\
    \x07\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xce\x01\x08\x15\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\xce\x01\x18\x19\n2\n\x04\x04\x18\x02\x01\x12\x04\
    \xcf\x01\x02\x12\"$\x20trx\x20quantity\x20for\x20buy\x20storage\x20(sun)\
    \n\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\xcf\x01\x02\xce\x01\x1a\n\r\n\
    \x05\x04\x18\x02\x01\x05\x12\x04\xcf\x01\x02\x07\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xcf\x01\x08\r\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xcf\
    \x01\x10\x11\n\x0c\n\x02\x04\x19\x12\x06\xd2\x01\0\xd5\x01\x01\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\xd2\x01\x08\x1f\n\x0c\n\x04\x04\x19\x02\0\x12\
    \x04\xd3\x01\x02\x1a\n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\xd3\x01\x02\
    \xd2\x01!\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xd3\x01\x02\x07\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xd3\x01\x08\x15\n\r\n\x05\x04\x19\x02\0\x03\
    \x12\x04\xd3\x01\x18\x19\n%\n\x04\x04\x19\x02\x01\x12\x04\xd4\x01\x02\
    \x12\"\x17\x20storage\x20bytes\x20for\x20buy\n\n\x0f\n\x05\x04\x19\x02\
    \x01\x04\x12\x06\xd4\x01\x02\xd3\x01\x1a\n\r\n\x05\x04\x19\x02\x01\x05\
    \x12\x04\xd4\x01\x02\x07\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd4\x01\
    \x08\r\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd4\x01\x10\x11\n\x0c\n\x02\
    \x04\x1a\x12\x06\xd7\x01\0\xda\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\
    \xd7\x01\x08\x1b\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xd8\x01\x02\x1a\n\x0f\
    \n\x05\x04\x1a\x02\0\x04\x12\x06\xd8\x01\x02\xd7\x01\x1d\n\r\n\x05\x04\
    \x1a\x02\0\x05\x12\x04\xd8\x01\x02\x07\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\xd8\x01\x08\x15\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd8\x01\x18\x19\
    \n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd9\x01\x02\x1a\n\x0f\n\x05\x04\x1a\
    \x02\x01\x04\x12\x06\xd9\x01\x02\xd8\x01\x1a\n\r\n\x05\x04\x1a\x02\x01\
    \x05\x12\x04\xd9\x01\x02\x07\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd9\
    \x01\x08\x15\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xd9\x01\x18\x19\n\x0c\
    \n\x02\x04\x1b\x12\x06\xdc\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xdc\x01\x08\x1e\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xdd\x01\x02\x1a\n\
    \x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xdd\x01\x02\xdc\x01\x20\n\r\n\x05\
    \x04\x1b\x02\0\x05\x12\x04\xdd\x01\x02\x07\n\r\n\x05\x04\x1b\x02\0\x01\
    \x12\x04\xdd\x01\x08\x15\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xdd\x01\x18\
    \x19\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xde\x01\x02\x1b\n\x0f\n\x05\x04\
    \x1b\x02\x01\x04\x12\x06\xde\x01\x02\xdd\x01\x1a\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\xde\x01\x02\x07\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \xde\x01\x08\x16\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xde\x01\x19\x1a\n\
    \x0c\n\x04\x04\x1b\x02\x02\x12\x04\xdf\x01\x02\x20\n\x0f\n\x05\x04\x1b\
    \x02\x02\x04\x12\x06\xdf\x01\x02\xde\x01\x1b\n\r\n\x05\x04\x1b\x02\x02\
    \x05\x12\x04\xdf\x01\x02\x07\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xdf\
    \x01\x08\x1b\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xdf\x01\x1e\x1f\n\x0c\
    \n\x04\x04\x1b\x02\x03\x12\x04\xe0\x01\x02\x1c\n\x0f\n\x05\x04\x1b\x02\
    \x03\x04\x12\x06\xe0\x01\x02\xdf\x01\x20\n\r\n\x05\x04\x1b\x02\x03\x05\
    \x12\x04\xe0\x01\x02\x07\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\xe0\x01\
    \x08\x17\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xe0\x01\x1a\x1b\n\x0c\n\
    \x04\x04\x1b\x02\x04\x12\x04\xe1\x01\x02!\n\x0f\n\x05\x04\x1b\x02\x04\
    \x04\x12\x06\xe1\x01\x02\xe0\x01\x1c\n\r\n\x05\x04\x1b\x02\x04\x05\x12\
    \x04\xe1\x01\x02\x07\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xe1\x01\x08\
    \x1c\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xe1\x01\x1f\x20\n\x0c\n\x02\
    \x04\x1c\x12\x06\xe4\x01\0\xe9\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\
    \xe4\x01\x08\x1e\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xe5\x01\x02\x1a\n\x0f\
    \n\x05\x04\x1c\x02\0\x04\x12\x06\xe5\x01\x02\xe4\x01\x20\n\r\n\x05\x04\
    \x1c\x02\0\x05\x12\x04\xe5\x01\x02\x07\n\r\n\x05\x04\x1c\x02\0\x01\x12\
    \x04\xe5\x01\x08\x15\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe5\x01\x18\x19\
    \n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xe6\x01\x02\x18\n\x0f\n\x05\x04\x1c\
    \x02\x01\x04\x12\x06\xe6\x01\x02\xe5\x01\x1a\n\r\n\x05\x04\x1c\x02\x01\
    \x05\x12\x04\xe6\x01\x02\x07\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xe6\
    \x01\x08\x13\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xe6\x01\x16\x17\n\x0c\
    \n\x04\x04\x1c\x02\x02\x12\x04\xe7\x01\x02\x15\n\x0f\n\x05\x04\x1c\x02\
    \x02\x04\x12\x06\xe7\x01\x02\xe6\x01\x18\n\r\n\x05\x04\x1c\x02\x02\x05\
    \x12\x04\xe7\x01\x02\x07\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xe7\x01\
    \x08\x10\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xe7\x01\x13\x14\n\x0c\n\
    \x04\x04\x1c\x02\x03\x12\x04\xe8\x01\x02\x12\n\x0f\n\x05\x04\x1c\x02\x03\
    \x04\x12\x06\xe8\x01\x02\xe7\x01\x15\n\r\n\x05\x04\x1c\x02\x03\x05\x12\
    \x04\xe8\x01\x02\x07\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xe8\x01\x08\r\
    \n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xe8\x01\x10\x11\n\x0c\n\x02\x04\
    \x1d\x12\x06\xeb\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xeb\
    \x01\x08\x20\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xec\x01\x02\x1a\n\x0f\n\
    \x05\x04\x1d\x02\0\x04\x12\x06\xec\x01\x02\xeb\x01\"\n\r\n\x05\x04\x1d\
    \x02\0\x05\x12\x04\xec\x01\x02\x07\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\
    \xec\x01\x08\x15\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xec\x01\x18\x19\n\
    \x0c\n\x04\x04\x1d\x02\x01\x12\x04\xed\x01\x02\x18\n\x0f\n\x05\x04\x1d\
    \x02\x01\x04\x12\x06\xed\x01\x02\xec\x01\x1a\n\r\n\x05\x04\x1d\x02\x01\
    \x05\x12\x04\xed\x01\x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xed\
    \x01\x08\x13\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xed\x01\x16\x17\n\x0c\
    \n\x04\x04\x1d\x02\x02\x12\x04\xee\x01\x02\x15\n\x0f\n\x05\x04\x1d\x02\
    \x02\x04\x12\x06\xee\x01\x02\xed\x01\x18\n\r\n\x05\x04\x1d\x02\x02\x05\
    \x12\x04\xee\x01\x02\x07\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xee\x01\
    \x08\x10\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xee\x01\x13\x14\n\x0c\n\
    \x04\x04\x1d\x02\x03\x12\x04\xef\x01\x02\x12\n\x0f\n\x05\x04\x1d\x02\x03\
    \x04\x12\x06\xef\x01\x02\xee\x01\x15\n\r\n\x05\x04\x1d\x02\x03\x05\x12\
    \x04\xef\x01\x02\x07\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xef\x01\x08\r\
    \n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xef\x01\x10\x11\n\x0c\n\x02\x04\
    \x1e\x12\x06\xf2\x01\0\xf8\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xf2\
    \x01\x08#\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xf3\x01\x02\x1a\n\x0f\n\x05\
    \x04\x1e\x02\0\x04\x12\x06\xf3\x01\x02\xf2\x01%\n\r\n\x05\x04\x1e\x02\0\
    \x05\x12\x04\xf3\x01\x02\x07\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xf3\x01\
    \x08\x15\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xf3\x01\x18\x19\n\x0c\n\x04\
    \x04\x1e\x02\x01\x12\x04\xf4\x01\x02\x18\n\x0f\n\x05\x04\x1e\x02\x01\x04\
    \x12\x06\xf4\x01\x02\xf3\x01\x1a\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\
    \xf4\x01\x02\x07\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf4\x01\x08\x13\n\
    \r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf4\x01\x16\x17\n\x0c\n\x04\x04\x1e\
    \x02\x02\x12\x04\xf5\x01\x02\x15\n\x0f\n\x05\x04\x1e\x02\x02\x04\x12\x06\
    \xf5\x01\x02\xf4\x01\x18\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xf5\x01\
    \x02\x07\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xf5\x01\x08\x10\n\r\n\x05\
    \x04\x1e\x02\x02\x03\x12\x04\xf5\x01\x13\x14\n\x0c\n\x04\x04\x1e\x02\x03\
    \x12\x04\xf6\x01\x02\x12\n\x0f\n\x05\x04\x1e\x02\x03\x04\x12\x06\xf6\x01\
    \x02\xf5\x01\x15\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\xf6\x01\x02\x07\n\
    \r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xf6\x01\x08\r\n\r\n\x05\x04\x1e\x02\
    \x03\x03\x12\x04\xf6\x01\x10\x11\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\xf7\
    \x01\x02\x15\n\x0f\n\x05\x04\x1e\x02\x04\x04\x12\x06\xf7\x01\x02\xf6\x01\
    \x12\n\r\n\x05\x04\x1e\x02\x04\x05\x12\x04\xf7\x01\x02\x07\n\r\n\x05\x04\
    \x1e\x02\x04\x01\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\x1e\x02\x04\x03\
    \x12\x04\xf7\x01\x13\x14\n\x0c\n\x02\x04\x1f\x12\x06\xfa\x01\0\xff\x01\
    \x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xfa\x01\x08'\n\x0c\n\x04\x04\x1f\
    \x02\0\x12\x04\xfb\x01\x02\x1a\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xfb\
    \x01\x02\xfa\x01)\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xfb\x01\x02\x07\n\
    \r\n\x05\x04\x1f\x02\0\x01\x12\x04\xfb\x01\x08\x15\n\r\n\x05\x04\x1f\x02\
    \0\x03\x12\x04\xfb\x01\x18\x19\n\"\n\x04\x04\x1f\x02\x01\x12\x04\xfc\x01\
    \x02\x17\"\x14Empty\x20is\x20invalidate\n\n\x0f\n\x05\x04\x1f\x02\x01\
    \x04\x12\x06\xfc\x01\x02\xfb\x01\x1a\n\r\n\x05\x04\x1f\x02\x01\x06\x12\
    \x04\xfc\x01\x02\x0c\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xfc\x01\r\x12\
    \n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xfc\x01\x15\x16\n\x1b\n\x04\x04\
    \x1f\x02\x02\x12\x04\xfd\x01\x02\x19\"\rCan\x20be\x20empty\n\n\x0f\n\x05\
    \x04\x1f\x02\x02\x04\x12\x06\xfd\x01\x02\xfc\x01\x17\n\r\n\x05\x04\x1f\
    \x02\x02\x06\x12\x04\xfd\x01\x02\x0c\n\r\n\x05\x04\x1f\x02\x02\x01\x12\
    \x04\xfd\x01\r\x14\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xfd\x01\x17\x18\
    \n\"\n\x04\x04\x1f\x02\x03\x12\x04\xfe\x01\x02\"\"\x14Empty\x20is\x20inv\
    alidate\n\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\xfe\x01\x02\n\n\r\n\x05\
    \x04\x1f\x02\x03\x06\x12\x04\xfe\x01\x0b\x15\n\r\n\x05\x04\x1f\x02\x03\
    \x01\x12\x04\xfe\x01\x16\x1d\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xfe\
    \x01\x20!b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
